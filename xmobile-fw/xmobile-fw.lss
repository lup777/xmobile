
xmobile-fw.elf:     формат файла elf32-avr

Разделы:
Инд Имя           Размер    VMA       LMA       Файл      Вырав
  0 .data         00000050  00800100  00002f10  00002fa4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002f10  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000068e  00800150  00800150  00002ff4  2**0
                  ALLOC
  3 .stab         0000a6a4  00000000  00000000  00002ff4  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00004a7a  00000000  00000000  0000d698  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      00000011  00000000  00000000  00012112  2**0
                  CONTENTS, READONLY
  6 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00012124  2**2
                  CONTENTS, READONLY

Дизассемблирование раздела .text:

00000000 <__vectors>:
       0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
       4:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
       8:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
       c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      10:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      14:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      18:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      1c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      20:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      24:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      28:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      2c:	0c 94 29 14 	jmp	0x2852	; 0x2852 <__vector_11>
      30:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      34:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      38:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      3c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      40:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      44:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      48:	0c 94 5e 01 	jmp	0x2bc	; 0x2bc <__vector_18>
      4c:	0c 94 9e 01 	jmp	0x33c	; 0x33c <__vector_19>
      50:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      54:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      58:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      5c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      60:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      64:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>

00000068 <__ctors_end>:
      68:	11 24       	eor	r1, r1
      6a:	1f be       	out	0x3f, r1	; 63
      6c:	cf ef       	ldi	r28, 0xFF	; 255
      6e:	d8 e0       	ldi	r29, 0x08	; 8
      70:	de bf       	out	0x3e, r29	; 62
      72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
      74:	11 e0       	ldi	r17, 0x01	; 1
      76:	a0 e0       	ldi	r26, 0x00	; 0
      78:	b1 e0       	ldi	r27, 0x01	; 1
      7a:	e0 e1       	ldi	r30, 0x10	; 16
      7c:	ff e2       	ldi	r31, 0x2F	; 47
      7e:	02 c0       	rjmp	.+4      	; 0x84 <__do_copy_data+0x10>
      80:	05 90       	lpm	r0, Z+
      82:	0d 92       	st	X+, r0
      84:	a0 35       	cpi	r26, 0x50	; 80
      86:	b1 07       	cpc	r27, r17
      88:	d9 f7       	brne	.-10     	; 0x80 <__do_copy_data+0xc>

0000008a <__do_clear_bss>:
      8a:	27 e0       	ldi	r18, 0x07	; 7
      8c:	a0 e5       	ldi	r26, 0x50	; 80
      8e:	b1 e0       	ldi	r27, 0x01	; 1
      90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
      92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:
      94:	ae 3d       	cpi	r26, 0xDE	; 222
      96:	b2 07       	cpc	r27, r18
      98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>
      9a:	0e 94 a4 16 	call	0x2d48	; 0x2d48 <main>
      9e:	0c 94 86 17 	jmp	0x2f0c	; 0x2f0c <_exit>

000000a2 <__bad_interrupt>:
      a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a6 <vErrorChecks>:
{
static portBASE_TYPE xErrorHasOccurred = pdFALSE;

	if( xAreIntegerMathsTaskStillRunning() != pdTRUE )
	{
		xErrorHasOccurred = pdTRUE;
      a6:	c1 e0       	ldi	r28, 0x01	; 1

	/* Cycle for ever, delaying then checking all the other tasks are still
	operating without error. */
	for( ;; )
	{
		vTaskDelay( mainCHECK_PERIOD );
      a8:	88 eb       	ldi	r24, 0xB8	; 184
      aa:	9b e0       	ldi	r25, 0x0B	; 11
      ac:	0e 94 c4 06 	call	0xd88	; 0xd88 <vTaskDelay>

		/* Perform a bit of 32bit maths to ensure the registers used by the
		integer tasks get some exercise. The result here is not important -
		see the demo application documentation for more info. */
		ulDummyVariable *= 3;
      b0:	20 91 00 01 	lds	r18, 0x0100
      b4:	30 91 01 01 	lds	r19, 0x0101
      b8:	40 91 02 01 	lds	r20, 0x0102
      bc:	50 91 03 01 	lds	r21, 0x0103
      c0:	a3 e0       	ldi	r26, 0x03	; 3
      c2:	b0 e0       	ldi	r27, 0x00	; 0
      c4:	0e 94 3d 17 	call	0x2e7a	; 0x2e7a <__muluhisi3>
      c8:	60 93 00 01 	sts	0x0100, r22
      cc:	70 93 01 01 	sts	0x0101, r23
      d0:	80 93 02 01 	sts	0x0102, r24
      d4:	90 93 03 01 	sts	0x0103, r25

static void prvCheckOtherTasksAreStillRunning( void )
{
static portBASE_TYPE xErrorHasOccurred = pdFALSE;

	if( xAreIntegerMathsTaskStillRunning() != pdTRUE )
      d8:	0e 94 5d 15 	call	0x2aba	; 0x2aba <xAreIntegerMathsTaskStillRunning>
      dc:	81 30       	cpi	r24, 0x01	; 1
      de:	11 f0       	breq	.+4      	; 0xe4 <vErrorChecks+0x3e>
	{
		xErrorHasOccurred = pdTRUE;
      e0:	c0 93 50 01 	sts	0x0150, r28
	}

	if( xAreComTestTasksStillRunning() != pdTRUE )
      e4:	0e 94 9b 16 	call	0x2d36	; 0x2d36 <xAreComTestTasksStillRunning>
      e8:	81 30       	cpi	r24, 0x01	; 1
      ea:	11 f0       	breq	.+4      	; 0xf0 <vErrorChecks+0x4a>
	{
		xErrorHasOccurred = pdTRUE;
      ec:	c0 93 50 01 	sts	0x0150, r28
	}

	if( xArePollingQueuesStillRunning() != pdTRUE )
      f0:	0e 94 fd 15 	call	0x2bfa	; 0x2bfa <xArePollingQueuesStillRunning>
      f4:	81 30       	cpi	r24, 0x01	; 1
      f6:	11 f0       	breq	.+4      	; 0xfc <vErrorChecks+0x56>
	{
		xErrorHasOccurred = pdTRUE;
      f8:	c0 93 50 01 	sts	0x0150, r28
	}

	if( xAreRegTestTasksStillRunning() != pdTRUE )
      fc:	0e 94 42 03 	call	0x684	; 0x684 <xAreRegTestTasksStillRunning>
     100:	81 30       	cpi	r24, 0x01	; 1
     102:	11 f0       	breq	.+4      	; 0x108 <vErrorChecks+0x62>
	{
		xErrorHasOccurred = pdTRUE;
     104:	c0 93 50 01 	sts	0x0150, r28
	}

	if( xErrorHasOccurred == pdFALSE )
     108:	80 91 50 01 	lds	r24, 0x0150
     10c:	81 11       	cpse	r24, r1
     10e:	cc cf       	rjmp	.-104    	; 0xa8 <vErrorChecks+0x2>
	{
		/* Toggle the LED if everything is okay so we know if an error occurs even if not
		using console IO. */
		vParTestToggleLED( mainCHECK_TASK_LED );
     110:	85 e0       	ldi	r24, 0x05	; 5
     112:	0e 94 ba 00 	call	0x174	; 0x174 <vParTestToggleLED>
     116:	c8 cf       	rjmp	.-112    	; 0xa8 <vErrorChecks+0x2>

00000118 <vApplicationIdleHook>:
}
/*-----------------------------------------------------------*/

void vApplicationIdleHook( void )
{
	vCoRoutineSchedule();
     118:	0c 94 84 10 	jmp	0x2108	; 0x2108 <vCoRoutineSchedule>

0000011c <vParTestInitialise>:

/*-----------------------------------------------------------*/

void vParTestInitialise( void )
{
	ucCurrentOutputValue = partstALL_OUTPUTS_OFF;
     11c:	8f ef       	ldi	r24, 0xFF	; 255
     11e:	80 93 04 01 	sts	0x0104, r24

	/* Set port B direction to outputs.  Start with all output off. */
	DDRB = partstALL_BITS_OUTPUT;
     122:	84 b9       	out	0x04, r24	; 4
	PORTB = ucCurrentOutputValue;
     124:	80 91 04 01 	lds	r24, 0x0104
     128:	85 b9       	out	0x05, r24	; 5
     12a:	08 95       	ret

0000012c <vParTestSetLED>:
}
/*-----------------------------------------------------------*/

void vParTestSetLED( unsigned portBASE_TYPE uxLED, signed portBASE_TYPE xValue )
{
     12c:	1f 93       	push	r17
     12e:	cf 93       	push	r28
     130:	df 93       	push	r29
unsigned char ucBit = ( unsigned char ) 1;

	if( uxLED <= partstMAX_OUTPUT_LED )
     132:	88 30       	cpi	r24, 0x08	; 8
     134:	d8 f4       	brcc	.+54     	; 0x16c <vParTestSetLED+0x40>
     136:	16 2f       	mov	r17, r22
	{
		ucBit <<= uxLED;	
     138:	c1 e0       	ldi	r28, 0x01	; 1
     13a:	d0 e0       	ldi	r29, 0x00	; 0
     13c:	01 c0       	rjmp	.+2      	; 0x140 <vParTestSetLED+0x14>
     13e:	cc 0f       	add	r28, r28
     140:	8a 95       	dec	r24
     142:	ea f7       	brpl	.-6      	; 0x13e <vParTestSetLED+0x12>

		vTaskSuspendAll();
     144:	0e 94 52 05 	call	0xaa4	; 0xaa4 <vTaskSuspendAll>
		{
			if( xValue == pdTRUE )
			{
				ucBit ^= ( unsigned char ) 0xff;
				ucCurrentOutputValue &= ucBit;
     148:	80 91 04 01 	lds	r24, 0x0104
	{
		ucBit <<= uxLED;	

		vTaskSuspendAll();
		{
			if( xValue == pdTRUE )
     14c:	11 30       	cpi	r17, 0x01	; 1
     14e:	19 f4       	brne	.+6      	; 0x156 <vParTestSetLED+0x2a>
			{
				ucBit ^= ( unsigned char ) 0xff;
     150:	c0 95       	com	r28
				ucCurrentOutputValue &= ucBit;
     152:	c8 23       	and	r28, r24
     154:	01 c0       	rjmp	.+2      	; 0x158 <vParTestSetLED+0x2c>
			}
			else
			{
				ucCurrentOutputValue |= ucBit;
     156:	c8 2b       	or	r28, r24
     158:	c0 93 04 01 	sts	0x0104, r28
			}

			PORTB = ucCurrentOutputValue;
     15c:	80 91 04 01 	lds	r24, 0x0104
     160:	85 b9       	out	0x05, r24	; 5
		}
		xTaskResumeAll();
	}
}
     162:	df 91       	pop	r29
     164:	cf 91       	pop	r28
     166:	1f 91       	pop	r17
				ucCurrentOutputValue |= ucBit;
			}

			PORTB = ucCurrentOutputValue;
		}
		xTaskResumeAll();
     168:	0c 94 1e 06 	jmp	0xc3c	; 0xc3c <xTaskResumeAll>
	}
}
     16c:	df 91       	pop	r29
     16e:	cf 91       	pop	r28
     170:	1f 91       	pop	r17
     172:	08 95       	ret

00000174 <vParTestToggleLED>:
/*-----------------------------------------------------------*/

void vParTestToggleLED( unsigned portBASE_TYPE uxLED )
{
     174:	cf 93       	push	r28
     176:	df 93       	push	r29
unsigned char ucBit;

	if( uxLED <= partstMAX_OUTPUT_LED )
     178:	88 30       	cpi	r24, 0x08	; 8
     17a:	e8 f4       	brcc	.+58     	; 0x1b6 <vParTestToggleLED+0x42>
	{
		ucBit = ( ( unsigned char ) 1 ) << uxLED;
     17c:	c1 e0       	ldi	r28, 0x01	; 1
     17e:	d0 e0       	ldi	r29, 0x00	; 0
     180:	01 c0       	rjmp	.+2      	; 0x184 <vParTestToggleLED+0x10>
     182:	cc 0f       	add	r28, r28
     184:	8a 95       	dec	r24
     186:	ea f7       	brpl	.-6      	; 0x182 <vParTestToggleLED+0xe>

		vTaskSuspendAll();
     188:	0e 94 52 05 	call	0xaa4	; 0xaa4 <vTaskSuspendAll>
		{
			if( ucCurrentOutputValue & ucBit )
     18c:	80 91 04 01 	lds	r24, 0x0104
     190:	8c 23       	and	r24, r28
     192:	29 f0       	breq	.+10     	; 0x19e <vParTestToggleLED+0x2a>
			{
				ucCurrentOutputValue &= ~ucBit;
     194:	80 91 04 01 	lds	r24, 0x0104
     198:	c0 95       	com	r28
     19a:	c8 23       	and	r28, r24
     19c:	03 c0       	rjmp	.+6      	; 0x1a4 <vParTestToggleLED+0x30>
			}
			else
			{
				ucCurrentOutputValue |= ucBit;
     19e:	80 91 04 01 	lds	r24, 0x0104
     1a2:	c8 2b       	or	r28, r24
     1a4:	c0 93 04 01 	sts	0x0104, r28
			}

			PORTB = ucCurrentOutputValue;
     1a8:	80 91 04 01 	lds	r24, 0x0104
     1ac:	85 b9       	out	0x05, r24	; 5
		}
		xTaskResumeAll();			
	}
}
     1ae:	df 91       	pop	r29
     1b0:	cf 91       	pop	r28
				ucCurrentOutputValue |= ucBit;
			}

			PORTB = ucCurrentOutputValue;
		}
		xTaskResumeAll();			
     1b2:	0c 94 1e 06 	jmp	0xc3c	; 0xc3c <xTaskResumeAll>
	}
}
     1b6:	df 91       	pop	r29
     1b8:	cf 91       	pop	r28
     1ba:	08 95       	ret

000001bc <xSerialPortInitMinimal>:
	UCSR0B = ucInByte;										\
}
/*-----------------------------------------------------------*/

xComPortHandle xSerialPortInitMinimal( unsigned long ulWantedBaud, unsigned portBASE_TYPE uxQueueLength )
{
     1bc:	cf 92       	push	r12
     1be:	df 92       	push	r13
     1c0:	ef 92       	push	r14
     1c2:	ff 92       	push	r15
     1c4:	cf 93       	push	r28
     1c6:	6b 01       	movw	r12, r22
     1c8:	7c 01       	movw	r14, r24
     1ca:	c4 2f       	mov	r28, r20
unsigned long ulBaudRateCounter;
unsigned char ucByte;

	portENTER_CRITICAL();
     1cc:	0f b6       	in	r0, 0x3f	; 63
     1ce:	f8 94       	cli
     1d0:	0f 92       	push	r0
	{
		/* Create the queues used by the com test task. */
		xRxedChars = xQueueCreate( uxQueueLength, ( unsigned portBASE_TYPE ) sizeof( signed char ) );
     1d2:	40 e0       	ldi	r20, 0x00	; 0
     1d4:	61 e0       	ldi	r22, 0x01	; 1
     1d6:	8c 2f       	mov	r24, r28
     1d8:	0e 94 35 0b 	call	0x166a	; 0x166a <xQueueGenericCreate>
     1dc:	90 93 54 01 	sts	0x0154, r25
     1e0:	80 93 53 01 	sts	0x0153, r24
		xCharsForTx = xQueueCreate( uxQueueLength, ( unsigned portBASE_TYPE ) sizeof( signed char ) );
     1e4:	40 e0       	ldi	r20, 0x00	; 0
     1e6:	61 e0       	ldi	r22, 0x01	; 1
     1e8:	8c 2f       	mov	r24, r28
     1ea:	0e 94 35 0b 	call	0x166a	; 0x166a <xQueueGenericCreate>
     1ee:	90 93 52 01 	sts	0x0152, r25
     1f2:	80 93 51 01 	sts	0x0151, r24

		/* Calculate the baud rate register value from the equation in the
		data sheet. */
		ulBaudRateCounter = ( configCPU_CLOCK_HZ / ( serBAUD_DIV_CONSTANT * ulWantedBaud ) ) - ( unsigned long ) 1;
     1f6:	a7 01       	movw	r20, r14
     1f8:	96 01       	movw	r18, r12
     1fa:	84 e0       	ldi	r24, 0x04	; 4
     1fc:	22 0f       	add	r18, r18
     1fe:	33 1f       	adc	r19, r19
     200:	44 1f       	adc	r20, r20
     202:	55 1f       	adc	r21, r21
     204:	8a 95       	dec	r24
     206:	d1 f7       	brne	.-12     	; 0x1fc <xSerialPortInitMinimal+0x40>
     208:	60 e0       	ldi	r22, 0x00	; 0
     20a:	72 e1       	ldi	r23, 0x12	; 18
     20c:	8a e7       	ldi	r24, 0x7A	; 122
     20e:	90 e0       	ldi	r25, 0x00	; 0
     210:	0e 94 fc 16 	call	0x2df8	; 0x2df8 <__udivmodsi4>
     214:	da 01       	movw	r26, r20
     216:	c9 01       	movw	r24, r18
     218:	01 97       	sbiw	r24, 0x01	; 1
     21a:	a1 09       	sbc	r26, r1
     21c:	b1 09       	sbc	r27, r1

		/* Set the baud rate. */	
		ucByte = ( unsigned char ) ( ulBaudRateCounter & ( unsigned long ) 0xff );	
		UBRR0L = ucByte;
     21e:	80 93 c4 00 	sts	0x00C4, r24

		ulBaudRateCounter >>= ( unsigned long ) 8;
     222:	89 2f       	mov	r24, r25
     224:	9a 2f       	mov	r25, r26
     226:	ab 2f       	mov	r26, r27
     228:	bb 27       	eor	r27, r27
		ucByte = ( unsigned char ) ( ulBaudRateCounter & ( unsigned long ) 0xff );	
		UBRR0H = ucByte;
     22a:	80 93 c5 00 	sts	0x00C5, r24

		/* Enable the Rx interrupt.  The Tx interrupt will get enabled
		later. Also enable the Rx and Tx. */
		UCSR0B = ( serRX_INT_ENABLE | serRX_ENABLE | serTX_ENABLE );
     22e:	88 e9       	ldi	r24, 0x98	; 152
     230:	80 93 c1 00 	sts	0x00C1, r24

		/* Set the data bits to 8. */
		UCSR0C = ( serUCSR0C_SELECT | serEIGHT_DATA_BITS );
     234:	86 e8       	ldi	r24, 0x86	; 134
     236:	80 93 c2 00 	sts	0x00C2, r24
	}
	portEXIT_CRITICAL();
     23a:	0f 90       	pop	r0
     23c:	0f be       	out	0x3f, r0	; 63
	
	/* Unlike other ports, this serial code does not allow for more than one
	com port.  We therefore don't return a pointer to a port structure and can
	instead just return NULL. */
	return NULL;
}
     23e:	80 e0       	ldi	r24, 0x00	; 0
     240:	90 e0       	ldi	r25, 0x00	; 0
     242:	cf 91       	pop	r28
     244:	ff 90       	pop	r15
     246:	ef 90       	pop	r14
     248:	df 90       	pop	r13
     24a:	cf 90       	pop	r12
     24c:	08 95       	ret

0000024e <xSerialGetChar>:
	/* Only one port is supported. */
	( void ) pxPort;

	/* Get the next character from the buffer.  Return false if no characters
	are available, or arrive before xBlockTime expires. */
	if( xQueueReceive( xRxedChars, pcRxedChar, xBlockTime ) )
     24e:	80 91 53 01 	lds	r24, 0x0153
     252:	90 91 54 01 	lds	r25, 0x0154
     256:	0e 94 4f 0c 	call	0x189e	; 0x189e <xQueueReceive>
     25a:	91 e0       	ldi	r25, 0x01	; 1
     25c:	81 11       	cpse	r24, r1
     25e:	01 c0       	rjmp	.+2      	; 0x262 <xSerialGetChar+0x14>
     260:	90 e0       	ldi	r25, 0x00	; 0
	}
	else
	{
		return pdFALSE;
	}
}
     262:	89 2f       	mov	r24, r25
     264:	08 95       	ret

00000266 <xSerialPutChar>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xSerialPutChar( xComPortHandle pxPort, signed char cOutChar, TickType_t xBlockTime )
{
     266:	cf 93       	push	r28
     268:	df 93       	push	r29
     26a:	1f 92       	push	r1
     26c:	cd b7       	in	r28, 0x3d	; 61
     26e:	de b7       	in	r29, 0x3e	; 62
     270:	69 83       	std	Y+1, r22	; 0x01
	/* Only one port is supported. */
	( void ) pxPort;

	/* Return false if after the block time there is no room on the Tx queue. */
	if( xQueueSend( xCharsForTx, &cOutChar, xBlockTime ) != pdPASS )
     272:	20 e0       	ldi	r18, 0x00	; 0
     274:	be 01       	movw	r22, r28
     276:	6f 5f       	subi	r22, 0xFF	; 255
     278:	7f 4f       	sbci	r23, 0xFF	; 255
     27a:	80 91 51 01 	lds	r24, 0x0151
     27e:	90 91 52 01 	lds	r25, 0x0152
     282:	0e 94 67 0b 	call	0x16ce	; 0x16ce <xQueueGenericSend>
     286:	81 30       	cpi	r24, 0x01	; 1
     288:	31 f4       	brne	.+12     	; 0x296 <xSerialPutChar+0x30>
	{
		return pdFAIL;
	}

	vInterruptOn();
     28a:	90 91 c1 00 	lds	r25, 0x00C1
     28e:	90 62       	ori	r25, 0x20	; 32
     290:	90 93 c1 00 	sts	0x00C1, r25

	return pdPASS;
     294:	01 c0       	rjmp	.+2      	; 0x298 <xSerialPutChar+0x32>
	( void ) pxPort;

	/* Return false if after the block time there is no room on the Tx queue. */
	if( xQueueSend( xCharsForTx, &cOutChar, xBlockTime ) != pdPASS )
	{
		return pdFAIL;
     296:	80 e0       	ldi	r24, 0x00	; 0
	}

	vInterruptOn();

	return pdPASS;
}
     298:	0f 90       	pop	r0
     29a:	df 91       	pop	r29
     29c:	cf 91       	pop	r28
     29e:	08 95       	ret

000002a0 <vSerialClose>:
	( void ) xPort;

	/* Turn off the interrupts.  We may also want to delete the queues and/or
	re-install the original ISR. */

	portENTER_CRITICAL();
     2a0:	0f b6       	in	r0, 0x3f	; 63
     2a2:	f8 94       	cli
     2a4:	0f 92       	push	r0
	{
		vInterruptOff();
     2a6:	e1 ec       	ldi	r30, 0xC1	; 193
     2a8:	f0 e0       	ldi	r31, 0x00	; 0
     2aa:	80 81       	ld	r24, Z
     2ac:	8f 7d       	andi	r24, 0xDF	; 223
     2ae:	80 83       	st	Z, r24
		ucByte = UCSR0B;
     2b0:	80 81       	ld	r24, Z
		ucByte &= ~serRX_INT_ENABLE;
     2b2:	8f 77       	andi	r24, 0x7F	; 127
		UCSR0B = ucByte;
     2b4:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
     2b6:	0f 90       	pop	r0
     2b8:	0f be       	out	0x3f, r0	; 63
     2ba:	08 95       	ret

000002bc <__vector_18>:
}
/*-----------------------------------------------------------*/

//SIGNAL( SIG_UART_RECV )
SIGNAL( USART_RX_vect )
{
     2bc:	1f 92       	push	r1
     2be:	0f 92       	push	r0
     2c0:	0f b6       	in	r0, 0x3f	; 63
     2c2:	0f 92       	push	r0
     2c4:	11 24       	eor	r1, r1
     2c6:	2f 93       	push	r18
     2c8:	3f 93       	push	r19
     2ca:	4f 93       	push	r20
     2cc:	5f 93       	push	r21
     2ce:	6f 93       	push	r22
     2d0:	7f 93       	push	r23
     2d2:	8f 93       	push	r24
     2d4:	9f 93       	push	r25
     2d6:	af 93       	push	r26
     2d8:	bf 93       	push	r27
     2da:	ef 93       	push	r30
     2dc:	ff 93       	push	r31
     2de:	cf 93       	push	r28
     2e0:	df 93       	push	r29
     2e2:	00 d0       	rcall	.+0      	; 0x2e4 <__vector_18+0x28>
     2e4:	cd b7       	in	r28, 0x3d	; 61
     2e6:	de b7       	in	r29, 0x3e	; 62
signed char cChar;
signed portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
     2e8:	19 82       	std	Y+1, r1	; 0x01

	/* Get the character and post it on the queue of Rxed characters.
	If the post causes a task to wake force a context switch as the woken task
	may have a higher priority than the task we have interrupted. */
	cChar = UDR0;
     2ea:	80 91 c6 00 	lds	r24, 0x00C6
     2ee:	8a 83       	std	Y+2, r24	; 0x02

	xQueueSendFromISR( xRxedChars, &cChar, &xHigherPriorityTaskWoken );
     2f0:	20 e0       	ldi	r18, 0x00	; 0
     2f2:	ae 01       	movw	r20, r28
     2f4:	4f 5f       	subi	r20, 0xFF	; 255
     2f6:	5f 4f       	sbci	r21, 0xFF	; 255
     2f8:	be 01       	movw	r22, r28
     2fa:	6e 5f       	subi	r22, 0xFE	; 254
     2fc:	7f 4f       	sbci	r23, 0xFF	; 255
     2fe:	80 91 53 01 	lds	r24, 0x0153
     302:	90 91 54 01 	lds	r25, 0x0154
     306:	0e 94 fd 0b 	call	0x17fa	; 0x17fa <xQueueGenericSendFromISR>

	if( xHigherPriorityTaskWoken != pdFALSE )
     30a:	89 81       	ldd	r24, Y+1	; 0x01
     30c:	81 11       	cpse	r24, r1
	{
		taskYIELD();
     30e:	0e 94 74 13 	call	0x26e8	; 0x26e8 <vPortYield>
	}
}
     312:	0f 90       	pop	r0
     314:	0f 90       	pop	r0
     316:	df 91       	pop	r29
     318:	cf 91       	pop	r28
     31a:	ff 91       	pop	r31
     31c:	ef 91       	pop	r30
     31e:	bf 91       	pop	r27
     320:	af 91       	pop	r26
     322:	9f 91       	pop	r25
     324:	8f 91       	pop	r24
     326:	7f 91       	pop	r23
     328:	6f 91       	pop	r22
     32a:	5f 91       	pop	r21
     32c:	4f 91       	pop	r20
     32e:	3f 91       	pop	r19
     330:	2f 91       	pop	r18
     332:	0f 90       	pop	r0
     334:	0f be       	out	0x3f, r0	; 63
     336:	0f 90       	pop	r0
     338:	1f 90       	pop	r1
     33a:	18 95       	reti

0000033c <__vector_19>:
/*-----------------------------------------------------------*/

//SIGNAL( SIG_UART_DATA )
SIGNAL( USART_UDRE_vect )
{
     33c:	1f 92       	push	r1
     33e:	0f 92       	push	r0
     340:	0f b6       	in	r0, 0x3f	; 63
     342:	0f 92       	push	r0
     344:	11 24       	eor	r1, r1
     346:	2f 93       	push	r18
     348:	3f 93       	push	r19
     34a:	4f 93       	push	r20
     34c:	5f 93       	push	r21
     34e:	6f 93       	push	r22
     350:	7f 93       	push	r23
     352:	8f 93       	push	r24
     354:	9f 93       	push	r25
     356:	af 93       	push	r26
     358:	bf 93       	push	r27
     35a:	ef 93       	push	r30
     35c:	ff 93       	push	r31
     35e:	cf 93       	push	r28
     360:	df 93       	push	r29
     362:	00 d0       	rcall	.+0      	; 0x364 <__vector_19+0x28>
     364:	cd b7       	in	r28, 0x3d	; 61
     366:	de b7       	in	r29, 0x3e	; 62
signed char cChar, cTaskWoken;

	if( xQueueReceiveFromISR( xCharsForTx, &cChar, &cTaskWoken ) == pdTRUE )
     368:	ae 01       	movw	r20, r28
     36a:	4f 5f       	subi	r20, 0xFF	; 255
     36c:	5f 4f       	sbci	r21, 0xFF	; 255
     36e:	be 01       	movw	r22, r28
     370:	6e 5f       	subi	r22, 0xFE	; 254
     372:	7f 4f       	sbci	r23, 0xFF	; 255
     374:	80 91 51 01 	lds	r24, 0x0151
     378:	90 91 52 01 	lds	r25, 0x0152
     37c:	0e 94 f9 0d 	call	0x1bf2	; 0x1bf2 <xQueueReceiveFromISR>
     380:	81 30       	cpi	r24, 0x01	; 1
     382:	21 f4       	brne	.+8      	; 0x38c <__vector_19+0x50>
	{
		/* Send the next character queued for Tx. */
		UDR0 = cChar;
     384:	8a 81       	ldd	r24, Y+2	; 0x02
     386:	80 93 c6 00 	sts	0x00C6, r24
     38a:	05 c0       	rjmp	.+10     	; 0x396 <__vector_19+0x5a>
	}
	else
	{
		/* Queue empty, nothing to send. */
		vInterruptOff();
     38c:	80 91 c1 00 	lds	r24, 0x00C1
     390:	8f 7d       	andi	r24, 0xDF	; 223
     392:	80 93 c1 00 	sts	0x00C1, r24
	}
}
     396:	0f 90       	pop	r0
     398:	0f 90       	pop	r0
     39a:	df 91       	pop	r29
     39c:	cf 91       	pop	r28
     39e:	ff 91       	pop	r31
     3a0:	ef 91       	pop	r30
     3a2:	bf 91       	pop	r27
     3a4:	af 91       	pop	r26
     3a6:	9f 91       	pop	r25
     3a8:	8f 91       	pop	r24
     3aa:	7f 91       	pop	r23
     3ac:	6f 91       	pop	r22
     3ae:	5f 91       	pop	r21
     3b0:	4f 91       	pop	r20
     3b2:	3f 91       	pop	r19
     3b4:	2f 91       	pop	r18
     3b6:	0f 90       	pop	r0
     3b8:	0f be       	out	0x3f, r0	; 63
     3ba:	0f 90       	pop	r0
     3bc:	1f 90       	pop	r1
     3be:	18 95       	reti

000003c0 <prvRegisterCheck1>:
{
	( void ) pvParameters;

	for( ;; )
	{
		asm(	"LDI	r31,	5"		);
     3c0:	f5 e0       	ldi	r31, 0x05	; 5
		asm( 	"MOV	r0,		r31"	);
     3c2:	0f 2e       	mov	r0, r31
		asm(	"LDI	r31,	6"		);
     3c4:	f6 e0       	ldi	r31, 0x06	; 6
		asm( 	"MOV	r1,		r31"	);
     3c6:	1f 2e       	mov	r1, r31
		asm(	"LDI	r31,	7"		);
     3c8:	f7 e0       	ldi	r31, 0x07	; 7
		asm( 	"MOV	r2,		r31"	);
     3ca:	2f 2e       	mov	r2, r31
		asm(	"LDI	r31,	8"		);
     3cc:	f8 e0       	ldi	r31, 0x08	; 8
		asm( 	"MOV	r3,		r31"	);
     3ce:	3f 2e       	mov	r3, r31
		asm(	"LDI	r31,	9"		);
     3d0:	f9 e0       	ldi	r31, 0x09	; 9
		asm( 	"MOV	r4,		r31"	);
     3d2:	4f 2e       	mov	r4, r31
		asm(	"LDI	r31,	10"		);
     3d4:	fa e0       	ldi	r31, 0x0A	; 10
		asm( 	"MOV	r5,		r31"	);
     3d6:	5f 2e       	mov	r5, r31
		asm(	"LDI	r31,	11"		);
     3d8:	fb e0       	ldi	r31, 0x0B	; 11
		asm( 	"MOV	r6,		r31"	);
     3da:	6f 2e       	mov	r6, r31
		asm(	"LDI	r31,	12"		);
     3dc:	fc e0       	ldi	r31, 0x0C	; 12
		asm( 	"MOV	r7,		r31"	);
     3de:	7f 2e       	mov	r7, r31
		asm(	"LDI	r31,	13"		);
     3e0:	fd e0       	ldi	r31, 0x0D	; 13
		asm( 	"MOV	r8,		r31"	);
     3e2:	8f 2e       	mov	r8, r31
		asm(	"LDI	r31,	14"		);
     3e4:	fe e0       	ldi	r31, 0x0E	; 14
		asm( 	"MOV	r9,		r31"	);
     3e6:	9f 2e       	mov	r9, r31
		asm(	"LDI	r31,	15"		);
     3e8:	ff e0       	ldi	r31, 0x0F	; 15
		asm( 	"MOV	r10,	r31"	);
     3ea:	af 2e       	mov	r10, r31
		asm(	"LDI	r31,	16"		);
     3ec:	f0 e1       	ldi	r31, 0x10	; 16
		asm( 	"MOV	r11,	r31"	);
     3ee:	bf 2e       	mov	r11, r31
		asm(	"LDI	r31,	17"		);
     3f0:	f1 e1       	ldi	r31, 0x11	; 17
		asm( 	"MOV	r12,	r31"	);
     3f2:	cf 2e       	mov	r12, r31
		asm(	"LDI	r31,	18"		);
     3f4:	f2 e1       	ldi	r31, 0x12	; 18
		asm( 	"MOV	r13,	r31"	);
     3f6:	df 2e       	mov	r13, r31
		asm(	"LDI	r31,	19"		);
     3f8:	f3 e1       	ldi	r31, 0x13	; 19
		asm( 	"MOV	r14,	r31"	);
     3fa:	ef 2e       	mov	r14, r31
		asm(	"LDI	r31,	20"		);
     3fc:	f4 e1       	ldi	r31, 0x14	; 20
		asm( 	"MOV	r15,	r31"	);
     3fe:	ff 2e       	mov	r15, r31
		asm(	"LDI	r16,	21"		);
     400:	05 e1       	ldi	r16, 0x15	; 21
		asm(	"LDI	r17,	22"		);
     402:	16 e1       	ldi	r17, 0x16	; 22
		asm(	"LDI	r18,	23"		);
     404:	27 e1       	ldi	r18, 0x17	; 23
		asm(	"LDI	r19,	24"		);
     406:	38 e1       	ldi	r19, 0x18	; 24
		asm(	"LDI	r20,	25"		);
     408:	49 e1       	ldi	r20, 0x19	; 25
		asm(	"LDI	r21,	26"		);
     40a:	5a e1       	ldi	r21, 0x1A	; 26
		asm(	"LDI	r22,	27"		);
     40c:	6b e1       	ldi	r22, 0x1B	; 27
		asm(	"LDI	r23,	28"		);
     40e:	7c e1       	ldi	r23, 0x1C	; 28
		asm(	"LDI	r24,	29"		);
     410:	8d e1       	ldi	r24, 0x1D	; 29
		asm(	"LDI	r25,	30"		);
     412:	9e e1       	ldi	r25, 0x1E	; 30
		asm(	"LDI	r26,	31"		);
     414:	af e1       	ldi	r26, 0x1F	; 31
		asm(	"LDI	r27,	32"		);
     416:	b0 e2       	ldi	r27, 0x20	; 32
		asm(	"LDI	r30,	33"		);
     418:	e1 e2       	ldi	r30, 0x21	; 33

		asm(	"LDI	r31,	5"			);
     41a:	f5 e0       	ldi	r31, 0x05	; 5
		asm(	"CPSE	r31,	r0"			);
     41c:	f0 11       	cpse	r31, r0
		asm(	"STS	xRegTestError, r0"	);
     41e:	00 92 55 01 	sts	0x0155, r0
		asm(	"LDI	r31,	6"			);
     422:	f6 e0       	ldi	r31, 0x06	; 6
		asm(	"CPSE	r31,	r1"			);
     424:	f1 11       	cpse	r31, r1
		asm(	"STS	xRegTestError, r0"	);
     426:	00 92 55 01 	sts	0x0155, r0
		asm(	"LDI	r31,	7"			);
     42a:	f7 e0       	ldi	r31, 0x07	; 7
		asm(	"CPSE	r31,	r2"			);
     42c:	f2 11       	cpse	r31, r2
		asm(	"STS	xRegTestError, r0"	);
     42e:	00 92 55 01 	sts	0x0155, r0
		asm(	"LDI	r31,	8"			);
     432:	f8 e0       	ldi	r31, 0x08	; 8
		asm(	"CPSE	r31,	r3"			);
     434:	f3 11       	cpse	r31, r3
		asm(	"STS	xRegTestError, r0"	);
     436:	00 92 55 01 	sts	0x0155, r0
		asm(	"LDI	r31,	9"			);
     43a:	f9 e0       	ldi	r31, 0x09	; 9
		asm(	"CPSE	r31,	r4"			);
     43c:	f4 11       	cpse	r31, r4
		asm(	"STS	xRegTestError, r0"	);
     43e:	00 92 55 01 	sts	0x0155, r0
		asm(	"LDI	r31,	10"			);
     442:	fa e0       	ldi	r31, 0x0A	; 10
		asm(	"CPSE	r31,	r5"			);
     444:	f5 11       	cpse	r31, r5
		asm(	"STS	xRegTestError, r0"	);
     446:	00 92 55 01 	sts	0x0155, r0
		asm(	"LDI	r31,	11"			);
     44a:	fb e0       	ldi	r31, 0x0B	; 11
		asm(	"CPSE	r31,	r6"			);
     44c:	f6 11       	cpse	r31, r6
		asm(	"STS	xRegTestError, r0"	);
     44e:	00 92 55 01 	sts	0x0155, r0
		asm(	"LDI	r31,	12"			);
     452:	fc e0       	ldi	r31, 0x0C	; 12
		asm(	"CPSE	r31,	r7"			);
     454:	f7 11       	cpse	r31, r7
		asm(	"STS	xRegTestError, r0"	);
     456:	00 92 55 01 	sts	0x0155, r0
		asm(	"LDI	r31,	13"			);
     45a:	fd e0       	ldi	r31, 0x0D	; 13
		asm(	"CPSE	r31,	r8"			);
     45c:	f8 11       	cpse	r31, r8
		asm(	"STS	xRegTestError, r0"	);
     45e:	00 92 55 01 	sts	0x0155, r0
		asm(	"LDI	r31,	14"			);
     462:	fe e0       	ldi	r31, 0x0E	; 14
		asm(	"CPSE	r31,	r9"			);
     464:	f9 11       	cpse	r31, r9
		asm(	"STS	xRegTestError, r0"	);
     466:	00 92 55 01 	sts	0x0155, r0
		asm(	"LDI	r31,	15"			);
     46a:	ff e0       	ldi	r31, 0x0F	; 15
		asm(	"CPSE	r31,	r10"		);
     46c:	fa 11       	cpse	r31, r10
		asm(	"STS	xRegTestError, r0"	);
     46e:	00 92 55 01 	sts	0x0155, r0
		asm(	"LDI	r31,	16"			);
     472:	f0 e1       	ldi	r31, 0x10	; 16
		asm(	"CPSE	r31,	r11"		);
     474:	fb 11       	cpse	r31, r11
		asm(	"STS	xRegTestError, r0"	);
     476:	00 92 55 01 	sts	0x0155, r0
		asm(	"LDI	r31,	17"			);
     47a:	f1 e1       	ldi	r31, 0x11	; 17
		asm(	"CPSE	r31,	r12"		);
     47c:	fc 11       	cpse	r31, r12
		asm(	"STS	xRegTestError, r0"	);
     47e:	00 92 55 01 	sts	0x0155, r0
		asm(	"LDI	r31,	18"			);
     482:	f2 e1       	ldi	r31, 0x12	; 18
		asm(	"CPSE	r31,	r13"		);
     484:	fd 11       	cpse	r31, r13
		asm(	"STS	xRegTestError, r0"	);
     486:	00 92 55 01 	sts	0x0155, r0
		asm(	"LDI	r31,	19"			);
     48a:	f3 e1       	ldi	r31, 0x13	; 19
		asm(	"CPSE	r31,	r14"		);
     48c:	fe 11       	cpse	r31, r14
		asm(	"STS	xRegTestError, r0"	);
     48e:	00 92 55 01 	sts	0x0155, r0
		asm(	"LDI	r31,	20"			);
     492:	f4 e1       	ldi	r31, 0x14	; 20
		asm(	"CPSE	r31,	r15"		);
     494:	ff 11       	cpse	r31, r15
		asm(	"STS	xRegTestError, r0"	);
     496:	00 92 55 01 	sts	0x0155, r0
		asm(	"LDI	r31,	21"			);
     49a:	f5 e1       	ldi	r31, 0x15	; 21
		asm(	"CPSE	r31,	r16"		);
     49c:	f0 13       	cpse	r31, r16
		asm(	"STS	xRegTestError, r0"	);
     49e:	00 92 55 01 	sts	0x0155, r0
		asm(	"LDI	r31,	22"			);
     4a2:	f6 e1       	ldi	r31, 0x16	; 22
		asm(	"CPSE	r31,	r17"		);
     4a4:	f1 13       	cpse	r31, r17
		asm(	"STS	xRegTestError, r0"	);
     4a6:	00 92 55 01 	sts	0x0155, r0
		asm(	"LDI	r31,	23"			);
     4aa:	f7 e1       	ldi	r31, 0x17	; 23
		asm(	"CPSE	r31,	r18"		);
     4ac:	f2 13       	cpse	r31, r18
		asm(	"STS	xRegTestError, r0"	);
     4ae:	00 92 55 01 	sts	0x0155, r0
		asm(	"LDI	r31,	24"			);
     4b2:	f8 e1       	ldi	r31, 0x18	; 24
		asm(	"CPSE	r31,	r19"		);
     4b4:	f3 13       	cpse	r31, r19
		asm(	"STS	xRegTestError, r0"	);
     4b6:	00 92 55 01 	sts	0x0155, r0
		asm(	"LDI	r31,	25"			);
     4ba:	f9 e1       	ldi	r31, 0x19	; 25
		asm(	"CPSE	r31,	r20"		);
     4bc:	f4 13       	cpse	r31, r20
		asm(	"STS	xRegTestError, r0"	);
     4be:	00 92 55 01 	sts	0x0155, r0
		asm(	"LDI	r31,	26"			);
     4c2:	fa e1       	ldi	r31, 0x1A	; 26
		asm(	"CPSE	r31,	r21"		);
     4c4:	f5 13       	cpse	r31, r21
		asm(	"STS	xRegTestError, r0"	);
     4c6:	00 92 55 01 	sts	0x0155, r0
		asm(	"LDI	r31,	27"			);
     4ca:	fb e1       	ldi	r31, 0x1B	; 27
		asm(	"CPSE	r31,	r22"		);
     4cc:	f6 13       	cpse	r31, r22
		asm(	"STS	xRegTestError, r0"	);
     4ce:	00 92 55 01 	sts	0x0155, r0
		asm(	"LDI	r31,	28"			);
     4d2:	fc e1       	ldi	r31, 0x1C	; 28
		asm(	"CPSE	r31,	r23"		);
     4d4:	f7 13       	cpse	r31, r23
		asm(	"STS	xRegTestError, r0"	);
     4d6:	00 92 55 01 	sts	0x0155, r0
		asm(	"LDI	r31,	29"			);
     4da:	fd e1       	ldi	r31, 0x1D	; 29
		asm(	"CPSE	r31,	r24"		);
     4dc:	f8 13       	cpse	r31, r24
		asm(	"STS	xRegTestError, r0"	);
     4de:	00 92 55 01 	sts	0x0155, r0
		asm(	"LDI	r31,	30"			);
     4e2:	fe e1       	ldi	r31, 0x1E	; 30
		asm(	"CPSE	r31,	r25"		);
     4e4:	f9 13       	cpse	r31, r25
		asm(	"STS	xRegTestError, r0"	);
     4e6:	00 92 55 01 	sts	0x0155, r0
		asm(	"LDI	r31,	31"			);
     4ea:	ff e1       	ldi	r31, 0x1F	; 31
		asm(	"CPSE	r31,	r26"		);
     4ec:	fa 13       	cpse	r31, r26
		asm(	"STS	xRegTestError, r0"	);
     4ee:	00 92 55 01 	sts	0x0155, r0
		asm(	"LDI	r31,	32"			);
     4f2:	f0 e2       	ldi	r31, 0x20	; 32
		asm(	"CPSE	r31,	r27"		);
     4f4:	fb 13       	cpse	r31, r27
		asm(	"STS	xRegTestError, r0"	);
     4f6:	00 92 55 01 	sts	0x0155, r0
		asm(	"LDI	r31,	33"			);
     4fa:	f1 e2       	ldi	r31, 0x21	; 33
		asm(	"CPSE	r31,	r30"		);
     4fc:	fe 13       	cpse	r31, r30
		asm(	"STS	xRegTestError, r0"	);
     4fe:	00 92 55 01 	sts	0x0155, r0
	}
     502:	5e cf       	rjmp	.-324    	; 0x3c0 <prvRegisterCheck1>

00000504 <prvRegisterCheck2>:
{
	( void ) pvParameters;

	for( ;; )
	{
		asm(	"LDI	r31,	1"		);
     504:	f1 e0       	ldi	r31, 0x01	; 1
		asm( 	"MOV	r0,		r31"	);
     506:	0f 2e       	mov	r0, r31
		asm(	"LDI	r31,	2"		);
     508:	f2 e0       	ldi	r31, 0x02	; 2
		asm( 	"MOV	r1,		r31"	);
     50a:	1f 2e       	mov	r1, r31
		asm(	"LDI	r31,	3"		);
     50c:	f3 e0       	ldi	r31, 0x03	; 3
		asm( 	"MOV	r2,		r31"	);
     50e:	2f 2e       	mov	r2, r31
		asm(	"LDI	r31,	4"		);
     510:	f4 e0       	ldi	r31, 0x04	; 4
		asm( 	"MOV	r3,		r31"	);
     512:	3f 2e       	mov	r3, r31
		asm(	"LDI	r31,	5"		);
     514:	f5 e0       	ldi	r31, 0x05	; 5
		asm( 	"MOV	r4,		r31"	);
     516:	4f 2e       	mov	r4, r31
		asm(	"LDI	r31,	6"		);
     518:	f6 e0       	ldi	r31, 0x06	; 6
		asm( 	"MOV	r5,		r31"	);
     51a:	5f 2e       	mov	r5, r31
		asm(	"LDI	r31,	7"		);
     51c:	f7 e0       	ldi	r31, 0x07	; 7
		asm( 	"MOV	r6,		r31"	);
     51e:	6f 2e       	mov	r6, r31
		asm(	"LDI	r31,	8"		);
     520:	f8 e0       	ldi	r31, 0x08	; 8
		asm( 	"MOV	r7,		r31"	);
     522:	7f 2e       	mov	r7, r31
		asm(	"LDI	r31,	9"		);
     524:	f9 e0       	ldi	r31, 0x09	; 9
		asm( 	"MOV	r8,		r31"	);
     526:	8f 2e       	mov	r8, r31
		asm(	"LDI	r31,	10"		);
     528:	fa e0       	ldi	r31, 0x0A	; 10
		asm( 	"MOV	r9,		r31"	);
     52a:	9f 2e       	mov	r9, r31
		asm(	"LDI	r31,	11"		);
     52c:	fb e0       	ldi	r31, 0x0B	; 11
		asm( 	"MOV	r10,	r31"	);
     52e:	af 2e       	mov	r10, r31
		asm(	"LDI	r31,	12"		);
     530:	fc e0       	ldi	r31, 0x0C	; 12
		asm( 	"MOV	r11,	r31"	);
     532:	bf 2e       	mov	r11, r31
		asm(	"LDI	r31,	13"		);
     534:	fd e0       	ldi	r31, 0x0D	; 13
		asm( 	"MOV	r12,	r31"	);
     536:	cf 2e       	mov	r12, r31
		asm(	"LDI	r31,	14"		);
     538:	fe e0       	ldi	r31, 0x0E	; 14
		asm( 	"MOV	r13,	r31"	);
     53a:	df 2e       	mov	r13, r31
		asm(	"LDI	r31,	15"		);
     53c:	ff e0       	ldi	r31, 0x0F	; 15
		asm( 	"MOV	r14,	r31"	);
     53e:	ef 2e       	mov	r14, r31
		asm(	"LDI	r31,	16"		);
     540:	f0 e1       	ldi	r31, 0x10	; 16
		asm( 	"MOV	r15,	r31"	);
     542:	ff 2e       	mov	r15, r31
		asm(	"LDI	r16,	17"		);
     544:	01 e1       	ldi	r16, 0x11	; 17
		asm(	"LDI	r17,	18"		);
     546:	12 e1       	ldi	r17, 0x12	; 18
		asm(	"LDI	r18,	19"		);
     548:	23 e1       	ldi	r18, 0x13	; 19
		asm(	"LDI	r19,	20"		);
     54a:	34 e1       	ldi	r19, 0x14	; 20
		asm(	"LDI	r20,	21"		);
     54c:	45 e1       	ldi	r20, 0x15	; 21
		asm(	"LDI	r21,	22"		);
     54e:	56 e1       	ldi	r21, 0x16	; 22
		asm(	"LDI	r22,	23"		);
     550:	67 e1       	ldi	r22, 0x17	; 23
		asm(	"LDI	r23,	24"		);
     552:	78 e1       	ldi	r23, 0x18	; 24
		asm(	"LDI	r24,	25"		);
     554:	89 e1       	ldi	r24, 0x19	; 25
		asm(	"LDI	r25,	26"		);
     556:	9a e1       	ldi	r25, 0x1A	; 26
		asm(	"LDI	r26,	27"		);
     558:	ab e1       	ldi	r26, 0x1B	; 27
		asm(	"LDI	r27,	28"		);
     55a:	bc e1       	ldi	r27, 0x1C	; 28
		asm(	"LDI	r30,	29"		);
     55c:	ed e1       	ldi	r30, 0x1D	; 29

		asm(	"LDI	r31,	1"			);
     55e:	f1 e0       	ldi	r31, 0x01	; 1
		asm(	"CPSE	r31,	r0"			);
     560:	f0 11       	cpse	r31, r0
		asm(	"STS	xRegTestError, r0"	);
     562:	00 92 55 01 	sts	0x0155, r0
		asm(	"LDI	r31,	2"			);
     566:	f2 e0       	ldi	r31, 0x02	; 2
		asm(	"CPSE	r31,	r1"			);
     568:	f1 11       	cpse	r31, r1
		asm(	"STS	xRegTestError, r0"	);
     56a:	00 92 55 01 	sts	0x0155, r0
		asm(	"LDI	r31,	3"			);
     56e:	f3 e0       	ldi	r31, 0x03	; 3
		asm(	"CPSE	r31,	r2"			);
     570:	f2 11       	cpse	r31, r2
		asm(	"STS	xRegTestError, r0"	);
     572:	00 92 55 01 	sts	0x0155, r0
		asm(	"LDI	r31,	4"			);
     576:	f4 e0       	ldi	r31, 0x04	; 4
		asm(	"CPSE	r31,	r3"			);
     578:	f3 11       	cpse	r31, r3
		asm(	"STS	xRegTestError, r0"	);
     57a:	00 92 55 01 	sts	0x0155, r0
		asm(	"LDI	r31,	5"			);
     57e:	f5 e0       	ldi	r31, 0x05	; 5
		asm(	"CPSE	r31,	r4"			);
     580:	f4 11       	cpse	r31, r4
		asm(	"STS	xRegTestError, r0"	);
     582:	00 92 55 01 	sts	0x0155, r0
		asm(	"LDI	r31,	6"			);
     586:	f6 e0       	ldi	r31, 0x06	; 6
		asm(	"CPSE	r31,	r5"			);
     588:	f5 11       	cpse	r31, r5
		asm(	"STS	xRegTestError, r0"	);
     58a:	00 92 55 01 	sts	0x0155, r0
		asm(	"LDI	r31,	7"			);
     58e:	f7 e0       	ldi	r31, 0x07	; 7
		asm(	"CPSE	r31,	r6"			);
     590:	f6 11       	cpse	r31, r6
		asm(	"STS	xRegTestError, r0"	);
     592:	00 92 55 01 	sts	0x0155, r0
		asm(	"LDI	r31,	8"			);
     596:	f8 e0       	ldi	r31, 0x08	; 8
		asm(	"CPSE	r31,	r7"			);
     598:	f7 11       	cpse	r31, r7
		asm(	"STS	xRegTestError, r0"	);
     59a:	00 92 55 01 	sts	0x0155, r0
		asm(	"LDI	r31,	9"			);
     59e:	f9 e0       	ldi	r31, 0x09	; 9
		asm(	"CPSE	r31,	r8"			);
     5a0:	f8 11       	cpse	r31, r8
		asm(	"STS	xRegTestError, r0"	);
     5a2:	00 92 55 01 	sts	0x0155, r0
		asm(	"LDI	r31,	10"			);
     5a6:	fa e0       	ldi	r31, 0x0A	; 10
		asm(	"CPSE	r31,	r9"			);
     5a8:	f9 11       	cpse	r31, r9
		asm(	"STS	xRegTestError, r0"	);
     5aa:	00 92 55 01 	sts	0x0155, r0
		asm(	"LDI	r31,	11"			);
     5ae:	fb e0       	ldi	r31, 0x0B	; 11
		asm(	"CPSE	r31,	r10"		);
     5b0:	fa 11       	cpse	r31, r10
		asm(	"STS	xRegTestError, r0"	);
     5b2:	00 92 55 01 	sts	0x0155, r0
		asm(	"LDI	r31,	12"			);
     5b6:	fc e0       	ldi	r31, 0x0C	; 12
		asm(	"CPSE	r31,	r11"		);
     5b8:	fb 11       	cpse	r31, r11
		asm(	"STS	xRegTestError, r0"	);
     5ba:	00 92 55 01 	sts	0x0155, r0
		asm(	"LDI	r31,	13"			);
     5be:	fd e0       	ldi	r31, 0x0D	; 13
		asm(	"CPSE	r31,	r12"		);
     5c0:	fc 11       	cpse	r31, r12
		asm(	"STS	xRegTestError, r0"	);
     5c2:	00 92 55 01 	sts	0x0155, r0
		asm(	"LDI	r31,	14"			);
     5c6:	fe e0       	ldi	r31, 0x0E	; 14
		asm(	"CPSE	r31,	r13"		);
     5c8:	fd 11       	cpse	r31, r13
		asm(	"STS	xRegTestError, r0"	);
     5ca:	00 92 55 01 	sts	0x0155, r0
		asm(	"LDI	r31,	15"			);
     5ce:	ff e0       	ldi	r31, 0x0F	; 15
		asm(	"CPSE	r31,	r14"		);
     5d0:	fe 11       	cpse	r31, r14
		asm(	"STS	xRegTestError, r0"	);
     5d2:	00 92 55 01 	sts	0x0155, r0
		asm(	"LDI	r31,	16"			);
     5d6:	f0 e1       	ldi	r31, 0x10	; 16
		asm(	"CPSE	r31,	r15"		);
     5d8:	ff 11       	cpse	r31, r15
		asm(	"STS	xRegTestError, r0"	);
     5da:	00 92 55 01 	sts	0x0155, r0
		asm(	"LDI	r31,	17"			);
     5de:	f1 e1       	ldi	r31, 0x11	; 17
		asm(	"CPSE	r31,	r16"		);
     5e0:	f0 13       	cpse	r31, r16
		asm(	"STS	xRegTestError, r0"	);
     5e2:	00 92 55 01 	sts	0x0155, r0
		asm(	"LDI	r31,	18"			);
     5e6:	f2 e1       	ldi	r31, 0x12	; 18
		asm(	"CPSE	r31,	r17"		);
     5e8:	f1 13       	cpse	r31, r17
		asm(	"STS	xRegTestError, r0"	);
     5ea:	00 92 55 01 	sts	0x0155, r0
		asm(	"LDI	r31,	19"			);
     5ee:	f3 e1       	ldi	r31, 0x13	; 19
		asm(	"CPSE	r31,	r18"		);
     5f0:	f2 13       	cpse	r31, r18
		asm(	"STS	xRegTestError, r0"	);
     5f2:	00 92 55 01 	sts	0x0155, r0
		asm(	"LDI	r31,	20"			);
     5f6:	f4 e1       	ldi	r31, 0x14	; 20
		asm(	"CPSE	r31,	r19"		);
     5f8:	f3 13       	cpse	r31, r19
		asm(	"STS	xRegTestError, r0"	);
     5fa:	00 92 55 01 	sts	0x0155, r0
		asm(	"LDI	r31,	21"			);
     5fe:	f5 e1       	ldi	r31, 0x15	; 21
		asm(	"CPSE	r31,	r20"		);
     600:	f4 13       	cpse	r31, r20
		asm(	"STS	xRegTestError, r0"	);
     602:	00 92 55 01 	sts	0x0155, r0
		asm(	"LDI	r31,	22"			);
     606:	f6 e1       	ldi	r31, 0x16	; 22
		asm(	"CPSE	r31,	r21"		);
     608:	f5 13       	cpse	r31, r21
		asm(	"STS	xRegTestError, r0"	);
     60a:	00 92 55 01 	sts	0x0155, r0
		asm(	"LDI	r31,	23"			);
     60e:	f7 e1       	ldi	r31, 0x17	; 23
		asm(	"CPSE	r31,	r22"		);
     610:	f6 13       	cpse	r31, r22
		asm(	"STS	xRegTestError, r0"	);
     612:	00 92 55 01 	sts	0x0155, r0
		asm(	"LDI	r31,	24"			);
     616:	f8 e1       	ldi	r31, 0x18	; 24
		asm(	"CPSE	r31,	r23"		);
     618:	f7 13       	cpse	r31, r23
		asm(	"STS	xRegTestError, r0"	);
     61a:	00 92 55 01 	sts	0x0155, r0
		asm(	"LDI	r31,	25"			);
     61e:	f9 e1       	ldi	r31, 0x19	; 25
		asm(	"CPSE	r31,	r24"		);
     620:	f8 13       	cpse	r31, r24
		asm(	"STS	xRegTestError, r0"	);
     622:	00 92 55 01 	sts	0x0155, r0
		asm(	"LDI	r31,	26"			);
     626:	fa e1       	ldi	r31, 0x1A	; 26
		asm(	"CPSE	r31,	r25"		);
     628:	f9 13       	cpse	r31, r25
		asm(	"STS	xRegTestError, r0"	);
     62a:	00 92 55 01 	sts	0x0155, r0
		asm(	"LDI	r31,	27"			);
     62e:	fb e1       	ldi	r31, 0x1B	; 27
		asm(	"CPSE	r31,	r26"		);
     630:	fa 13       	cpse	r31, r26
		asm(	"STS	xRegTestError, r0"	);
     632:	00 92 55 01 	sts	0x0155, r0
		asm(	"LDI	r31,	28"			);
     636:	fc e1       	ldi	r31, 0x1C	; 28
		asm(	"CPSE	r31,	r27"		);
     638:	fb 13       	cpse	r31, r27
		asm(	"STS	xRegTestError, r0"	);
     63a:	00 92 55 01 	sts	0x0155, r0
		asm(	"LDI	r31,	29"			);
     63e:	fd e1       	ldi	r31, 0x1D	; 29
		asm(	"CPSE	r31,	r30"		);
     640:	fe 13       	cpse	r31, r30
		asm(	"STS	xRegTestError, r0"	);
     642:	00 92 55 01 	sts	0x0155, r0
	}
     646:	5e cf       	rjmp	.-324    	; 0x504 <prvRegisterCheck2>

00000648 <vStartRegTestTasks>:
portBASE_TYPE xRegTestError = pdFALSE;

/*-----------------------------------------------------------*/

void vStartRegTestTasks( void )
{
     648:	ef 92       	push	r14
     64a:	ff 92       	push	r15
     64c:	0f 93       	push	r16
	xTaskCreate( prvRegisterCheck1, "Reg1", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );
     64e:	e1 2c       	mov	r14, r1
     650:	f1 2c       	mov	r15, r1
     652:	00 e0       	ldi	r16, 0x00	; 0
     654:	20 e0       	ldi	r18, 0x00	; 0
     656:	30 e0       	ldi	r19, 0x00	; 0
     658:	45 e5       	ldi	r20, 0x55	; 85
     65a:	50 e0       	ldi	r21, 0x00	; 0
     65c:	6c e1       	ldi	r22, 0x1C	; 28
     65e:	71 e0       	ldi	r23, 0x01	; 1
     660:	80 ee       	ldi	r24, 0xE0	; 224
     662:	91 e0       	ldi	r25, 0x01	; 1
     664:	0e 94 d4 03 	call	0x7a8	; 0x7a8 <xTaskCreate>
	xTaskCreate( prvRegisterCheck2, "Reg2", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );
     668:	20 e0       	ldi	r18, 0x00	; 0
     66a:	30 e0       	ldi	r19, 0x00	; 0
     66c:	45 e5       	ldi	r20, 0x55	; 85
     66e:	50 e0       	ldi	r21, 0x00	; 0
     670:	61 e2       	ldi	r22, 0x21	; 33
     672:	71 e0       	ldi	r23, 0x01	; 1
     674:	82 e8       	ldi	r24, 0x82	; 130
     676:	92 e0       	ldi	r25, 0x02	; 2
     678:	0e 94 d4 03 	call	0x7a8	; 0x7a8 <xTaskCreate>
}
     67c:	0f 91       	pop	r16
     67e:	ff 90       	pop	r15
     680:	ef 90       	pop	r14
     682:	08 95       	ret

00000684 <xAreRegTestTasksStillRunning>:
{
portBASE_TYPE xReturn;

	/* If a register was found to contain an unexpected value then the
	xRegTestError variable would have been set to a non zero value. */
	if( xRegTestError == pdFALSE )
     684:	81 e0       	ldi	r24, 0x01	; 1
     686:	90 91 55 01 	lds	r25, 0x0155
     68a:	91 11       	cpse	r25, r1
     68c:	80 e0       	ldi	r24, 0x00	; 0
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
     68e:	08 95       	ret

00000690 <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     690:	e0 91 7b 01 	lds	r30, 0x017B
     694:	f0 91 7c 01 	lds	r31, 0x017C
     698:	80 81       	ld	r24, Z
     69a:	81 11       	cpse	r24, r1
     69c:	03 c0       	rjmp	.+6      	; 0x6a4 <prvResetNextTaskUnblockTime+0x14>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
     69e:	8f ef       	ldi	r24, 0xFF	; 255
     6a0:	9f ef       	ldi	r25, 0xFF	; 255
     6a2:	0c c0       	rjmp	.+24     	; 0x6bc <prvResetNextTaskUnblockTime+0x2c>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
     6a4:	e0 91 7b 01 	lds	r30, 0x017B
     6a8:	f0 91 7c 01 	lds	r31, 0x017C
     6ac:	05 80       	ldd	r0, Z+5	; 0x05
     6ae:	f6 81       	ldd	r31, Z+6	; 0x06
     6b0:	e0 2d       	mov	r30, r0
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
     6b2:	06 80       	ldd	r0, Z+6	; 0x06
     6b4:	f7 81       	ldd	r31, Z+7	; 0x07
     6b6:	e0 2d       	mov	r30, r0
     6b8:	82 81       	ldd	r24, Z+2	; 0x02
     6ba:	93 81       	ldd	r25, Z+3	; 0x03
     6bc:	90 93 5c 01 	sts	0x015C, r25
     6c0:	80 93 5b 01 	sts	0x015B, r24
     6c4:	08 95       	ret

000006c6 <prvAddCurrentTaskToDelayedList.isra.2>:

#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
     6c6:	0f 93       	push	r16
     6c8:	1f 93       	push	r17
     6ca:	cf 93       	push	r28
     6cc:	df 93       	push	r29
     6ce:	ec 01       	movw	r28, r24
{
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
     6d0:	00 91 63 01 	lds	r16, 0x0163
     6d4:	10 91 64 01 	lds	r17, 0x0164
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
     6d8:	80 91 56 01 	lds	r24, 0x0156
     6dc:	90 91 57 01 	lds	r25, 0x0157
     6e0:	02 96       	adiw	r24, 0x02	; 2
     6e2:	0e 94 ac 0f 	call	0x1f58	; 0x1f58 <uxListRemove>
	#else /* INCLUDE_vTaskSuspend */
	{
		/* Calculate the time at which the task should be woken if the event
		does not occur.  This may overflow but this doesn't matter, the kernel
		will manage it correctly. */
		xTimeToWake = xConstTickCount + xTicksToWait;
     6e6:	c0 0f       	add	r28, r16
     6e8:	d1 1f       	adc	r29, r17

		/* The list item will be inserted in wake time order. */
		listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
     6ea:	e0 91 56 01 	lds	r30, 0x0156
     6ee:	f0 91 57 01 	lds	r31, 0x0157
     6f2:	d3 83       	std	Z+3, r29	; 0x03
     6f4:	c2 83       	std	Z+2, r28	; 0x02

		if( xTimeToWake < xConstTickCount )
		{
			/* Wake time has overflowed.  Place this item in the overflow list. */
			vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
     6f6:	60 91 56 01 	lds	r22, 0x0156
     6fa:	70 91 57 01 	lds	r23, 0x0157
		xTimeToWake = xConstTickCount + xTicksToWait;

		/* The list item will be inserted in wake time order. */
		listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );

		if( xTimeToWake < xConstTickCount )
     6fe:	c0 17       	cp	r28, r16
     700:	d1 07       	cpc	r29, r17
     702:	60 f4       	brcc	.+24     	; 0x71c <prvAddCurrentTaskToDelayedList.isra.2+0x56>
		{
			/* Wake time has overflowed.  Place this item in the overflow list. */
			vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
     704:	80 91 79 01 	lds	r24, 0x0179
     708:	90 91 7a 01 	lds	r25, 0x017A
     70c:	6e 5f       	subi	r22, 0xFE	; 254
     70e:	7f 4f       	sbci	r23, 0xFF	; 255

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
     710:	df 91       	pop	r29
     712:	cf 91       	pop	r28
     714:	1f 91       	pop	r17
     716:	0f 91       	pop	r16
		listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );

		if( xTimeToWake < xConstTickCount )
		{
			/* Wake time has overflowed.  Place this item in the overflow list. */
			vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
     718:	0c 94 74 0f 	jmp	0x1ee8	; 0x1ee8 <vListInsert>
		}
		else
		{
			/* The wake time has not overflowed, so the current block list is used. */
			vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
     71c:	80 91 7b 01 	lds	r24, 0x017B
     720:	90 91 7c 01 	lds	r25, 0x017C
     724:	6e 5f       	subi	r22, 0xFE	; 254
     726:	7f 4f       	sbci	r23, 0xFF	; 255
     728:	0e 94 74 0f 	call	0x1ee8	; 0x1ee8 <vListInsert>

			/* If the task entering the blocked state was placed at the head of the
			list of blocked tasks then xNextTaskUnblockTime needs to be updated
			too. */
			if( xTimeToWake < xNextTaskUnblockTime )
     72c:	80 91 5b 01 	lds	r24, 0x015B
     730:	90 91 5c 01 	lds	r25, 0x015C
     734:	c8 17       	cp	r28, r24
     736:	d9 07       	cpc	r29, r25
     738:	20 f4       	brcc	.+8      	; 0x742 <prvAddCurrentTaskToDelayedList.isra.2+0x7c>
			{
				xNextTaskUnblockTime = xTimeToWake;
     73a:	d0 93 5c 01 	sts	0x015C, r29
     73e:	c0 93 5b 01 	sts	0x015B, r28

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
     742:	df 91       	pop	r29
     744:	cf 91       	pop	r28
     746:	1f 91       	pop	r17
     748:	0f 91       	pop	r16
     74a:	08 95       	ret

0000074c <prvIdleTask>:
	{
		TCB_t *pxTCB;

		/* uxDeletedTasksWaitingCleanUp is used to prevent vTaskSuspendAll()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
     74c:	80 91 66 01 	lds	r24, 0x0166
     750:	88 23       	and	r24, r24
     752:	09 f1       	breq	.+66     	; 0x796 <prvIdleTask+0x4a>
		{
			taskENTER_CRITICAL();
     754:	0f b6       	in	r0, 0x3f	; 63
     756:	f8 94       	cli
     758:	0f 92       	push	r0
			{
				pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
     75a:	e0 91 6c 01 	lds	r30, 0x016C
     75e:	f0 91 6d 01 	lds	r31, 0x016D
     762:	c6 81       	ldd	r28, Z+6	; 0x06
     764:	d7 81       	ldd	r29, Z+7	; 0x07
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     766:	ce 01       	movw	r24, r28
     768:	02 96       	adiw	r24, 0x02	; 2
     76a:	0e 94 ac 0f 	call	0x1f58	; 0x1f58 <uxListRemove>
				--uxCurrentNumberOfTasks;
     76e:	80 91 65 01 	lds	r24, 0x0165
     772:	81 50       	subi	r24, 0x01	; 1
     774:	80 93 65 01 	sts	0x0165, r24
				--uxDeletedTasksWaitingCleanUp;
     778:	80 91 66 01 	lds	r24, 0x0166
     77c:	81 50       	subi	r24, 0x01	; 1
     77e:	80 93 66 01 	sts	0x0166, r24
			}
			taskEXIT_CRITICAL();
     782:	0f 90       	pop	r0
     784:	0f be       	out	0x3f, r0	; 63

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
     786:	8f 89       	ldd	r24, Y+23	; 0x17
     788:	98 8d       	ldd	r25, Y+24	; 0x18
     78a:	0e 94 8f 12 	call	0x251e	; 0x251e <vPortFree>
			vPortFree( pxTCB );
     78e:	ce 01       	movw	r24, r28
     790:	0e 94 8f 12 	call	0x251e	; 0x251e <vPortFree>
     794:	db cf       	rjmp	.-74     	; 0x74c <prvIdleTask>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
     796:	80 91 8f 01 	lds	r24, 0x018F
     79a:	82 30       	cpi	r24, 0x02	; 2
     79c:	10 f0       	brcs	.+4      	; 0x7a2 <prvIdleTask+0x56>
			{
				taskYIELD();
     79e:	0e 94 74 13 	call	0x26e8	; 0x26e8 <vPortYield>
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
     7a2:	0e 94 8c 00 	call	0x118	; 0x118 <vApplicationIdleHook>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_TICKLESS_IDLE */
	}
     7a6:	d2 cf       	rjmp	.-92     	; 0x74c <prvIdleTask>

000007a8 <xTaskCreate>:
							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
							const configSTACK_DEPTH_TYPE usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask )
	{
     7a8:	4f 92       	push	r4
     7aa:	5f 92       	push	r5
     7ac:	6f 92       	push	r6
     7ae:	7f 92       	push	r7
     7b0:	8f 92       	push	r8
     7b2:	9f 92       	push	r9
     7b4:	af 92       	push	r10
     7b6:	bf 92       	push	r11
     7b8:	cf 92       	push	r12
     7ba:	df 92       	push	r13
     7bc:	ef 92       	push	r14
     7be:	ff 92       	push	r15
     7c0:	0f 93       	push	r16
     7c2:	1f 93       	push	r17
     7c4:	cf 93       	push	r28
     7c6:	df 93       	push	r29
     7c8:	5c 01       	movw	r10, r24
     7ca:	76 2e       	mov	r7, r22
     7cc:	17 2f       	mov	r17, r23
     7ce:	6a 01       	movw	r12, r20
     7d0:	49 01       	movw	r8, r18
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     7d2:	ca 01       	movw	r24, r20
     7d4:	0e 94 da 11 	call	0x23b4	; 0x23b4 <pvPortMalloc>
     7d8:	2c 01       	movw	r4, r24

			if( pxStack != NULL )
     7da:	89 2b       	or	r24, r25
     7dc:	09 f4       	brne	.+2      	; 0x7e0 <xTaskCreate+0x38>
     7de:	cc c0       	rjmp	.+408    	; 0x978 <__stack+0x79>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
     7e0:	86 e2       	ldi	r24, 0x26	; 38
     7e2:	90 e0       	ldi	r25, 0x00	; 0
     7e4:	0e 94 da 11 	call	0x23b4	; 0x23b4 <pvPortMalloc>
     7e8:	ec 01       	movw	r28, r24

				if( pxNewTCB != NULL )
     7ea:	00 97       	sbiw	r24, 0x00	; 0
     7ec:	79 f0       	breq	.+30     	; 0x80c <xTaskCreate+0x64>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
     7ee:	58 8e       	std	Y+24, r5	; 0x18
     7f0:	4f 8a       	std	Y+23, r4	; 0x17
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
     7f2:	21 e0       	ldi	r18, 0x01	; 1
     7f4:	c2 1a       	sub	r12, r18
     7f6:	d1 08       	sbc	r13, r1
     7f8:	c4 0c       	add	r12, r4
     7fa:	d5 1c       	adc	r13, r5
     7fc:	bc 01       	movw	r22, r24
     7fe:	67 5e       	subi	r22, 0xE7	; 231
     800:	7f 4f       	sbci	r23, 0xFF	; 255
     802:	e7 2d       	mov	r30, r7
     804:	f1 2f       	mov	r31, r17
     806:	cf 01       	movw	r24, r30
     808:	08 96       	adiw	r24, 0x08	; 8
     80a:	07 c0       	rjmp	.+14     	; 0x81a <xTaskCreate+0x72>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
     80c:	c2 01       	movw	r24, r4
     80e:	0e 94 8f 12 	call	0x251e	; 0x251e <vPortFree>
     812:	b2 c0       	rjmp	.+356    	; 0x978 <__stack+0x79>
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
     814:	e8 17       	cp	r30, r24
     816:	f9 07       	cpc	r31, r25
     818:	49 f0       	breq	.+18     	; 0x82c <xTaskCreate+0x84>
     81a:	9f 01       	movw	r18, r30
	{
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
     81c:	41 91       	ld	r20, Z+
     81e:	db 01       	movw	r26, r22
     820:	4d 93       	st	X+, r20
     822:	bd 01       	movw	r22, r26

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
     824:	d9 01       	movw	r26, r18
     826:	2c 91       	ld	r18, X
     828:	21 11       	cpse	r18, r1
     82a:	f4 cf       	rjmp	.-24     	; 0x814 <xTaskCreate+0x6c>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
     82c:	18 a2       	std	Y+32, r1	; 0x20
     82e:	04 30       	cpi	r16, 0x04	; 4
     830:	08 f0       	brcs	.+2      	; 0x834 <xTaskCreate+0x8c>
     832:	03 e0       	ldi	r16, 0x03	; 3
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
     834:	0e 8b       	std	Y+22, r16	; 0x16
		pxNewTCB->uxBasePriority = uxPriority;
		pxNewTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
     836:	3e 01       	movw	r6, r28
     838:	b2 e0       	ldi	r27, 0x02	; 2
     83a:	6b 0e       	add	r6, r27
     83c:	71 1c       	adc	r7, r1
     83e:	c3 01       	movw	r24, r6
     840:	0e 94 4f 0f 	call	0x1e9e	; 0x1e9e <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
     844:	ce 01       	movw	r24, r28
     846:	0c 96       	adiw	r24, 0x0c	; 12
     848:	0e 94 4f 0f 	call	0x1e9e	; 0x1e9e <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
     84c:	d9 87       	std	Y+9, r29	; 0x09
     84e:	c8 87       	std	Y+8, r28	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     850:	84 e0       	ldi	r24, 0x04	; 4
     852:	90 e0       	ldi	r25, 0x00	; 0
     854:	80 1b       	sub	r24, r16
     856:	91 09       	sbc	r25, r1
     858:	9d 87       	std	Y+13, r25	; 0x0d
     85a:	8c 87       	std	Y+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
     85c:	db 8b       	std	Y+19, r29	; 0x13
     85e:	ca 8b       	std	Y+18, r28	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
     860:	19 a2       	std	Y+33, r1	; 0x21
     862:	1a a2       	std	Y+34, r1	; 0x22
     864:	1b a2       	std	Y+35, r1	; 0x23
     866:	1c a2       	std	Y+36, r1	; 0x24
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
     868:	1d a2       	std	Y+37, r1	; 0x25
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
	}
	#else /* portUSING_MPU_WRAPPERS */
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
     86a:	a4 01       	movw	r20, r8
     86c:	b5 01       	movw	r22, r10
     86e:	c6 01       	movw	r24, r12
     870:	0e 94 cd 12 	call	0x259a	; 0x259a <pxPortInitialiseStack>
     874:	99 83       	std	Y+1, r25	; 0x01
     876:	88 83       	st	Y, r24
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( ( void * ) pxCreatedTask != NULL )
     878:	e1 14       	cp	r14, r1
     87a:	f1 04       	cpc	r15, r1
     87c:	19 f0       	breq	.+6      	; 0x884 <xTaskCreate+0xdc>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
     87e:	f7 01       	movw	r30, r14
     880:	d1 83       	std	Z+1, r29	; 0x01
     882:	c0 83       	st	Z, r28

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
     884:	0f b6       	in	r0, 0x3f	; 63
     886:	f8 94       	cli
     888:	0f 92       	push	r0
	{
		uxCurrentNumberOfTasks++;
     88a:	80 91 65 01 	lds	r24, 0x0165
     88e:	8f 5f       	subi	r24, 0xFF	; 255
     890:	80 93 65 01 	sts	0x0165, r24
		if( pxCurrentTCB == NULL )
     894:	80 91 56 01 	lds	r24, 0x0156
     898:	90 91 57 01 	lds	r25, 0x0157
     89c:	89 2b       	or	r24, r25
     89e:	a9 f5       	brne	.+106    	; 0x90a <__stack+0xb>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
     8a0:	d0 93 57 01 	sts	0x0157, r29
     8a4:	c0 93 56 01 	sts	0x0156, r28

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
     8a8:	80 91 65 01 	lds	r24, 0x0165
     8ac:	81 30       	cpi	r24, 0x01	; 1
     8ae:	e9 f5       	brne	.+122    	; 0x92a <__stack+0x2b>
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
     8b0:	8f e8       	ldi	r24, 0x8F	; 143
     8b2:	91 e0       	ldi	r25, 0x01	; 1
     8b4:	0e 94 41 0f 	call	0x1e82	; 0x1e82 <vListInitialise>
     8b8:	88 e9       	ldi	r24, 0x98	; 152
     8ba:	91 e0       	ldi	r25, 0x01	; 1
     8bc:	0e 94 41 0f 	call	0x1e82	; 0x1e82 <vListInitialise>
     8c0:	81 ea       	ldi	r24, 0xA1	; 161
     8c2:	91 e0       	ldi	r25, 0x01	; 1
     8c4:	0e 94 41 0f 	call	0x1e82	; 0x1e82 <vListInitialise>
     8c8:	8a ea       	ldi	r24, 0xAA	; 170
     8ca:	91 e0       	ldi	r25, 0x01	; 1
     8cc:	0e 94 41 0f 	call	0x1e82	; 0x1e82 <vListInitialise>
	}

	vListInitialise( &xDelayedTaskList1 );
     8d0:	86 e8       	ldi	r24, 0x86	; 134
     8d2:	91 e0       	ldi	r25, 0x01	; 1
     8d4:	0e 94 41 0f 	call	0x1e82	; 0x1e82 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
     8d8:	8d e7       	ldi	r24, 0x7D	; 125
     8da:	91 e0       	ldi	r25, 0x01	; 1
     8dc:	0e 94 41 0f 	call	0x1e82	; 0x1e82 <vListInitialise>
	vListInitialise( &xPendingReadyList );
     8e0:	80 e7       	ldi	r24, 0x70	; 112
     8e2:	91 e0       	ldi	r25, 0x01	; 1
     8e4:	0e 94 41 0f 	call	0x1e82	; 0x1e82 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
     8e8:	87 e6       	ldi	r24, 0x67	; 103
     8ea:	91 e0       	ldi	r25, 0x01	; 1
     8ec:	0e 94 41 0f 	call	0x1e82	; 0x1e82 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
     8f0:	86 e8       	ldi	r24, 0x86	; 134
     8f2:	91 e0       	ldi	r25, 0x01	; 1
     8f4:	90 93 7c 01 	sts	0x017C, r25
     8f8:	80 93 7b 01 	sts	0x017B, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
     8fc:	8d e7       	ldi	r24, 0x7D	; 125
     8fe:	91 e0       	ldi	r25, 0x01	; 1
     900:	90 93 7a 01 	sts	0x017A, r25
     904:	80 93 79 01 	sts	0x0179, r24
     908:	10 c0       	rjmp	.+32     	; 0x92a <__stack+0x2b>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
     90a:	80 91 61 01 	lds	r24, 0x0161
     90e:	81 11       	cpse	r24, r1
     910:	0c c0       	rjmp	.+24     	; 0x92a <__stack+0x2b>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
     912:	e0 91 56 01 	lds	r30, 0x0156
     916:	f0 91 57 01 	lds	r31, 0x0157
     91a:	96 89       	ldd	r25, Z+22	; 0x16
     91c:	8e 89       	ldd	r24, Y+22	; 0x16
     91e:	89 17       	cp	r24, r25
     920:	20 f0       	brcs	.+8      	; 0x92a <__stack+0x2b>
				{
					pxCurrentTCB = pxNewTCB;
     922:	d0 93 57 01 	sts	0x0157, r29
     926:	c0 93 56 01 	sts	0x0156, r28
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
     92a:	80 91 5d 01 	lds	r24, 0x015D
     92e:	8f 5f       	subi	r24, 0xFF	; 255
     930:	80 93 5d 01 	sts	0x015D, r24
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
     934:	8e 89       	ldd	r24, Y+22	; 0x16
     936:	90 91 62 01 	lds	r25, 0x0162
     93a:	98 17       	cp	r25, r24
     93c:	10 f4       	brcc	.+4      	; 0x942 <__stack+0x43>
     93e:	80 93 62 01 	sts	0x0162, r24
     942:	f9 e0       	ldi	r31, 0x09	; 9
     944:	8f 9f       	mul	r24, r31
     946:	c0 01       	movw	r24, r0
     948:	11 24       	eor	r1, r1
     94a:	b3 01       	movw	r22, r6
     94c:	81 57       	subi	r24, 0x71	; 113
     94e:	9e 4f       	sbci	r25, 0xFE	; 254
     950:	0e 94 53 0f 	call	0x1ea6	; 0x1ea6 <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
     954:	0f 90       	pop	r0
     956:	0f be       	out	0x3f, r0	; 63

	if( xSchedulerRunning != pdFALSE )
     958:	80 91 61 01 	lds	r24, 0x0161
     95c:	88 23       	and	r24, r24
     95e:	51 f0       	breq	.+20     	; 0x974 <__stack+0x75>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
     960:	e0 91 56 01 	lds	r30, 0x0156
     964:	f0 91 57 01 	lds	r31, 0x0157
     968:	96 89       	ldd	r25, Z+22	; 0x16
     96a:	8e 89       	ldd	r24, Y+22	; 0x16
     96c:	98 17       	cp	r25, r24
     96e:	10 f4       	brcc	.+4      	; 0x974 <__stack+0x75>
		{
			taskYIELD_IF_USING_PREEMPTION();
     970:	0e 94 74 13 	call	0x26e8	; 0x26e8 <vPortYield>
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
			prvAddNewTaskToReadyList( pxNewTCB );
			xReturn = pdPASS;
     974:	81 e0       	ldi	r24, 0x01	; 1
     976:	01 c0       	rjmp	.+2      	; 0x97a <__stack+0x7b>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     978:	8f ef       	ldi	r24, 0xFF	; 255
		}

		return xReturn;
	}
     97a:	df 91       	pop	r29
     97c:	cf 91       	pop	r28
     97e:	1f 91       	pop	r17
     980:	0f 91       	pop	r16
     982:	ff 90       	pop	r15
     984:	ef 90       	pop	r14
     986:	df 90       	pop	r13
     988:	cf 90       	pop	r12
     98a:	bf 90       	pop	r11
     98c:	af 90       	pop	r10
     98e:	9f 90       	pop	r9
     990:	8f 90       	pop	r8
     992:	7f 90       	pop	r7
     994:	6f 90       	pop	r6
     996:	5f 90       	pop	r5
     998:	4f 90       	pop	r4
     99a:	08 95       	ret

0000099c <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
     99c:	0f 93       	push	r16
     99e:	1f 93       	push	r17
     9a0:	cf 93       	push	r28
     9a2:	df 93       	push	r29
     9a4:	ec 01       	movw	r28, r24
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
     9a6:	0f b6       	in	r0, 0x3f	; 63
     9a8:	f8 94       	cli
     9aa:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
     9ac:	89 2b       	or	r24, r25
     9ae:	21 f4       	brne	.+8      	; 0x9b8 <vTaskDelete+0x1c>
     9b0:	c0 91 56 01 	lds	r28, 0x0156
     9b4:	d0 91 57 01 	lds	r29, 0x0157

			/* Remove task from the ready list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
     9b8:	8e 01       	movw	r16, r28
     9ba:	0e 5f       	subi	r16, 0xFE	; 254
     9bc:	1f 4f       	sbci	r17, 0xFF	; 255
     9be:	c8 01       	movw	r24, r16
     9c0:	0e 94 ac 0f 	call	0x1f58	; 0x1f58 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
     9c4:	8c 89       	ldd	r24, Y+20	; 0x14
     9c6:	9d 89       	ldd	r25, Y+21	; 0x15
     9c8:	89 2b       	or	r24, r25
     9ca:	21 f0       	breq	.+8      	; 0x9d4 <vTaskDelete+0x38>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     9cc:	ce 01       	movw	r24, r28
     9ce:	0c 96       	adiw	r24, 0x0c	; 12
     9d0:	0e 94 ac 0f 	call	0x1f58	; 0x1f58 <uxListRemove>

			/* Increment the uxTaskNumber also so kernel aware debuggers can
			detect that the task lists need re-generating.  This is done before
			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
			not return. */
			uxTaskNumber++;
     9d4:	90 91 5d 01 	lds	r25, 0x015D
     9d8:	9f 5f       	subi	r25, 0xFF	; 255
     9da:	90 93 5d 01 	sts	0x015D, r25

			if( pxTCB == pxCurrentTCB )
     9de:	80 91 56 01 	lds	r24, 0x0156
     9e2:	90 91 57 01 	lds	r25, 0x0157
     9e6:	c8 17       	cp	r28, r24
     9e8:	d9 07       	cpc	r29, r25
     9ea:	59 f4       	brne	.+22     	; 0xa02 <vTaskDelete+0x66>
				/* A task is deleting itself.  This cannot complete within the
				task itself, as a context switch to another task is required.
				Place the task in the termination list.  The idle task will
				check the termination list and free up any memory allocated by
				the scheduler for the TCB and stack of the deleted task. */
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
     9ec:	b8 01       	movw	r22, r16
     9ee:	87 e6       	ldi	r24, 0x67	; 103
     9f0:	91 e0       	ldi	r25, 0x01	; 1
     9f2:	0e 94 53 0f 	call	0x1ea6	; 0x1ea6 <vListInsertEnd>

				/* Increment the ucTasksDeleted variable so the idle task knows
				there is a task that has been deleted and that it should therefore
				check the xTasksWaitingTermination list. */
				++uxDeletedTasksWaitingCleanUp;
     9f6:	80 91 66 01 	lds	r24, 0x0166
     9fa:	8f 5f       	subi	r24, 0xFF	; 255
     9fc:	80 93 66 01 	sts	0x0166, r24
     a00:	0e c0       	rjmp	.+28     	; 0xa1e <vTaskDelete+0x82>
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
			}
			else
			{
				--uxCurrentNumberOfTasks;
     a02:	80 91 65 01 	lds	r24, 0x0165
     a06:	81 50       	subi	r24, 0x01	; 1
     a08:	80 93 65 01 	sts	0x0165, r24

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
     a0c:	8f 89       	ldd	r24, Y+23	; 0x17
     a0e:	98 8d       	ldd	r25, Y+24	; 0x18
     a10:	0e 94 8f 12 	call	0x251e	; 0x251e <vPortFree>
			vPortFree( pxTCB );
     a14:	ce 01       	movw	r24, r28
     a16:	0e 94 8f 12 	call	0x251e	; 0x251e <vPortFree>
				--uxCurrentNumberOfTasks;
				prvDeleteTCB( pxTCB );

				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				prvResetNextTaskUnblockTime();
     a1a:	0e 94 48 03 	call	0x690	; 0x690 <prvResetNextTaskUnblockTime>
			}

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
     a1e:	0f 90       	pop	r0
     a20:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
     a22:	80 91 61 01 	lds	r24, 0x0161
     a26:	88 23       	and	r24, r24
     a28:	49 f0       	breq	.+18     	; 0xa3c <vTaskDelete+0xa0>
		{
			if( pxTCB == pxCurrentTCB )
     a2a:	80 91 56 01 	lds	r24, 0x0156
     a2e:	90 91 57 01 	lds	r25, 0x0157
     a32:	c8 17       	cp	r28, r24
     a34:	d9 07       	cpc	r29, r25
     a36:	11 f4       	brne	.+4      	; 0xa3c <vTaskDelete+0xa0>
			{
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
     a38:	0e 94 74 13 	call	0x26e8	; 0x26e8 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
     a3c:	df 91       	pop	r29
     a3e:	cf 91       	pop	r28
     a40:	1f 91       	pop	r17
     a42:	0f 91       	pop	r16
     a44:	08 95       	ret

00000a46 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
     a46:	ef 92       	push	r14
     a48:	ff 92       	push	r15
     a4a:	0f 93       	push	r16
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
     a4c:	89 e5       	ldi	r24, 0x59	; 89
     a4e:	e8 2e       	mov	r14, r24
     a50:	81 e0       	ldi	r24, 0x01	; 1
     a52:	f8 2e       	mov	r15, r24
     a54:	00 e0       	ldi	r16, 0x00	; 0
     a56:	20 e0       	ldi	r18, 0x00	; 0
     a58:	30 e0       	ldi	r19, 0x00	; 0
     a5a:	45 e5       	ldi	r20, 0x55	; 85
     a5c:	50 e0       	ldi	r21, 0x00	; 0
     a5e:	66 e2       	ldi	r22, 0x26	; 38
     a60:	71 e0       	ldi	r23, 0x01	; 1
     a62:	86 ea       	ldi	r24, 0xA6	; 166
     a64:	93 e0       	ldi	r25, 0x03	; 3
     a66:	0e 94 d4 03 	call	0x7a8	; 0x7a8 <xTaskCreate>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
     a6a:	81 30       	cpi	r24, 0x01	; 1
     a6c:	91 f4       	brne	.+36     	; 0xa92 <vTaskStartScheduler+0x4c>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
     a6e:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
     a70:	2f ef       	ldi	r18, 0xFF	; 255
     a72:	3f ef       	ldi	r19, 0xFF	; 255
     a74:	30 93 5c 01 	sts	0x015C, r19
     a78:	20 93 5b 01 	sts	0x015B, r18
		xSchedulerRunning = pdTRUE;
     a7c:	80 93 61 01 	sts	0x0161, r24
		xTickCount = ( TickType_t ) 0U;
     a80:	10 92 64 01 	sts	0x0164, r1
     a84:	10 92 63 01 	sts	0x0163, r1
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
     a88:	0f 91       	pop	r16
     a8a:	ff 90       	pop	r15
     a8c:	ef 90       	pop	r14
		FreeRTOSConfig.h file. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
     a8e:	0c 94 39 13 	jmp	0x2672	; 0x2672 <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
     a92:	0f 91       	pop	r16
     a94:	ff 90       	pop	r15
     a96:	ef 90       	pop	r14
     a98:	08 95       	ret

00000a9a <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
     a9a:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
     a9c:	10 92 61 01 	sts	0x0161, r1
	vPortEndScheduler();
     aa0:	0c 94 73 13 	jmp	0x26e6	; 0x26e6 <vPortEndScheduler>

00000aa4 <vTaskSuspendAll>:
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
     aa4:	80 91 58 01 	lds	r24, 0x0158
     aa8:	8f 5f       	subi	r24, 0xFF	; 255
     aaa:	80 93 58 01 	sts	0x0158, r24
     aae:	08 95       	ret

00000ab0 <xTaskGetTickCount>:
TickType_t xTaskGetTickCount( void )
{
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
     ab0:	0f b6       	in	r0, 0x3f	; 63
     ab2:	f8 94       	cli
     ab4:	0f 92       	push	r0
	{
		xTicks = xTickCount;
     ab6:	80 91 63 01 	lds	r24, 0x0163
     aba:	90 91 64 01 	lds	r25, 0x0164
	}
	portTICK_TYPE_EXIT_CRITICAL();
     abe:	0f 90       	pop	r0
     ac0:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
     ac2:	08 95       	ret

00000ac4 <xTaskGetTickCountFromISR>:
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
	{
		xReturn = xTickCount;
     ac4:	80 91 63 01 	lds	r24, 0x0163
     ac8:	90 91 64 01 	lds	r25, 0x0164
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     acc:	08 95       	ret

00000ace <uxTaskGetNumberOfTasks>:

UBaseType_t uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
     ace:	80 91 65 01 	lds	r24, 0x0165
}
     ad2:	08 95       	ret

00000ad4 <pcTaskGetName>:
{
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
     ad4:	00 97       	sbiw	r24, 0x00	; 0
     ad6:	21 f4       	brne	.+8      	; 0xae0 <pcTaskGetName+0xc>
     ad8:	80 91 56 01 	lds	r24, 0x0156
     adc:	90 91 57 01 	lds	r25, 0x0157
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
}
     ae0:	49 96       	adiw	r24, 0x19	; 25
     ae2:	08 95       	ret

00000ae4 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
     ae4:	cf 92       	push	r12
     ae6:	df 92       	push	r13
     ae8:	ef 92       	push	r14
     aea:	ff 92       	push	r15
     aec:	0f 93       	push	r16
     aee:	1f 93       	push	r17
     af0:	cf 93       	push	r28
     af2:	df 93       	push	r29

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     af4:	80 91 58 01 	lds	r24, 0x0158
     af8:	81 11       	cpse	r24, r1
     afa:	8c c0       	rjmp	.+280    	; 0xc14 <xTaskIncrementTick+0x130>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
     afc:	00 91 63 01 	lds	r16, 0x0163
     b00:	10 91 64 01 	lds	r17, 0x0164
     b04:	0f 5f       	subi	r16, 0xFF	; 255
     b06:	1f 4f       	sbci	r17, 0xFF	; 255

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
     b08:	10 93 64 01 	sts	0x0164, r17
     b0c:	00 93 63 01 	sts	0x0163, r16

		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
     b10:	01 15       	cp	r16, r1
     b12:	11 05       	cpc	r17, r1
     b14:	b9 f4       	brne	.+46     	; 0xb44 <xTaskIncrementTick+0x60>
		{
			taskSWITCH_DELAYED_LISTS();
     b16:	80 91 7b 01 	lds	r24, 0x017B
     b1a:	90 91 7c 01 	lds	r25, 0x017C
     b1e:	20 91 79 01 	lds	r18, 0x0179
     b22:	30 91 7a 01 	lds	r19, 0x017A
     b26:	30 93 7c 01 	sts	0x017C, r19
     b2a:	20 93 7b 01 	sts	0x017B, r18
     b2e:	90 93 7a 01 	sts	0x017A, r25
     b32:	80 93 79 01 	sts	0x0179, r24
     b36:	80 91 5e 01 	lds	r24, 0x015E
     b3a:	8f 5f       	subi	r24, 0xFF	; 255
     b3c:	80 93 5e 01 	sts	0x015E, r24
     b40:	0e 94 48 03 	call	0x690	; 0x690 <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
     b44:	80 91 5b 01 	lds	r24, 0x015B
     b48:	90 91 5c 01 	lds	r25, 0x015C
     b4c:	c0 e0       	ldi	r28, 0x00	; 0
     b4e:	08 17       	cp	r16, r24
     b50:	19 07       	cpc	r17, r25
     b52:	08 f4       	brcc	.+2      	; 0xb56 <xTaskIncrementTick+0x72>
     b54:	4f c0       	rjmp	.+158    	; 0xbf4 <xTaskIncrementTick+0x110>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
     b56:	d9 e0       	ldi	r29, 0x09	; 9
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     b58:	e0 91 7b 01 	lds	r30, 0x017B
     b5c:	f0 91 7c 01 	lds	r31, 0x017C
     b60:	80 81       	ld	r24, Z
     b62:	81 11       	cpse	r24, r1
     b64:	03 c0       	rjmp	.+6      	; 0xb6c <xTaskIncrementTick+0x88>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     b66:	8f ef       	ldi	r24, 0xFF	; 255
     b68:	9f ef       	ldi	r25, 0xFF	; 255
     b6a:	11 c0       	rjmp	.+34     	; 0xb8e <xTaskIncrementTick+0xaa>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
     b6c:	e0 91 7b 01 	lds	r30, 0x017B
     b70:	f0 91 7c 01 	lds	r31, 0x017C
     b74:	05 80       	ldd	r0, Z+5	; 0x05
     b76:	f6 81       	ldd	r31, Z+6	; 0x06
     b78:	e0 2d       	mov	r30, r0
     b7a:	e6 80       	ldd	r14, Z+6	; 0x06
     b7c:	f7 80       	ldd	r15, Z+7	; 0x07
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
     b7e:	d7 01       	movw	r26, r14
     b80:	12 96       	adiw	r26, 0x02	; 2
     b82:	8d 91       	ld	r24, X+
     b84:	9c 91       	ld	r25, X
     b86:	13 97       	sbiw	r26, 0x03	; 3

					if( xConstTickCount < xItemValue )
     b88:	08 17       	cp	r16, r24
     b8a:	19 07       	cpc	r17, r25
     b8c:	28 f4       	brcc	.+10     	; 0xb98 <xTaskIncrementTick+0xb4>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
     b8e:	90 93 5c 01 	sts	0x015C, r25
     b92:	80 93 5b 01 	sts	0x015B, r24
						break;
     b96:	2e c0       	rjmp	.+92     	; 0xbf4 <xTaskIncrementTick+0x110>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     b98:	67 01       	movw	r12, r14
     b9a:	b2 e0       	ldi	r27, 0x02	; 2
     b9c:	cb 0e       	add	r12, r27
     b9e:	d1 1c       	adc	r13, r1
     ba0:	c6 01       	movw	r24, r12
     ba2:	0e 94 ac 0f 	call	0x1f58	; 0x1f58 <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
     ba6:	f7 01       	movw	r30, r14
     ba8:	84 89       	ldd	r24, Z+20	; 0x14
     baa:	95 89       	ldd	r25, Z+21	; 0x15
     bac:	89 2b       	or	r24, r25
     bae:	21 f0       	breq	.+8      	; 0xbb8 <xTaskIncrementTick+0xd4>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     bb0:	c7 01       	movw	r24, r14
     bb2:	0c 96       	adiw	r24, 0x0c	; 12
     bb4:	0e 94 ac 0f 	call	0x1f58	; 0x1f58 <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
     bb8:	d7 01       	movw	r26, r14
     bba:	56 96       	adiw	r26, 0x16	; 22
     bbc:	9c 91       	ld	r25, X
     bbe:	80 91 62 01 	lds	r24, 0x0162
     bc2:	89 17       	cp	r24, r25
     bc4:	10 f4       	brcc	.+4      	; 0xbca <xTaskIncrementTick+0xe6>
     bc6:	90 93 62 01 	sts	0x0162, r25
     bca:	d9 9f       	mul	r29, r25
     bcc:	c0 01       	movw	r24, r0
     bce:	11 24       	eor	r1, r1
     bd0:	b6 01       	movw	r22, r12
     bd2:	81 57       	subi	r24, 0x71	; 113
     bd4:	9e 4f       	sbci	r25, 0xFE	; 254
     bd6:	0e 94 53 0f 	call	0x1ea6	; 0x1ea6 <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     bda:	e0 91 56 01 	lds	r30, 0x0156
     bde:	f0 91 57 01 	lds	r31, 0x0157
     be2:	d7 01       	movw	r26, r14
     be4:	56 96       	adiw	r26, 0x16	; 22
     be6:	9c 91       	ld	r25, X
     be8:	86 89       	ldd	r24, Z+22	; 0x16
     bea:	98 17       	cp	r25, r24
     bec:	08 f4       	brcc	.+2      	; 0xbf0 <xTaskIncrementTick+0x10c>
     bee:	b4 cf       	rjmp	.-152    	; 0xb58 <xTaskIncrementTick+0x74>
						{
							xSwitchRequired = pdTRUE;
     bf0:	c1 e0       	ldi	r28, 0x01	; 1
     bf2:	b2 cf       	rjmp	.-156    	; 0xb58 <xTaskIncrementTick+0x74>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
     bf4:	e0 91 56 01 	lds	r30, 0x0156
     bf8:	f0 91 57 01 	lds	r31, 0x0157
     bfc:	e6 89       	ldd	r30, Z+22	; 0x16
     bfe:	b9 e0       	ldi	r27, 0x09	; 9
     c00:	eb 9f       	mul	r30, r27
     c02:	f0 01       	movw	r30, r0
     c04:	11 24       	eor	r1, r1
     c06:	e1 57       	subi	r30, 0x71	; 113
     c08:	fe 4f       	sbci	r31, 0xFE	; 254
     c0a:	80 81       	ld	r24, Z
     c0c:	82 30       	cpi	r24, 0x02	; 2
     c0e:	40 f0       	brcs	.+16     	; 0xc20 <xTaskIncrementTick+0x13c>
			{
				xSwitchRequired = pdTRUE;
     c10:	c1 e0       	ldi	r28, 0x01	; 1
     c12:	06 c0       	rjmp	.+12     	; 0xc20 <xTaskIncrementTick+0x13c>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
     c14:	80 91 60 01 	lds	r24, 0x0160
     c18:	8f 5f       	subi	r24, 0xFF	; 255
     c1a:	80 93 60 01 	sts	0x0160, r24

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
     c1e:	c0 e0       	ldi	r28, 0x00	; 0
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
     c20:	80 91 5f 01 	lds	r24, 0x015F
     c24:	81 11       	cpse	r24, r1
		{
			xSwitchRequired = pdTRUE;
     c26:	c1 e0       	ldi	r28, 0x01	; 1
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
}
     c28:	8c 2f       	mov	r24, r28
     c2a:	df 91       	pop	r29
     c2c:	cf 91       	pop	r28
     c2e:	1f 91       	pop	r17
     c30:	0f 91       	pop	r16
     c32:	ff 90       	pop	r15
     c34:	ef 90       	pop	r14
     c36:	df 90       	pop	r13
     c38:	cf 90       	pop	r12
     c3a:	08 95       	ret

00000c3c <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
     c3c:	ef 92       	push	r14
     c3e:	ff 92       	push	r15
     c40:	0f 93       	push	r16
     c42:	1f 93       	push	r17
     c44:	cf 93       	push	r28
     c46:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
     c48:	0f b6       	in	r0, 0x3f	; 63
     c4a:	f8 94       	cli
     c4c:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
     c4e:	80 91 58 01 	lds	r24, 0x0158
     c52:	81 50       	subi	r24, 0x01	; 1
     c54:	80 93 58 01 	sts	0x0158, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     c58:	80 91 58 01 	lds	r24, 0x0158
     c5c:	88 23       	and	r24, r24
     c5e:	11 f0       	breq	.+4      	; 0xc64 <xTaskResumeAll+0x28>
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
TCB_t *pxTCB = NULL;
BaseType_t xAlreadyYielded = pdFALSE;
     c60:	80 e0       	ldi	r24, 0x00	; 0
     c62:	52 c0       	rjmp	.+164    	; 0xd08 <xTaskResumeAll+0xcc>
	{
		--uxSchedulerSuspended;

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
     c64:	80 91 65 01 	lds	r24, 0x0165
     c68:	88 23       	and	r24, r24
     c6a:	d1 f3       	breq	.-12     	; 0xc60 <xTaskResumeAll+0x24>
     c6c:	c0 e0       	ldi	r28, 0x00	; 0
     c6e:	d0 e0       	ldi	r29, 0x00	; 0
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
					prvAddTaskToReadyList( pxTCB );
     c70:	89 e0       	ldi	r24, 0x09	; 9
     c72:	f8 2e       	mov	r15, r24

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldPending = pdTRUE;
     c74:	ee 24       	eor	r14, r14
     c76:	e3 94       	inc	r14
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
     c78:	80 91 70 01 	lds	r24, 0x0170
     c7c:	88 23       	and	r24, r24
     c7e:	51 f1       	breq	.+84     	; 0xcd4 <xTaskResumeAll+0x98>
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
     c80:	e0 91 75 01 	lds	r30, 0x0175
     c84:	f0 91 76 01 	lds	r31, 0x0176
     c88:	c6 81       	ldd	r28, Z+6	; 0x06
     c8a:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     c8c:	ce 01       	movw	r24, r28
     c8e:	0c 96       	adiw	r24, 0x0c	; 12
     c90:	0e 94 ac 0f 	call	0x1f58	; 0x1f58 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     c94:	8e 01       	movw	r16, r28
     c96:	0e 5f       	subi	r16, 0xFE	; 254
     c98:	1f 4f       	sbci	r17, 0xFF	; 255
     c9a:	c8 01       	movw	r24, r16
     c9c:	0e 94 ac 0f 	call	0x1f58	; 0x1f58 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
     ca0:	9e 89       	ldd	r25, Y+22	; 0x16
     ca2:	80 91 62 01 	lds	r24, 0x0162
     ca6:	89 17       	cp	r24, r25
     ca8:	10 f4       	brcc	.+4      	; 0xcae <xTaskResumeAll+0x72>
     caa:	90 93 62 01 	sts	0x0162, r25
     cae:	f9 9e       	mul	r15, r25
     cb0:	c0 01       	movw	r24, r0
     cb2:	11 24       	eor	r1, r1
     cb4:	b8 01       	movw	r22, r16
     cb6:	81 57       	subi	r24, 0x71	; 113
     cb8:	9e 4f       	sbci	r25, 0xFE	; 254
     cba:	0e 94 53 0f 	call	0x1ea6	; 0x1ea6 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     cbe:	e0 91 56 01 	lds	r30, 0x0156
     cc2:	f0 91 57 01 	lds	r31, 0x0157
     cc6:	9e 89       	ldd	r25, Y+22	; 0x16
     cc8:	86 89       	ldd	r24, Z+22	; 0x16
     cca:	98 17       	cp	r25, r24
     ccc:	a8 f2       	brcs	.-86     	; 0xc78 <xTaskResumeAll+0x3c>
					{
						xYieldPending = pdTRUE;
     cce:	e0 92 5f 01 	sts	0x015F, r14
     cd2:	d2 cf       	rjmp	.-92     	; 0xc78 <xTaskResumeAll+0x3c>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
     cd4:	cd 2b       	or	r28, r29
     cd6:	11 f0       	breq	.+4      	; 0xcdc <xTaskResumeAll+0xa0>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
     cd8:	0e 94 48 03 	call	0x690	; 0x690 <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
     cdc:	c0 91 60 01 	lds	r28, 0x0160

					if( uxPendedCounts > ( UBaseType_t ) 0U )
     ce0:	cc 23       	and	r28, r28
     ce2:	51 f0       	breq	.+20     	; 0xcf8 <xTaskResumeAll+0xbc>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
							{
								xYieldPending = pdTRUE;
     ce4:	d1 e0       	ldi	r29, 0x01	; 1

					if( uxPendedCounts > ( UBaseType_t ) 0U )
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
     ce6:	0e 94 72 05 	call	0xae4	; 0xae4 <xTaskIncrementTick>
     cea:	81 11       	cpse	r24, r1
							{
								xYieldPending = pdTRUE;
     cec:	d0 93 5f 01 	sts	0x015F, r29
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
     cf0:	c1 50       	subi	r28, 0x01	; 1
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
     cf2:	c9 f7       	brne	.-14     	; 0xce6 <xTaskResumeAll+0xaa>

						uxPendedTicks = 0;
     cf4:	10 92 60 01 	sts	0x0160, r1
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
     cf8:	80 91 5f 01 	lds	r24, 0x015F
     cfc:	88 23       	and	r24, r24
     cfe:	09 f4       	brne	.+2      	; 0xd02 <xTaskResumeAll+0xc6>
     d00:	af cf       	rjmp	.-162    	; 0xc60 <xTaskResumeAll+0x24>
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
     d02:	0e 94 74 13 	call	0x26e8	; 0x26e8 <vPortYield>

				if( xYieldPending != pdFALSE )
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
     d06:	81 e0       	ldi	r24, 0x01	; 1
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
     d08:	0f 90       	pop	r0
     d0a:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
     d0c:	df 91       	pop	r29
     d0e:	cf 91       	pop	r28
     d10:	1f 91       	pop	r17
     d12:	0f 91       	pop	r16
     d14:	ff 90       	pop	r15
     d16:	ef 90       	pop	r14
     d18:	08 95       	ret

00000d1a <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
     d1a:	0f 93       	push	r16
     d1c:	1f 93       	push	r17
     d1e:	cf 93       	push	r28
     d20:	df 93       	push	r29
     d22:	8c 01       	movw	r16, r24
     d24:	eb 01       	movw	r28, r22

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
     d26:	0e 94 52 05 	call	0xaa4	; 0xaa4 <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
     d2a:	20 91 63 01 	lds	r18, 0x0163
     d2e:	30 91 64 01 	lds	r19, 0x0164

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
     d32:	f8 01       	movw	r30, r16
     d34:	40 81       	ld	r20, Z
     d36:	51 81       	ldd	r21, Z+1	; 0x01
     d38:	ba 01       	movw	r22, r20
     d3a:	6c 0f       	add	r22, r28
     d3c:	7d 1f       	adc	r23, r29

			if( xConstTickCount < *pxPreviousWakeTime )
     d3e:	24 17       	cp	r18, r20
     d40:	35 07       	cpc	r19, r21
     d42:	28 f4       	brcc	.+10     	; 0xd4e <vTaskDelayUntil+0x34>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
     d44:	64 17       	cp	r22, r20
     d46:	75 07       	cpc	r23, r21
     d48:	48 f4       	brcc	.+18     	; 0xd5c <vTaskDelayUntil+0x42>
     d4a:	91 e0       	ldi	r25, 0x01	; 1
     d4c:	04 c0       	rjmp	.+8      	; 0xd56 <vTaskDelayUntil+0x3c>
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
				{
					xShouldDelay = pdTRUE;
     d4e:	91 e0       	ldi	r25, 0x01	; 1
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
     d50:	64 17       	cp	r22, r20
     d52:	75 07       	cpc	r23, r21
     d54:	20 f0       	brcs	.+8      	; 0xd5e <vTaskDelayUntil+0x44>
     d56:	26 17       	cp	r18, r22
     d58:	37 07       	cpc	r19, r23
     d5a:	08 f0       	brcs	.+2      	; 0xd5e <vTaskDelayUntil+0x44>
#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
     d5c:	90 e0       	ldi	r25, 0x00	; 0
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
     d5e:	f8 01       	movw	r30, r16
     d60:	71 83       	std	Z+1, r23	; 0x01
     d62:	60 83       	st	Z, r22

			if( xShouldDelay != pdFALSE )
     d64:	99 23       	and	r25, r25
     d66:	29 f0       	breq	.+10     	; 0xd72 <vTaskDelayUntil+0x58>
			{
				traceTASK_DELAY_UNTIL( xTimeToWake );

				/* prvAddCurrentTaskToDelayedList() needs the block time, not
				the time to wake, so subtract the current tick count. */
				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
     d68:	cb 01       	movw	r24, r22
     d6a:	82 1b       	sub	r24, r18
     d6c:	93 0b       	sbc	r25, r19
     d6e:	0e 94 63 03 	call	0x6c6	; 0x6c6 <prvAddCurrentTaskToDelayedList.isra.2>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
     d72:	0e 94 1e 06 	call	0xc3c	; 0xc3c <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
     d76:	81 11       	cpse	r24, r1
     d78:	02 c0       	rjmp	.+4      	; 0xd7e <vTaskDelayUntil+0x64>
		{
			portYIELD_WITHIN_API();
     d7a:	0e 94 74 13 	call	0x26e8	; 0x26e8 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     d7e:	df 91       	pop	r29
     d80:	cf 91       	pop	r28
     d82:	1f 91       	pop	r17
     d84:	0f 91       	pop	r16
     d86:	08 95       	ret

00000d88 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
     d88:	cf 93       	push	r28
     d8a:	df 93       	push	r29
     d8c:	00 d0       	rcall	.+0      	; 0xd8e <vTaskDelay+0x6>
     d8e:	cd b7       	in	r28, 0x3d	; 61
     d90:	de b7       	in	r29, 0x3e	; 62
	BaseType_t xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
     d92:	00 97       	sbiw	r24, 0x00	; 0
     d94:	19 f4       	brne	.+6      	; 0xd9c <vTaskDelay+0x14>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
     d96:	0e 94 74 13 	call	0x26e8	; 0x26e8 <vPortYield>
     d9a:	0c c0       	rjmp	.+24     	; 0xdb4 <vTaskDelay+0x2c>

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
     d9c:	89 83       	std	Y+1, r24	; 0x01
     d9e:	9a 83       	std	Y+2, r25	; 0x02
     da0:	0e 94 52 05 	call	0xaa4	; 0xaa4 <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
     da4:	89 81       	ldd	r24, Y+1	; 0x01
     da6:	9a 81       	ldd	r25, Y+2	; 0x02
     da8:	0e 94 63 03 	call	0x6c6	; 0x6c6 <prvAddCurrentTaskToDelayedList.isra.2>
			}
			xAlreadyYielded = xTaskResumeAll();
     dac:	0e 94 1e 06 	call	0xc3c	; 0xc3c <xTaskResumeAll>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
     db0:	88 23       	and	r24, r24
     db2:	89 f3       	breq	.-30     	; 0xd96 <vTaskDelay+0xe>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     db4:	0f 90       	pop	r0
     db6:	0f 90       	pop	r0
     db8:	df 91       	pop	r29
     dba:	cf 91       	pop	r28
     dbc:	08 95       	ret

00000dbe <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
     dbe:	80 91 58 01 	lds	r24, 0x0158
     dc2:	88 23       	and	r24, r24
     dc4:	21 f0       	breq	.+8      	; 0xdce <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
     dc6:	81 e0       	ldi	r24, 0x01	; 1
     dc8:	80 93 5f 01 	sts	0x015F, r24
     dcc:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
     dce:	10 92 5f 01 	sts	0x015F, r1
		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
     dd2:	80 91 62 01 	lds	r24, 0x0162
     dd6:	69 e0       	ldi	r22, 0x09	; 9
     dd8:	48 2f       	mov	r20, r24
     dda:	50 e0       	ldi	r21, 0x00	; 0
     ddc:	64 9f       	mul	r22, r20
     dde:	90 01       	movw	r18, r0
     de0:	65 9f       	mul	r22, r21
     de2:	30 0d       	add	r19, r0
     de4:	11 24       	eor	r1, r1
     de6:	f9 01       	movw	r30, r18
     de8:	e1 57       	subi	r30, 0x71	; 113
     dea:	fe 4f       	sbci	r31, 0xFE	; 254
     dec:	90 81       	ld	r25, Z
     dee:	91 11       	cpse	r25, r1
     df0:	02 c0       	rjmp	.+4      	; 0xdf6 <vTaskSwitchContext+0x38>
     df2:	81 50       	subi	r24, 0x01	; 1
     df4:	f1 cf       	rjmp	.-30     	; 0xdd8 <vTaskSwitchContext+0x1a>
     df6:	a1 81       	ldd	r26, Z+1	; 0x01
     df8:	b2 81       	ldd	r27, Z+2	; 0x02
     dfa:	12 96       	adiw	r26, 0x02	; 2
     dfc:	0d 90       	ld	r0, X+
     dfe:	bc 91       	ld	r27, X
     e00:	a0 2d       	mov	r26, r0
     e02:	b2 83       	std	Z+2, r27	; 0x02
     e04:	a1 83       	std	Z+1, r26	; 0x01
     e06:	2e 56       	subi	r18, 0x6E	; 110
     e08:	3e 4f       	sbci	r19, 0xFE	; 254
     e0a:	a2 17       	cp	r26, r18
     e0c:	b3 07       	cpc	r27, r19
     e0e:	31 f4       	brne	.+12     	; 0xe1c <vTaskSwitchContext+0x5e>
     e10:	12 96       	adiw	r26, 0x02	; 2
     e12:	2d 91       	ld	r18, X+
     e14:	3c 91       	ld	r19, X
     e16:	13 97       	sbiw	r26, 0x03	; 3
     e18:	32 83       	std	Z+2, r19	; 0x02
     e1a:	21 83       	std	Z+1, r18	; 0x01
     e1c:	99 e0       	ldi	r25, 0x09	; 9
     e1e:	94 9f       	mul	r25, r20
     e20:	f0 01       	movw	r30, r0
     e22:	95 9f       	mul	r25, r21
     e24:	f0 0d       	add	r31, r0
     e26:	11 24       	eor	r1, r1
     e28:	e1 57       	subi	r30, 0x71	; 113
     e2a:	fe 4f       	sbci	r31, 0xFE	; 254
     e2c:	01 80       	ldd	r0, Z+1	; 0x01
     e2e:	f2 81       	ldd	r31, Z+2	; 0x02
     e30:	e0 2d       	mov	r30, r0
     e32:	26 81       	ldd	r18, Z+6	; 0x06
     e34:	37 81       	ldd	r19, Z+7	; 0x07
     e36:	30 93 57 01 	sts	0x0157, r19
     e3a:	20 93 56 01 	sts	0x0156, r18
     e3e:	80 93 62 01 	sts	0x0162, r24
     e42:	08 95       	ret

00000e44 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
     e44:	cf 93       	push	r28
     e46:	df 93       	push	r29
     e48:	eb 01       	movw	r28, r22

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
     e4a:	20 91 56 01 	lds	r18, 0x0156
     e4e:	30 91 57 01 	lds	r19, 0x0157
     e52:	b9 01       	movw	r22, r18
     e54:	64 5f       	subi	r22, 0xF4	; 244
     e56:	7f 4f       	sbci	r23, 0xFF	; 255
     e58:	0e 94 74 0f 	call	0x1ee8	; 0x1ee8 <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     e5c:	ce 01       	movw	r24, r28
}
     e5e:	df 91       	pop	r29
     e60:	cf 91       	pop	r28
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     e62:	0c 94 63 03 	jmp	0x6c6	; 0x6c6 <prvAddCurrentTaskToDelayedList.isra.2>

00000e66 <vTaskPlaceOnUnorderedEventList>:
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
     e66:	cf 93       	push	r28
     e68:	df 93       	push	r29
     e6a:	ea 01       	movw	r28, r20
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
     e6c:	e0 91 56 01 	lds	r30, 0x0156
     e70:	f0 91 57 01 	lds	r31, 0x0157
     e74:	70 68       	ori	r23, 0x80	; 128
     e76:	75 87       	std	Z+13, r23	; 0x0d
     e78:	64 87       	std	Z+12, r22	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
     e7a:	60 91 56 01 	lds	r22, 0x0156
     e7e:	70 91 57 01 	lds	r23, 0x0157
     e82:	64 5f       	subi	r22, 0xF4	; 244
     e84:	7f 4f       	sbci	r23, 0xFF	; 255
     e86:	0e 94 53 0f 	call	0x1ea6	; 0x1ea6 <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     e8a:	ce 01       	movw	r24, r28
}
     e8c:	df 91       	pop	r29
     e8e:	cf 91       	pop	r28
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     e90:	0c 94 63 03 	jmp	0x6c6	; 0x6c6 <prvAddCurrentTaskToDelayedList.isra.2>

00000e94 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
     e94:	0f 93       	push	r16
     e96:	1f 93       	push	r17
     e98:	cf 93       	push	r28
     e9a:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
     e9c:	dc 01       	movw	r26, r24
     e9e:	15 96       	adiw	r26, 0x05	; 5
     ea0:	ed 91       	ld	r30, X+
     ea2:	fc 91       	ld	r31, X
     ea4:	16 97       	sbiw	r26, 0x06	; 6
     ea6:	c6 81       	ldd	r28, Z+6	; 0x06
     ea8:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
     eaa:	8e 01       	movw	r16, r28
     eac:	04 5f       	subi	r16, 0xF4	; 244
     eae:	1f 4f       	sbci	r17, 0xFF	; 255
     eb0:	c8 01       	movw	r24, r16
     eb2:	0e 94 ac 0f 	call	0x1f58	; 0x1f58 <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     eb6:	80 91 58 01 	lds	r24, 0x0158
     eba:	81 11       	cpse	r24, r1
     ebc:	14 c0       	rjmp	.+40     	; 0xee6 <xTaskRemoveFromEventList+0x52>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
     ebe:	0a 50       	subi	r16, 0x0A	; 10
     ec0:	11 09       	sbc	r17, r1
     ec2:	c8 01       	movw	r24, r16
     ec4:	0e 94 ac 0f 	call	0x1f58	; 0x1f58 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
     ec8:	9e 89       	ldd	r25, Y+22	; 0x16
     eca:	80 91 62 01 	lds	r24, 0x0162
     ece:	89 17       	cp	r24, r25
     ed0:	10 f4       	brcc	.+4      	; 0xed6 <xTaskRemoveFromEventList+0x42>
     ed2:	90 93 62 01 	sts	0x0162, r25
     ed6:	b9 e0       	ldi	r27, 0x09	; 9
     ed8:	9b 9f       	mul	r25, r27
     eda:	c0 01       	movw	r24, r0
     edc:	11 24       	eor	r1, r1
     ede:	b8 01       	movw	r22, r16
     ee0:	81 57       	subi	r24, 0x71	; 113
     ee2:	9e 4f       	sbci	r25, 0xFE	; 254
     ee4:	03 c0       	rjmp	.+6      	; 0xeec <xTaskRemoveFromEventList+0x58>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
     ee6:	b8 01       	movw	r22, r16
     ee8:	80 e7       	ldi	r24, 0x70	; 112
     eea:	91 e0       	ldi	r25, 0x01	; 1
     eec:	0e 94 53 0f 	call	0x1ea6	; 0x1ea6 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
     ef0:	e0 91 56 01 	lds	r30, 0x0156
     ef4:	f0 91 57 01 	lds	r31, 0x0157
     ef8:	9e 89       	ldd	r25, Y+22	; 0x16
     efa:	86 89       	ldd	r24, Z+22	; 0x16
     efc:	89 17       	cp	r24, r25
     efe:	20 f4       	brcc	.+8      	; 0xf08 <xTaskRemoveFromEventList+0x74>
		it should force a context switch now. */
		xReturn = pdTRUE;

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
     f00:	81 e0       	ldi	r24, 0x01	; 1
     f02:	80 93 5f 01 	sts	0x015F, r24
     f06:	01 c0       	rjmp	.+2      	; 0xf0a <xTaskRemoveFromEventList+0x76>
	}
	else
	{
		xReturn = pdFALSE;
     f08:	80 e0       	ldi	r24, 0x00	; 0
		prvResetNextTaskUnblockTime();
	}
	#endif

	return xReturn;
}
     f0a:	df 91       	pop	r29
     f0c:	cf 91       	pop	r28
     f0e:	1f 91       	pop	r17
     f10:	0f 91       	pop	r16
     f12:	08 95       	ret

00000f14 <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
     f14:	0f 93       	push	r16
     f16:	1f 93       	push	r17
     f18:	cf 93       	push	r28
     f1a:	df 93       	push	r29
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
     f1c:	70 68       	ori	r23, 0x80	; 128
     f1e:	fc 01       	movw	r30, r24
     f20:	71 83       	std	Z+1, r23	; 0x01
     f22:	60 83       	st	Z, r22

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
     f24:	c6 81       	ldd	r28, Z+6	; 0x06
     f26:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
     f28:	0e 94 ac 0f 	call	0x1f58	; 0x1f58 <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
     f2c:	8e 01       	movw	r16, r28
     f2e:	0e 5f       	subi	r16, 0xFE	; 254
     f30:	1f 4f       	sbci	r17, 0xFF	; 255
     f32:	c8 01       	movw	r24, r16
     f34:	0e 94 ac 0f 	call	0x1f58	; 0x1f58 <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
     f38:	9e 89       	ldd	r25, Y+22	; 0x16
     f3a:	80 91 62 01 	lds	r24, 0x0162
     f3e:	89 17       	cp	r24, r25
     f40:	10 f4       	brcc	.+4      	; 0xf46 <vTaskRemoveFromUnorderedEventList+0x32>
     f42:	90 93 62 01 	sts	0x0162, r25
     f46:	f9 e0       	ldi	r31, 0x09	; 9
     f48:	9f 9f       	mul	r25, r31
     f4a:	c0 01       	movw	r24, r0
     f4c:	11 24       	eor	r1, r1
     f4e:	b8 01       	movw	r22, r16
     f50:	81 57       	subi	r24, 0x71	; 113
     f52:	9e 4f       	sbci	r25, 0xFE	; 254
     f54:	0e 94 53 0f 	call	0x1ea6	; 0x1ea6 <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
     f58:	e0 91 56 01 	lds	r30, 0x0156
     f5c:	f0 91 57 01 	lds	r31, 0x0157
     f60:	9e 89       	ldd	r25, Y+22	; 0x16
     f62:	86 89       	ldd	r24, Z+22	; 0x16
     f64:	89 17       	cp	r24, r25
     f66:	18 f4       	brcc	.+6      	; 0xf6e <vTaskRemoveFromUnorderedEventList+0x5a>
	{
		/* The unblocked task has a priority above that of the calling task, so
		a context switch is required.  This function is called with the
		scheduler suspended so xYieldPending is set so the context switch
		occurs immediately that the scheduler is resumed (unsuspended). */
		xYieldPending = pdTRUE;
     f68:	81 e0       	ldi	r24, 0x01	; 1
     f6a:	80 93 5f 01 	sts	0x015F, r24
	}
}
     f6e:	df 91       	pop	r29
     f70:	cf 91       	pop	r28
     f72:	1f 91       	pop	r17
     f74:	0f 91       	pop	r16
     f76:	08 95       	ret

00000f78 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	taskENTER_CRITICAL();
     f78:	0f b6       	in	r0, 0x3f	; 63
     f7a:	f8 94       	cli
     f7c:	0f 92       	push	r0
	{
		pxTimeOut->xOverflowCount = xNumOfOverflows;
     f7e:	20 91 5e 01 	lds	r18, 0x015E
     f82:	fc 01       	movw	r30, r24
     f84:	20 83       	st	Z, r18
		pxTimeOut->xTimeOnEntering = xTickCount;
     f86:	20 91 63 01 	lds	r18, 0x0163
     f8a:	30 91 64 01 	lds	r19, 0x0164
     f8e:	32 83       	std	Z+2, r19	; 0x02
     f90:	21 83       	std	Z+1, r18	; 0x01
	}
	taskEXIT_CRITICAL();
     f92:	0f 90       	pop	r0
     f94:	0f be       	out	0x3f, r0	; 63
     f96:	08 95       	ret

00000f98 <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
     f98:	20 91 5e 01 	lds	r18, 0x015E
     f9c:	fc 01       	movw	r30, r24
     f9e:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
     fa0:	20 91 63 01 	lds	r18, 0x0163
     fa4:	30 91 64 01 	lds	r19, 0x0164
     fa8:	32 83       	std	Z+2, r19	; 0x02
     faa:	21 83       	std	Z+1, r18	; 0x01
     fac:	08 95       	ret

00000fae <xTaskCheckForTimeOut>:
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
     fae:	0f b6       	in	r0, 0x3f	; 63
     fb0:	f8 94       	cli
     fb2:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
     fb4:	20 91 63 01 	lds	r18, 0x0163
     fb8:	30 91 64 01 	lds	r19, 0x0164
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
     fbc:	dc 01       	movw	r26, r24
     fbe:	11 96       	adiw	r26, 0x01	; 1
     fc0:	4d 91       	ld	r20, X+
     fc2:	5c 91       	ld	r21, X
     fc4:	12 97       	sbiw	r26, 0x02	; 2
				xReturn = pdFALSE;
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
     fc6:	f0 91 5e 01 	lds	r31, 0x015E
     fca:	ec 91       	ld	r30, X
     fcc:	fe 17       	cp	r31, r30
     fce:	19 f0       	breq	.+6      	; 0xfd6 <xTaskCheckForTimeOut+0x28>
     fd0:	24 17       	cp	r18, r20
     fd2:	35 07       	cpc	r19, r21
     fd4:	90 f4       	brcc	.+36     	; 0xffa <xTaskCheckForTimeOut+0x4c>

	taskENTER_CRITICAL();
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
     fd6:	24 1b       	sub	r18, r20
     fd8:	35 0b       	sbc	r19, r21
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
     fda:	fb 01       	movw	r30, r22
     fdc:	40 81       	ld	r20, Z
     fde:	51 81       	ldd	r21, Z+1	; 0x01
     fe0:	24 17       	cp	r18, r20
     fe2:	35 07       	cpc	r19, r21
     fe4:	40 f4       	brcc	.+16     	; 0xff6 <xTaskCheckForTimeOut+0x48>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
     fe6:	42 1b       	sub	r20, r18
     fe8:	53 0b       	sbc	r21, r19
     fea:	51 83       	std	Z+1, r21	; 0x01
     fec:	40 83       	st	Z, r20
			vTaskInternalSetTimeOutState( pxTimeOut );
     fee:	0e 94 cc 07 	call	0xf98	; 0xf98 <vTaskInternalSetTimeOutState>
			xReturn = pdFALSE;
     ff2:	80 e0       	ldi	r24, 0x00	; 0
     ff4:	03 c0       	rjmp	.+6      	; 0xffc <xTaskCheckForTimeOut+0x4e>
		}
		else
		{
			*pxTicksToWait = 0;
     ff6:	11 82       	std	Z+1, r1	; 0x01
     ff8:	10 82       	st	Z, r1
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
     ffa:	81 e0       	ldi	r24, 0x01	; 1
		{
			*pxTicksToWait = 0;
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
     ffc:	0f 90       	pop	r0
     ffe:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    1000:	08 95       	ret

00001002 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
    1002:	81 e0       	ldi	r24, 0x01	; 1
    1004:	80 93 5f 01 	sts	0x015F, r24
    1008:	08 95       	ret

0000100a <uxTaskResetEventItemValue>:

TickType_t uxTaskResetEventItemValue( void )
{
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    100a:	e0 91 56 01 	lds	r30, 0x0156
    100e:	f0 91 57 01 	lds	r31, 0x0157
    1012:	84 85       	ldd	r24, Z+12	; 0x0c
    1014:	95 85       	ldd	r25, Z+13	; 0x0d

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1016:	e0 91 56 01 	lds	r30, 0x0156
    101a:	f0 91 57 01 	lds	r31, 0x0157
    101e:	a0 91 56 01 	lds	r26, 0x0156
    1022:	b0 91 57 01 	lds	r27, 0x0157
    1026:	56 96       	adiw	r26, 0x16	; 22
    1028:	4c 91       	ld	r20, X
    102a:	24 e0       	ldi	r18, 0x04	; 4
    102c:	30 e0       	ldi	r19, 0x00	; 0
    102e:	24 1b       	sub	r18, r20
    1030:	31 09       	sbc	r19, r1
    1032:	35 87       	std	Z+13, r19	; 0x0d
    1034:	24 87       	std	Z+12, r18	; 0x0c

	return uxReturn;
}
    1036:	08 95       	ret

00001038 <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
    1038:	0f 93       	push	r16
    103a:	1f 93       	push	r17
    103c:	18 2f       	mov	r17, r24
	uint32_t ulReturn;

		taskENTER_CRITICAL();
    103e:	0f b6       	in	r0, 0x3f	; 63
    1040:	f8 94       	cli
    1042:	0f 92       	push	r0
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
    1044:	e0 91 56 01 	lds	r30, 0x0156
    1048:	f0 91 57 01 	lds	r31, 0x0157
    104c:	81 a1       	ldd	r24, Z+33	; 0x21
    104e:	92 a1       	ldd	r25, Z+34	; 0x22
    1050:	a3 a1       	ldd	r26, Z+35	; 0x23
    1052:	b4 a1       	ldd	r27, Z+36	; 0x24
    1054:	89 2b       	or	r24, r25
    1056:	8a 2b       	or	r24, r26
    1058:	8b 2b       	or	r24, r27
    105a:	71 f4       	brne	.+28     	; 0x1078 <ulTaskNotifyTake+0x40>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    105c:	e0 91 56 01 	lds	r30, 0x0156
    1060:	f0 91 57 01 	lds	r31, 0x0157
    1064:	81 e0       	ldi	r24, 0x01	; 1
    1066:	85 a3       	std	Z+37, r24	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
    1068:	61 15       	cp	r22, r1
    106a:	71 05       	cpc	r23, r1
    106c:	29 f0       	breq	.+10     	; 0x1078 <ulTaskNotifyTake+0x40>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    106e:	cb 01       	movw	r24, r22
    1070:	0e 94 63 03 	call	0x6c6	; 0x6c6 <prvAddCurrentTaskToDelayedList.isra.2>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    1074:	0e 94 74 13 	call	0x26e8	; 0x26e8 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    1078:	0f 90       	pop	r0
    107a:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    107c:	0f b6       	in	r0, 0x3f	; 63
    107e:	f8 94       	cli
    1080:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
    1082:	e0 91 56 01 	lds	r30, 0x0156
    1086:	f0 91 57 01 	lds	r31, 0x0157
    108a:	61 a1       	ldd	r22, Z+33	; 0x21
    108c:	72 a1       	ldd	r23, Z+34	; 0x22
    108e:	83 a1       	ldd	r24, Z+35	; 0x23
    1090:	94 a1       	ldd	r25, Z+36	; 0x24

			if( ulReturn != 0UL )
    1092:	61 15       	cp	r22, r1
    1094:	71 05       	cpc	r23, r1
    1096:	81 05       	cpc	r24, r1
    1098:	91 05       	cpc	r25, r1
    109a:	a9 f0       	breq	.+42     	; 0x10c6 <ulTaskNotifyTake+0x8e>
			{
				if( xClearCountOnExit != pdFALSE )
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
    109c:	e0 91 56 01 	lds	r30, 0x0156
    10a0:	f0 91 57 01 	lds	r31, 0x0157
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;

			if( ulReturn != 0UL )
			{
				if( xClearCountOnExit != pdFALSE )
    10a4:	11 23       	and	r17, r17
    10a6:	29 f0       	breq	.+10     	; 0x10b2 <ulTaskNotifyTake+0x7a>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
    10a8:	11 a2       	std	Z+33, r1	; 0x21
    10aa:	12 a2       	std	Z+34, r1	; 0x22
    10ac:	13 a2       	std	Z+35, r1	; 0x23
    10ae:	14 a2       	std	Z+36, r1	; 0x24
    10b0:	0a c0       	rjmp	.+20     	; 0x10c6 <ulTaskNotifyTake+0x8e>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - ( uint32_t ) 1;
    10b2:	8b 01       	movw	r16, r22
    10b4:	9c 01       	movw	r18, r24
    10b6:	01 50       	subi	r16, 0x01	; 1
    10b8:	11 09       	sbc	r17, r1
    10ba:	21 09       	sbc	r18, r1
    10bc:	31 09       	sbc	r19, r1
    10be:	01 a3       	std	Z+33, r16	; 0x21
    10c0:	12 a3       	std	Z+34, r17	; 0x22
    10c2:	23 a3       	std	Z+35, r18	; 0x23
    10c4:	34 a3       	std	Z+36, r19	; 0x24
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    10c6:	e0 91 56 01 	lds	r30, 0x0156
    10ca:	f0 91 57 01 	lds	r31, 0x0157
    10ce:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
    10d0:	0f 90       	pop	r0
    10d2:	0f be       	out	0x3f, r0	; 63

		return ulReturn;
	}
    10d4:	1f 91       	pop	r17
    10d6:	0f 91       	pop	r16
    10d8:	08 95       	ret

000010da <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
    10da:	4f 92       	push	r4
    10dc:	5f 92       	push	r5
    10de:	6f 92       	push	r6
    10e0:	7f 92       	push	r7
    10e2:	8f 92       	push	r8
    10e4:	9f 92       	push	r9
    10e6:	af 92       	push	r10
    10e8:	bf 92       	push	r11
    10ea:	ef 92       	push	r14
    10ec:	ff 92       	push	r15
    10ee:	0f 93       	push	r16
    10f0:	1f 93       	push	r17
    10f2:	cf 93       	push	r28
    10f4:	df 93       	push	r29
    10f6:	00 d0       	rcall	.+0      	; 0x10f8 <xTaskNotifyWait+0x1e>
    10f8:	00 d0       	rcall	.+0      	; 0x10fa <xTaskNotifyWait+0x20>
    10fa:	cd b7       	in	r28, 0x3d	; 61
    10fc:	de b7       	in	r29, 0x3e	; 62
	BaseType_t xReturn;

		taskENTER_CRITICAL();
    10fe:	0f b6       	in	r0, 0x3f	; 63
    1100:	f8 94       	cli
    1102:	0f 92       	push	r0
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    1104:	e0 91 56 01 	lds	r30, 0x0156
    1108:	f0 91 57 01 	lds	r31, 0x0157
    110c:	e5 a1       	ldd	r30, Z+37	; 0x25
    110e:	e2 30       	cpi	r30, 0x02	; 2
    1110:	71 f1       	breq	.+92     	; 0x116e <xTaskNotifyWait+0x94>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
    1112:	e0 91 56 01 	lds	r30, 0x0156
    1116:	f0 91 57 01 	lds	r31, 0x0157
    111a:	81 a0       	ldd	r8, Z+33	; 0x21
    111c:	92 a0       	ldd	r9, Z+34	; 0x22
    111e:	a3 a0       	ldd	r10, Z+35	; 0x23
    1120:	b4 a0       	ldd	r11, Z+36	; 0x24
    1122:	2b 01       	movw	r4, r22
    1124:	3c 01       	movw	r6, r24
    1126:	40 94       	com	r4
    1128:	50 94       	com	r5
    112a:	60 94       	com	r6
    112c:	70 94       	com	r7
    112e:	d3 01       	movw	r26, r6
    1130:	c2 01       	movw	r24, r4
    1132:	88 21       	and	r24, r8
    1134:	99 21       	and	r25, r9
    1136:	aa 21       	and	r26, r10
    1138:	bb 21       	and	r27, r11
    113a:	81 a3       	std	Z+33, r24	; 0x21
    113c:	92 a3       	std	Z+34, r25	; 0x22
    113e:	a3 a3       	std	Z+35, r26	; 0x23
    1140:	b4 a3       	std	Z+36, r27	; 0x24

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    1142:	e0 91 56 01 	lds	r30, 0x0156
    1146:	f0 91 57 01 	lds	r31, 0x0157
    114a:	81 e0       	ldi	r24, 0x01	; 1
    114c:	85 a3       	std	Z+37, r24	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
    114e:	e1 14       	cp	r14, r1
    1150:	f1 04       	cpc	r15, r1
    1152:	69 f0       	breq	.+26     	; 0x116e <xTaskNotifyWait+0x94>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    1154:	c7 01       	movw	r24, r14
    1156:	29 83       	std	Y+1, r18	; 0x01
    1158:	3a 83       	std	Y+2, r19	; 0x02
    115a:	4b 83       	std	Y+3, r20	; 0x03
    115c:	5c 83       	std	Y+4, r21	; 0x04
    115e:	0e 94 63 03 	call	0x6c6	; 0x6c6 <prvAddCurrentTaskToDelayedList.isra.2>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    1162:	0e 94 74 13 	call	0x26e8	; 0x26e8 <vPortYield>
    1166:	5c 81       	ldd	r21, Y+4	; 0x04
    1168:	4b 81       	ldd	r20, Y+3	; 0x03
    116a:	3a 81       	ldd	r19, Y+2	; 0x02
    116c:	29 81       	ldd	r18, Y+1	; 0x01
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    116e:	0f 90       	pop	r0
    1170:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    1172:	0f b6       	in	r0, 0x3f	; 63
    1174:	f8 94       	cli
    1176:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
    1178:	01 15       	cp	r16, r1
    117a:	11 05       	cpc	r17, r1
    117c:	69 f0       	breq	.+26     	; 0x1198 <xTaskNotifyWait+0xbe>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
    117e:	e0 91 56 01 	lds	r30, 0x0156
    1182:	f0 91 57 01 	lds	r31, 0x0157
    1186:	81 a1       	ldd	r24, Z+33	; 0x21
    1188:	92 a1       	ldd	r25, Z+34	; 0x22
    118a:	a3 a1       	ldd	r26, Z+35	; 0x23
    118c:	b4 a1       	ldd	r27, Z+36	; 0x24
    118e:	f8 01       	movw	r30, r16
    1190:	80 83       	st	Z, r24
    1192:	91 83       	std	Z+1, r25	; 0x01
    1194:	a2 83       	std	Z+2, r26	; 0x02
    1196:	b3 83       	std	Z+3, r27	; 0x03

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    1198:	e0 91 56 01 	lds	r30, 0x0156
    119c:	f0 91 57 01 	lds	r31, 0x0157
    11a0:	85 a1       	ldd	r24, Z+37	; 0x25
    11a2:	82 30       	cpi	r24, 0x02	; 2
    11a4:	c1 f4       	brne	.+48     	; 0x11d6 <xTaskNotifyWait+0xfc>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
    11a6:	e0 91 56 01 	lds	r30, 0x0156
    11aa:	f0 91 57 01 	lds	r31, 0x0157
    11ae:	81 a0       	ldd	r8, Z+33	; 0x21
    11b0:	92 a0       	ldd	r9, Z+34	; 0x22
    11b2:	a3 a0       	ldd	r10, Z+35	; 0x23
    11b4:	b4 a0       	ldd	r11, Z+36	; 0x24
    11b6:	da 01       	movw	r26, r20
    11b8:	c9 01       	movw	r24, r18
    11ba:	80 95       	com	r24
    11bc:	90 95       	com	r25
    11be:	a0 95       	com	r26
    11c0:	b0 95       	com	r27
    11c2:	88 21       	and	r24, r8
    11c4:	99 21       	and	r25, r9
    11c6:	aa 21       	and	r26, r10
    11c8:	bb 21       	and	r27, r11
    11ca:	81 a3       	std	Z+33, r24	; 0x21
    11cc:	92 a3       	std	Z+34, r25	; 0x22
    11ce:	a3 a3       	std	Z+35, r26	; 0x23
    11d0:	b4 a3       	std	Z+36, r27	; 0x24
				xReturn = pdTRUE;
    11d2:	81 e0       	ldi	r24, 0x01	; 1
    11d4:	01 c0       	rjmp	.+2      	; 0x11d8 <xTaskNotifyWait+0xfe>
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
    11d6:	80 e0       	ldi	r24, 0x00	; 0
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
				xReturn = pdTRUE;
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    11d8:	e0 91 56 01 	lds	r30, 0x0156
    11dc:	f0 91 57 01 	lds	r31, 0x0157
    11e0:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
    11e2:	0f 90       	pop	r0
    11e4:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    11e6:	0f 90       	pop	r0
    11e8:	0f 90       	pop	r0
    11ea:	0f 90       	pop	r0
    11ec:	0f 90       	pop	r0
    11ee:	df 91       	pop	r29
    11f0:	cf 91       	pop	r28
    11f2:	1f 91       	pop	r17
    11f4:	0f 91       	pop	r16
    11f6:	ff 90       	pop	r15
    11f8:	ef 90       	pop	r14
    11fa:	bf 90       	pop	r11
    11fc:	af 90       	pop	r10
    11fe:	9f 90       	pop	r9
    1200:	8f 90       	pop	r8
    1202:	7f 90       	pop	r7
    1204:	6f 90       	pop	r6
    1206:	5f 90       	pop	r5
    1208:	4f 90       	pop	r4
    120a:	08 95       	ret

0000120c <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
    120c:	0f 93       	push	r16
    120e:	1f 93       	push	r17
    1210:	cf 93       	push	r28
    1212:	df 93       	push	r29
    1214:	fc 01       	movw	r30, r24
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
		pxTCB = ( TCB_t * ) xTaskToNotify;

		taskENTER_CRITICAL();
    1216:	0f b6       	in	r0, 0x3f	; 63
    1218:	f8 94       	cli
    121a:	0f 92       	push	r0
		{
			if( pulPreviousNotificationValue != NULL )
    121c:	01 15       	cp	r16, r1
    121e:	11 05       	cpc	r17, r1
    1220:	49 f0       	breq	.+18     	; 0x1234 <xTaskGenericNotify+0x28>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    1222:	81 a1       	ldd	r24, Z+33	; 0x21
    1224:	92 a1       	ldd	r25, Z+34	; 0x22
    1226:	a3 a1       	ldd	r26, Z+35	; 0x23
    1228:	b4 a1       	ldd	r27, Z+36	; 0x24
    122a:	e8 01       	movw	r28, r16
    122c:	88 83       	st	Y, r24
    122e:	99 83       	std	Y+1, r25	; 0x01
    1230:	aa 83       	std	Y+2, r26	; 0x02
    1232:	bb 83       	std	Y+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    1234:	35 a1       	ldd	r19, Z+37	; 0x25

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    1236:	82 e0       	ldi	r24, 0x02	; 2
    1238:	85 a3       	std	Z+37, r24	; 0x25

			switch( eAction )
    123a:	22 30       	cpi	r18, 0x02	; 2
    123c:	89 f0       	breq	.+34     	; 0x1260 <xTaskGenericNotify+0x54>
    123e:	58 f4       	brcc	.+22     	; 0x1256 <xTaskGenericNotify+0x4a>
    1240:	21 30       	cpi	r18, 0x01	; 1
    1242:	01 f5       	brne	.+64     	; 0x1284 <xTaskGenericNotify+0x78>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    1244:	81 a1       	ldd	r24, Z+33	; 0x21
    1246:	92 a1       	ldd	r25, Z+34	; 0x22
    1248:	a3 a1       	ldd	r26, Z+35	; 0x23
    124a:	b4 a1       	ldd	r27, Z+36	; 0x24
    124c:	48 2b       	or	r20, r24
    124e:	59 2b       	or	r21, r25
    1250:	6a 2b       	or	r22, r26
    1252:	7b 2b       	or	r23, r27
    1254:	13 c0       	rjmp	.+38     	; 0x127c <xTaskGenericNotify+0x70>

			ucOriginalNotifyState = pxTCB->ucNotifyState;

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;

			switch( eAction )
    1256:	23 30       	cpi	r18, 0x03	; 3
    1258:	89 f0       	breq	.+34     	; 0x127c <xTaskGenericNotify+0x70>
    125a:	24 30       	cpi	r18, 0x04	; 4
    125c:	69 f0       	breq	.+26     	; 0x1278 <xTaskGenericNotify+0x6c>
    125e:	12 c0       	rjmp	.+36     	; 0x1284 <xTaskGenericNotify+0x78>
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    1260:	81 a1       	ldd	r24, Z+33	; 0x21
    1262:	92 a1       	ldd	r25, Z+34	; 0x22
    1264:	a3 a1       	ldd	r26, Z+35	; 0x23
    1266:	b4 a1       	ldd	r27, Z+36	; 0x24
    1268:	01 96       	adiw	r24, 0x01	; 1
    126a:	a1 1d       	adc	r26, r1
    126c:	b1 1d       	adc	r27, r1
    126e:	81 a3       	std	Z+33, r24	; 0x21
    1270:	92 a3       	std	Z+34, r25	; 0x22
    1272:	a3 a3       	std	Z+35, r26	; 0x23
    1274:	b4 a3       	std	Z+36, r27	; 0x24
					break;
    1276:	06 c0       	rjmp	.+12     	; 0x1284 <xTaskGenericNotify+0x78>
				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    1278:	32 30       	cpi	r19, 0x02	; 2
    127a:	49 f1       	breq	.+82     	; 0x12ce <xTaskGenericNotify+0xc2>
					{
						pxTCB->ulNotifiedValue = ulValue;
    127c:	41 a3       	std	Z+33, r20	; 0x21
    127e:	52 a3       	std	Z+34, r21	; 0x22
    1280:	63 a3       	std	Z+35, r22	; 0x23
    1282:	74 a3       	std	Z+36, r23	; 0x24

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    1284:	31 30       	cpi	r19, 0x01	; 1
    1286:	09 f5       	brne	.+66     	; 0x12ca <xTaskGenericNotify+0xbe>
    1288:	ef 01       	movw	r28, r30
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    128a:	8f 01       	movw	r16, r30
    128c:	0e 5f       	subi	r16, 0xFE	; 254
    128e:	1f 4f       	sbci	r17, 0xFF	; 255
    1290:	c8 01       	movw	r24, r16
    1292:	0e 94 ac 0f 	call	0x1f58	; 0x1f58 <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
    1296:	9e 89       	ldd	r25, Y+22	; 0x16
    1298:	80 91 62 01 	lds	r24, 0x0162
    129c:	89 17       	cp	r24, r25
    129e:	10 f4       	brcc	.+4      	; 0x12a4 <xTaskGenericNotify+0x98>
    12a0:	90 93 62 01 	sts	0x0162, r25
    12a4:	29 e0       	ldi	r18, 0x09	; 9
    12a6:	92 9f       	mul	r25, r18
    12a8:	c0 01       	movw	r24, r0
    12aa:	11 24       	eor	r1, r1
    12ac:	b8 01       	movw	r22, r16
    12ae:	81 57       	subi	r24, 0x71	; 113
    12b0:	9e 4f       	sbci	r25, 0xFE	; 254
    12b2:	0e 94 53 0f 	call	0x1ea6	; 0x1ea6 <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    12b6:	e0 91 56 01 	lds	r30, 0x0156
    12ba:	f0 91 57 01 	lds	r31, 0x0157
    12be:	9e 89       	ldd	r25, Y+22	; 0x16
    12c0:	86 89       	ldd	r24, Z+22	; 0x16
    12c2:	89 17       	cp	r24, r25
    12c4:	10 f4       	brcc	.+4      	; 0x12ca <xTaskGenericNotify+0xbe>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
    12c6:	0e 94 74 13 	call	0x26e8	; 0x26e8 <vPortYield>
    12ca:	81 e0       	ldi	r24, 0x01	; 1
    12cc:	01 c0       	rjmp	.+2      	; 0x12d0 <xTaskGenericNotify+0xc4>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    12ce:	80 e0       	ldi	r24, 0x00	; 0
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    12d0:	0f 90       	pop	r0
    12d2:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    12d4:	df 91       	pop	r29
    12d6:	cf 91       	pop	r28
    12d8:	1f 91       	pop	r17
    12da:	0f 91       	pop	r16
    12dc:	08 95       	ret

000012de <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    12de:	ef 92       	push	r14
    12e0:	ff 92       	push	r15
    12e2:	0f 93       	push	r16
    12e4:	1f 93       	push	r17
    12e6:	cf 93       	push	r28
    12e8:	df 93       	push	r29
    12ea:	fc 01       	movw	r30, r24

		pxTCB = ( TCB_t * ) xTaskToNotify;

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			if( pulPreviousNotificationValue != NULL )
    12ec:	01 15       	cp	r16, r1
    12ee:	11 05       	cpc	r17, r1
    12f0:	49 f0       	breq	.+18     	; 0x1304 <xTaskGenericNotifyFromISR+0x26>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    12f2:	81 a1       	ldd	r24, Z+33	; 0x21
    12f4:	92 a1       	ldd	r25, Z+34	; 0x22
    12f6:	a3 a1       	ldd	r26, Z+35	; 0x23
    12f8:	b4 a1       	ldd	r27, Z+36	; 0x24
    12fa:	e8 01       	movw	r28, r16
    12fc:	88 83       	st	Y, r24
    12fe:	99 83       	std	Y+1, r25	; 0x01
    1300:	aa 83       	std	Y+2, r26	; 0x02
    1302:	bb 83       	std	Y+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    1304:	35 a1       	ldd	r19, Z+37	; 0x25
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    1306:	82 e0       	ldi	r24, 0x02	; 2
    1308:	85 a3       	std	Z+37, r24	; 0x25

			switch( eAction )
    130a:	22 30       	cpi	r18, 0x02	; 2
    130c:	89 f0       	breq	.+34     	; 0x1330 <xTaskGenericNotifyFromISR+0x52>
    130e:	58 f4       	brcc	.+22     	; 0x1326 <xTaskGenericNotifyFromISR+0x48>
    1310:	21 30       	cpi	r18, 0x01	; 1
    1312:	01 f5       	brne	.+64     	; 0x1354 <xTaskGenericNotifyFromISR+0x76>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    1314:	81 a1       	ldd	r24, Z+33	; 0x21
    1316:	92 a1       	ldd	r25, Z+34	; 0x22
    1318:	a3 a1       	ldd	r26, Z+35	; 0x23
    131a:	b4 a1       	ldd	r27, Z+36	; 0x24
    131c:	48 2b       	or	r20, r24
    131e:	59 2b       	or	r21, r25
    1320:	6a 2b       	or	r22, r26
    1322:	7b 2b       	or	r23, r27
    1324:	13 c0       	rjmp	.+38     	; 0x134c <xTaskGenericNotifyFromISR+0x6e>
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;

			switch( eAction )
    1326:	23 30       	cpi	r18, 0x03	; 3
    1328:	89 f0       	breq	.+34     	; 0x134c <xTaskGenericNotifyFromISR+0x6e>
    132a:	24 30       	cpi	r18, 0x04	; 4
    132c:	69 f0       	breq	.+26     	; 0x1348 <xTaskGenericNotifyFromISR+0x6a>
    132e:	12 c0       	rjmp	.+36     	; 0x1354 <xTaskGenericNotifyFromISR+0x76>
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    1330:	81 a1       	ldd	r24, Z+33	; 0x21
    1332:	92 a1       	ldd	r25, Z+34	; 0x22
    1334:	a3 a1       	ldd	r26, Z+35	; 0x23
    1336:	b4 a1       	ldd	r27, Z+36	; 0x24
    1338:	01 96       	adiw	r24, 0x01	; 1
    133a:	a1 1d       	adc	r26, r1
    133c:	b1 1d       	adc	r27, r1
    133e:	81 a3       	std	Z+33, r24	; 0x21
    1340:	92 a3       	std	Z+34, r25	; 0x22
    1342:	a3 a3       	std	Z+35, r26	; 0x23
    1344:	b4 a3       	std	Z+36, r27	; 0x24
					break;
    1346:	06 c0       	rjmp	.+12     	; 0x1354 <xTaskGenericNotifyFromISR+0x76>
				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    1348:	32 30       	cpi	r19, 0x02	; 2
    134a:	d9 f1       	breq	.+118    	; 0x13c2 <xTaskGenericNotifyFromISR+0xe4>
					{
						pxTCB->ulNotifiedValue = ulValue;
    134c:	41 a3       	std	Z+33, r20	; 0x21
    134e:	52 a3       	std	Z+34, r21	; 0x22
    1350:	63 a3       	std	Z+35, r22	; 0x23
    1352:	74 a3       	std	Z+36, r23	; 0x24

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    1354:	31 30       	cpi	r19, 0x01	; 1
    1356:	11 f0       	breq	.+4      	; 0x135c <xTaskGenericNotifyFromISR+0x7e>
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    1358:	81 e0       	ldi	r24, 0x01	; 1
    135a:	34 c0       	rjmp	.+104    	; 0x13c4 <xTaskGenericNotifyFromISR+0xe6>
    135c:	ef 01       	movw	r28, r30
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    135e:	80 91 58 01 	lds	r24, 0x0158
    1362:	81 11       	cpse	r24, r1
    1364:	15 c0       	rjmp	.+42     	; 0x1390 <xTaskGenericNotifyFromISR+0xb2>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    1366:	8f 01       	movw	r16, r30
    1368:	0e 5f       	subi	r16, 0xFE	; 254
    136a:	1f 4f       	sbci	r17, 0xFF	; 255
    136c:	c8 01       	movw	r24, r16
    136e:	0e 94 ac 0f 	call	0x1f58	; 0x1f58 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    1372:	2e 89       	ldd	r18, Y+22	; 0x16
    1374:	80 91 62 01 	lds	r24, 0x0162
    1378:	82 17       	cp	r24, r18
    137a:	10 f4       	brcc	.+4      	; 0x1380 <xTaskGenericNotifyFromISR+0xa2>
    137c:	20 93 62 01 	sts	0x0162, r18
    1380:	e9 e0       	ldi	r30, 0x09	; 9
    1382:	2e 9f       	mul	r18, r30
    1384:	c0 01       	movw	r24, r0
    1386:	11 24       	eor	r1, r1
    1388:	b8 01       	movw	r22, r16
    138a:	81 57       	subi	r24, 0x71	; 113
    138c:	9e 4f       	sbci	r25, 0xFE	; 254
    138e:	05 c0       	rjmp	.+10     	; 0x139a <xTaskGenericNotifyFromISR+0xbc>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    1390:	bf 01       	movw	r22, r30
    1392:	64 5f       	subi	r22, 0xF4	; 244
    1394:	7f 4f       	sbci	r23, 0xFF	; 255
    1396:	80 e7       	ldi	r24, 0x70	; 112
    1398:	91 e0       	ldi	r25, 0x01	; 1
    139a:	0e 94 53 0f 	call	0x1ea6	; 0x1ea6 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    139e:	e0 91 56 01 	lds	r30, 0x0156
    13a2:	f0 91 57 01 	lds	r31, 0x0157
    13a6:	9e 89       	ldd	r25, Y+22	; 0x16
    13a8:	86 89       	ldd	r24, Z+22	; 0x16
    13aa:	89 17       	cp	r24, r25
    13ac:	a8 f6       	brcc	.-86     	; 0x1358 <xTaskGenericNotifyFromISR+0x7a>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    13ae:	81 e0       	ldi	r24, 0x01	; 1

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    13b0:	e1 14       	cp	r14, r1
    13b2:	f1 04       	cpc	r15, r1
    13b4:	19 f0       	breq	.+6      	; 0x13bc <xTaskGenericNotifyFromISR+0xde>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    13b6:	e7 01       	movw	r28, r14
    13b8:	88 83       	st	Y, r24
    13ba:	04 c0       	rjmp	.+8      	; 0x13c4 <xTaskGenericNotifyFromISR+0xe6>
					else
					{
						/* Mark that a yield is pending in case the user is not
						using the "xHigherPriorityTaskWoken" parameter to an ISR
						safe FreeRTOS function. */
						xYieldPending = pdTRUE;
    13bc:	80 93 5f 01 	sts	0x015F, r24
    13c0:	01 c0       	rjmp	.+2      	; 0x13c4 <xTaskGenericNotifyFromISR+0xe6>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    13c2:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
	}
    13c4:	df 91       	pop	r29
    13c6:	cf 91       	pop	r28
    13c8:	1f 91       	pop	r17
    13ca:	0f 91       	pop	r16
    13cc:	ff 90       	pop	r15
    13ce:	ef 90       	pop	r14
    13d0:	08 95       	ret

000013d2 <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
    13d2:	ef 92       	push	r14
    13d4:	ff 92       	push	r15
    13d6:	0f 93       	push	r16
    13d8:	1f 93       	push	r17
    13da:	cf 93       	push	r28
    13dc:	df 93       	push	r29
    13de:	fc 01       	movw	r30, r24

		pxTCB = ( TCB_t * ) xTaskToNotify;

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
    13e0:	25 a1       	ldd	r18, Z+37	; 0x25
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    13e2:	82 e0       	ldi	r24, 0x02	; 2
    13e4:	85 a3       	std	Z+37, r24	; 0x25

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
    13e6:	81 a1       	ldd	r24, Z+33	; 0x21
    13e8:	92 a1       	ldd	r25, Z+34	; 0x22
    13ea:	a3 a1       	ldd	r26, Z+35	; 0x23
    13ec:	b4 a1       	ldd	r27, Z+36	; 0x24
    13ee:	01 96       	adiw	r24, 0x01	; 1
    13f0:	a1 1d       	adc	r26, r1
    13f2:	b1 1d       	adc	r27, r1
    13f4:	81 a3       	std	Z+33, r24	; 0x21
    13f6:	92 a3       	std	Z+34, r25	; 0x22
    13f8:	a3 a3       	std	Z+35, r26	; 0x23
    13fa:	b4 a3       	std	Z+36, r27	; 0x24

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    13fc:	21 30       	cpi	r18, 0x01	; 1
    13fe:	a1 f5       	brne	.+104    	; 0x1468 <vTaskNotifyGiveFromISR+0x96>
    1400:	8b 01       	movw	r16, r22
    1402:	ef 01       	movw	r28, r30
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1404:	80 91 58 01 	lds	r24, 0x0158
    1408:	81 11       	cpse	r24, r1
    140a:	16 c0       	rjmp	.+44     	; 0x1438 <vTaskNotifyGiveFromISR+0x66>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    140c:	7f 01       	movw	r14, r30
    140e:	32 e0       	ldi	r19, 0x02	; 2
    1410:	e3 0e       	add	r14, r19
    1412:	f1 1c       	adc	r15, r1
    1414:	c7 01       	movw	r24, r14
    1416:	0e 94 ac 0f 	call	0x1f58	; 0x1f58 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    141a:	2e 89       	ldd	r18, Y+22	; 0x16
    141c:	80 91 62 01 	lds	r24, 0x0162
    1420:	82 17       	cp	r24, r18
    1422:	10 f4       	brcc	.+4      	; 0x1428 <vTaskNotifyGiveFromISR+0x56>
    1424:	20 93 62 01 	sts	0x0162, r18
    1428:	e9 e0       	ldi	r30, 0x09	; 9
    142a:	2e 9f       	mul	r18, r30
    142c:	c0 01       	movw	r24, r0
    142e:	11 24       	eor	r1, r1
    1430:	b7 01       	movw	r22, r14
    1432:	81 57       	subi	r24, 0x71	; 113
    1434:	9e 4f       	sbci	r25, 0xFE	; 254
    1436:	05 c0       	rjmp	.+10     	; 0x1442 <vTaskNotifyGiveFromISR+0x70>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    1438:	bf 01       	movw	r22, r30
    143a:	64 5f       	subi	r22, 0xF4	; 244
    143c:	7f 4f       	sbci	r23, 0xFF	; 255
    143e:	80 e7       	ldi	r24, 0x70	; 112
    1440:	91 e0       	ldi	r25, 0x01	; 1
    1442:	0e 94 53 0f 	call	0x1ea6	; 0x1ea6 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    1446:	e0 91 56 01 	lds	r30, 0x0156
    144a:	f0 91 57 01 	lds	r31, 0x0157
    144e:	9e 89       	ldd	r25, Y+22	; 0x16
    1450:	86 89       	ldd	r24, Z+22	; 0x16
    1452:	89 17       	cp	r24, r25
    1454:	48 f4       	brcc	.+18     	; 0x1468 <vTaskNotifyGiveFromISR+0x96>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    1456:	81 e0       	ldi	r24, 0x01	; 1

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    1458:	01 15       	cp	r16, r1
    145a:	11 05       	cpc	r17, r1
    145c:	19 f0       	breq	.+6      	; 0x1464 <vTaskNotifyGiveFromISR+0x92>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    145e:	f8 01       	movw	r30, r16
    1460:	80 83       	st	Z, r24
    1462:	02 c0       	rjmp	.+4      	; 0x1468 <vTaskNotifyGiveFromISR+0x96>
					else
					{
						/* Mark that a yield is pending in case the user is not
						using the "xHigherPriorityTaskWoken" parameter in an ISR
						safe FreeRTOS function. */
						xYieldPending = pdTRUE;
    1464:	80 93 5f 01 	sts	0x015F, r24
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
    1468:	df 91       	pop	r29
    146a:	cf 91       	pop	r28
    146c:	1f 91       	pop	r17
    146e:	0f 91       	pop	r16
    1470:	ff 90       	pop	r15
    1472:	ef 90       	pop	r14
    1474:	08 95       	ret

00001476 <xTaskNotifyStateClear>:
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
    1476:	00 97       	sbiw	r24, 0x00	; 0
    1478:	21 f4       	brne	.+8      	; 0x1482 <xTaskNotifyStateClear+0xc>
    147a:	80 91 56 01 	lds	r24, 0x0156
    147e:	90 91 57 01 	lds	r25, 0x0157

		taskENTER_CRITICAL();
    1482:	0f b6       	in	r0, 0x3f	; 63
    1484:	f8 94       	cli
    1486:	0f 92       	push	r0
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
    1488:	fc 01       	movw	r30, r24
    148a:	25 a1       	ldd	r18, Z+37	; 0x25
    148c:	22 30       	cpi	r18, 0x02	; 2
    148e:	19 f4       	brne	.+6      	; 0x1496 <xTaskNotifyStateClear+0x20>
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    1490:	15 a2       	std	Z+37, r1	; 0x25
				xReturn = pdPASS;
    1492:	81 e0       	ldi	r24, 0x01	; 1
    1494:	01 c0       	rjmp	.+2      	; 0x1498 <xTaskNotifyStateClear+0x22>
			}
			else
			{
				xReturn = pdFAIL;
    1496:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		taskEXIT_CRITICAL();
    1498:	0f 90       	pop	r0
    149a:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    149c:	08 95       	ret

0000149e <prvIsQueueEmpty>:

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    149e:	0f b6       	in	r0, 0x3f	; 63
    14a0:	f8 94       	cli
    14a2:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    14a4:	fc 01       	movw	r30, r24
    14a6:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    14a8:	0f 90       	pop	r0
    14aa:	0f be       	out	0x3f, r0	; 63
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    14ac:	81 e0       	ldi	r24, 0x01	; 1
    14ae:	91 11       	cpse	r25, r1
    14b0:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	taskEXIT_CRITICAL();

	return xReturn;
}
    14b2:	08 95       	ret

000014b4 <prvCopyDataToQueue>:

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    14b4:	0f 93       	push	r16
    14b6:	1f 93       	push	r17
    14b8:	cf 93       	push	r28
    14ba:	df 93       	push	r29
    14bc:	ec 01       	movw	r28, r24
    14be:	04 2f       	mov	r16, r20
BaseType_t xReturn = pdFALSE;
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    14c0:	1a 8d       	ldd	r17, Y+26	; 0x1a

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    14c2:	8c 8d       	ldd	r24, Y+28	; 0x1c
    14c4:	88 23       	and	r24, r24
    14c6:	b9 f1       	breq	.+110    	; 0x1536 <prvCopyDataToQueue+0x82>
    14c8:	48 2f       	mov	r20, r24
    14ca:	50 e0       	ldi	r21, 0x00	; 0
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    14cc:	01 11       	cpse	r16, r1
    14ce:	15 c0       	rjmp	.+42     	; 0x14fa <prvCopyDataToQueue+0x46>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
    14d0:	8c 81       	ldd	r24, Y+4	; 0x04
    14d2:	9d 81       	ldd	r25, Y+5	; 0x05
    14d4:	0e 94 5f 17 	call	0x2ebe	; 0x2ebe <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    14d8:	2c 8d       	ldd	r18, Y+28	; 0x1c
    14da:	8c 81       	ldd	r24, Y+4	; 0x04
    14dc:	9d 81       	ldd	r25, Y+5	; 0x05
    14de:	82 0f       	add	r24, r18
    14e0:	91 1d       	adc	r25, r1
    14e2:	9d 83       	std	Y+5, r25	; 0x05
    14e4:	8c 83       	std	Y+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    14e6:	2a 81       	ldd	r18, Y+2	; 0x02
    14e8:	3b 81       	ldd	r19, Y+3	; 0x03
    14ea:	82 17       	cp	r24, r18
    14ec:	93 07       	cpc	r25, r19
    14ee:	18 f1       	brcs	.+70     	; 0x1536 <prvCopyDataToQueue+0x82>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    14f0:	88 81       	ld	r24, Y
    14f2:	99 81       	ldd	r25, Y+1	; 0x01
    14f4:	9d 83       	std	Y+5, r25	; 0x05
    14f6:	8c 83       	std	Y+4, r24	; 0x04
    14f8:	1e c0       	rjmp	.+60     	; 0x1536 <prvCopyDataToQueue+0x82>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    14fa:	8e 81       	ldd	r24, Y+6	; 0x06
    14fc:	9f 81       	ldd	r25, Y+7	; 0x07
    14fe:	0e 94 5f 17 	call	0x2ebe	; 0x2ebe <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    1502:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1504:	90 e0       	ldi	r25, 0x00	; 0
    1506:	91 95       	neg	r25
    1508:	81 95       	neg	r24
    150a:	91 09       	sbc	r25, r1
    150c:	2e 81       	ldd	r18, Y+6	; 0x06
    150e:	3f 81       	ldd	r19, Y+7	; 0x07
    1510:	28 0f       	add	r18, r24
    1512:	39 1f       	adc	r19, r25
    1514:	3f 83       	std	Y+7, r19	; 0x07
    1516:	2e 83       	std	Y+6, r18	; 0x06
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    1518:	48 81       	ld	r20, Y
    151a:	59 81       	ldd	r21, Y+1	; 0x01
    151c:	24 17       	cp	r18, r20
    151e:	35 07       	cpc	r19, r21
    1520:	30 f4       	brcc	.+12     	; 0x152e <prvCopyDataToQueue+0x7a>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    1522:	2a 81       	ldd	r18, Y+2	; 0x02
    1524:	3b 81       	ldd	r19, Y+3	; 0x03
    1526:	82 0f       	add	r24, r18
    1528:	93 1f       	adc	r25, r19
    152a:	9f 83       	std	Y+7, r25	; 0x07
    152c:	8e 83       	std	Y+6, r24	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    152e:	02 30       	cpi	r16, 0x02	; 2
    1530:	11 f4       	brne	.+4      	; 0x1536 <prvCopyDataToQueue+0x82>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1532:	11 11       	cpse	r17, r1
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
    1534:	11 50       	subi	r17, 0x01	; 1
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    1536:	1f 5f       	subi	r17, 0xFF	; 255
    1538:	1a 8f       	std	Y+26, r17	; 0x1a

	return xReturn;
}
    153a:	80 e0       	ldi	r24, 0x00	; 0
    153c:	df 91       	pop	r29
    153e:	cf 91       	pop	r28
    1540:	1f 91       	pop	r17
    1542:	0f 91       	pop	r16
    1544:	08 95       	ret

00001546 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    1546:	fc 01       	movw	r30, r24
    1548:	cb 01       	movw	r24, r22
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    154a:	44 8d       	ldd	r20, Z+28	; 0x1c
    154c:	44 23       	and	r20, r20
    154e:	a1 f0       	breq	.+40     	; 0x1578 <prvCopyDataFromQueue+0x32>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    1550:	50 e0       	ldi	r21, 0x00	; 0
    1552:	26 81       	ldd	r18, Z+6	; 0x06
    1554:	37 81       	ldd	r19, Z+7	; 0x07
    1556:	24 0f       	add	r18, r20
    1558:	35 1f       	adc	r19, r21
    155a:	37 83       	std	Z+7, r19	; 0x07
    155c:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    155e:	62 81       	ldd	r22, Z+2	; 0x02
    1560:	73 81       	ldd	r23, Z+3	; 0x03
    1562:	26 17       	cp	r18, r22
    1564:	37 07       	cpc	r19, r23
    1566:	20 f0       	brcs	.+8      	; 0x1570 <prvCopyDataFromQueue+0x2a>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
    1568:	20 81       	ld	r18, Z
    156a:	31 81       	ldd	r19, Z+1	; 0x01
    156c:	37 83       	std	Z+7, r19	; 0x07
    156e:	26 83       	std	Z+6, r18	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
    1570:	66 81       	ldd	r22, Z+6	; 0x06
    1572:	77 81       	ldd	r23, Z+7	; 0x07
    1574:	0c 94 5f 17 	jmp	0x2ebe	; 0x2ebe <memcpy>
    1578:	08 95       	ret

0000157a <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    157a:	ef 92       	push	r14
    157c:	ff 92       	push	r15
    157e:	1f 93       	push	r17
    1580:	cf 93       	push	r28
    1582:	df 93       	push	r29
    1584:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    1586:	0f b6       	in	r0, 0x3f	; 63
    1588:	f8 94       	cli
    158a:	0f 92       	push	r0
	{
		int8_t cTxLock = pxQueue->cTxLock;
    158c:	1e 8d       	ldd	r17, Y+30	; 0x1e
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    158e:	7c 01       	movw	r14, r24
    1590:	81 e1       	ldi	r24, 0x11	; 17
    1592:	e8 0e       	add	r14, r24
    1594:	f1 1c       	adc	r15, r1
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
    1596:	11 16       	cp	r1, r17
    1598:	5c f4       	brge	.+22     	; 0x15b0 <prvUnlockQueue+0x36>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    159a:	89 89       	ldd	r24, Y+17	; 0x11
    159c:	88 23       	and	r24, r24
    159e:	41 f0       	breq	.+16     	; 0x15b0 <prvUnlockQueue+0x36>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    15a0:	c7 01       	movw	r24, r14
    15a2:	0e 94 4a 07 	call	0xe94	; 0xe94 <xTaskRemoveFromEventList>
    15a6:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
    15a8:	0e 94 01 08 	call	0x1002	; 0x1002 <vTaskMissedYield>
    15ac:	11 50       	subi	r17, 0x01	; 1
    15ae:	f3 cf       	rjmp	.-26     	; 0x1596 <prvUnlockQueue+0x1c>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
    15b0:	8f ef       	ldi	r24, 0xFF	; 255
    15b2:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    15b4:	0f 90       	pop	r0
    15b6:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    15b8:	0f b6       	in	r0, 0x3f	; 63
    15ba:	f8 94       	cli
    15bc:	0f 92       	push	r0
	{
		int8_t cRxLock = pxQueue->cRxLock;
    15be:	1d 8d       	ldd	r17, Y+29	; 0x1d

		while( cRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    15c0:	7e 01       	movw	r14, r28
    15c2:	88 e0       	ldi	r24, 0x08	; 8
    15c4:	e8 0e       	add	r14, r24
    15c6:	f1 1c       	adc	r15, r1
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
    15c8:	11 16       	cp	r1, r17
    15ca:	5c f4       	brge	.+22     	; 0x15e2 <prvUnlockQueue+0x68>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    15cc:	88 85       	ldd	r24, Y+8	; 0x08
    15ce:	88 23       	and	r24, r24
    15d0:	41 f0       	breq	.+16     	; 0x15e2 <prvUnlockQueue+0x68>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    15d2:	c7 01       	movw	r24, r14
    15d4:	0e 94 4a 07 	call	0xe94	; 0xe94 <xTaskRemoveFromEventList>
    15d8:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
    15da:	0e 94 01 08 	call	0x1002	; 0x1002 <vTaskMissedYield>
    15de:	11 50       	subi	r17, 0x01	; 1
    15e0:	f3 cf       	rjmp	.-26     	; 0x15c8 <prvUnlockQueue+0x4e>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
    15e2:	8f ef       	ldi	r24, 0xFF	; 255
    15e4:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    15e6:	0f 90       	pop	r0
    15e8:	0f be       	out	0x3f, r0	; 63
}
    15ea:	df 91       	pop	r29
    15ec:	cf 91       	pop	r28
    15ee:	1f 91       	pop	r17
    15f0:	ff 90       	pop	r15
    15f2:	ef 90       	pop	r14
    15f4:	08 95       	ret

000015f6 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    15f6:	cf 93       	push	r28
    15f8:	df 93       	push	r29
    15fa:	ec 01       	movw	r28, r24
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    15fc:	0f b6       	in	r0, 0x3f	; 63
    15fe:	f8 94       	cli
    1600:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    1602:	28 81       	ld	r18, Y
    1604:	39 81       	ldd	r19, Y+1	; 0x01
    1606:	9b 8d       	ldd	r25, Y+27	; 0x1b
    1608:	4c 8d       	ldd	r20, Y+28	; 0x1c
    160a:	94 9f       	mul	r25, r20
    160c:	c0 01       	movw	r24, r0
    160e:	11 24       	eor	r1, r1
    1610:	f9 01       	movw	r30, r18
    1612:	e8 0f       	add	r30, r24
    1614:	f9 1f       	adc	r31, r25
    1616:	fb 83       	std	Y+3, r31	; 0x03
    1618:	ea 83       	std	Y+2, r30	; 0x02
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    161a:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    161c:	3d 83       	std	Y+5, r19	; 0x05
    161e:	2c 83       	std	Y+4, r18	; 0x04
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
    1620:	84 1b       	sub	r24, r20
    1622:	91 09       	sbc	r25, r1
    1624:	82 0f       	add	r24, r18
    1626:	93 1f       	adc	r25, r19
    1628:	9f 83       	std	Y+7, r25	; 0x07
    162a:	8e 83       	std	Y+6, r24	; 0x06
		pxQueue->cRxLock = queueUNLOCKED;
    162c:	8f ef       	ldi	r24, 0xFF	; 255
    162e:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->cTxLock = queueUNLOCKED;
    1630:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    1632:	61 11       	cpse	r22, r1
    1634:	0c c0       	rjmp	.+24     	; 0x164e <xQueueGenericReset+0x58>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1636:	88 85       	ldd	r24, Y+8	; 0x08
    1638:	88 23       	and	r24, r24
    163a:	89 f0       	breq	.+34     	; 0x165e <xQueueGenericReset+0x68>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    163c:	ce 01       	movw	r24, r28
    163e:	08 96       	adiw	r24, 0x08	; 8
    1640:	0e 94 4a 07 	call	0xe94	; 0xe94 <xTaskRemoveFromEventList>
    1644:	88 23       	and	r24, r24
    1646:	59 f0       	breq	.+22     	; 0x165e <xQueueGenericReset+0x68>
				{
					queueYIELD_IF_USING_PREEMPTION();
    1648:	0e 94 74 13 	call	0x26e8	; 0x26e8 <vPortYield>
    164c:	08 c0       	rjmp	.+16     	; 0x165e <xQueueGenericReset+0x68>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    164e:	ce 01       	movw	r24, r28
    1650:	08 96       	adiw	r24, 0x08	; 8
    1652:	0e 94 41 0f 	call	0x1e82	; 0x1e82 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    1656:	ce 01       	movw	r24, r28
    1658:	41 96       	adiw	r24, 0x11	; 17
    165a:	0e 94 41 0f 	call	0x1e82	; 0x1e82 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    165e:	0f 90       	pop	r0
    1660:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
    1662:	81 e0       	ldi	r24, 0x01	; 1
    1664:	df 91       	pop	r29
    1666:	cf 91       	pop	r28
    1668:	08 95       	ret

0000166a <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
    166a:	ef 92       	push	r14
    166c:	ff 92       	push	r15
    166e:	1f 93       	push	r17
    1670:	cf 93       	push	r28
    1672:	df 93       	push	r29
    1674:	1f 92       	push	r1
    1676:	cd b7       	in	r28, 0x3d	; 61
    1678:	de b7       	in	r29, 0x3e	; 62
    167a:	18 2f       	mov	r17, r24
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
    167c:	66 23       	and	r22, r22
    167e:	21 f0       	breq	.+8      	; 0x1688 <xQueueGenericCreate+0x1e>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1680:	86 9f       	mul	r24, r22
    1682:	c0 01       	movw	r24, r0
    1684:	11 24       	eor	r1, r1
    1686:	02 c0       	rjmp	.+4      	; 0x168c <xQueueGenericCreate+0x22>
		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
		{
			/* There is not going to be a queue storage area. */
			xQueueSizeInBytes = ( size_t ) 0;
    1688:	80 e0       	ldi	r24, 0x00	; 0
    168a:	90 e0       	ldi	r25, 0x00	; 0
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
		}

		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
    168c:	4f 96       	adiw	r24, 0x1f	; 31
    168e:	69 83       	std	Y+1, r22	; 0x01
    1690:	0e 94 da 11 	call	0x23b4	; 0x23b4 <pvPortMalloc>
    1694:	7c 01       	movw	r14, r24

		if( pxNewQueue != NULL )
    1696:	69 81       	ldd	r22, Y+1	; 0x01
    1698:	00 97       	sbiw	r24, 0x00	; 0
    169a:	89 f0       	breq	.+34     	; 0x16be <xQueueGenericCreate+0x54>
{
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
    169c:	61 11       	cpse	r22, r1
    169e:	04 c0       	rjmp	.+8      	; 0x16a8 <xQueueGenericCreate+0x3e>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    16a0:	fc 01       	movw	r30, r24
    16a2:	91 83       	std	Z+1, r25	; 0x01
    16a4:	80 83       	st	Z, r24
    16a6:	04 c0       	rjmp	.+8      	; 0x16b0 <xQueueGenericCreate+0x46>

		if( pxNewQueue != NULL )
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pucQueueStorage = ( ( uint8_t * ) pxNewQueue ) + sizeof( Queue_t );
    16a8:	4f 96       	adiw	r24, 0x1f	; 31
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    16aa:	f7 01       	movw	r30, r14
    16ac:	91 83       	std	Z+1, r25	; 0x01
    16ae:	80 83       	st	Z, r24
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
    16b0:	f7 01       	movw	r30, r14
    16b2:	13 8f       	std	Z+27, r17	; 0x1b
	pxNewQueue->uxItemSize = uxItemSize;
    16b4:	64 8f       	std	Z+28, r22	; 0x1c
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    16b6:	61 e0       	ldi	r22, 0x01	; 1
    16b8:	c7 01       	movw	r24, r14
    16ba:	0e 94 fb 0a 	call	0x15f6	; 0x15f6 <xQueueGenericReset>
		{
			traceQUEUE_CREATE_FAILED( ucQueueType );
		}

		return pxNewQueue;
	}
    16be:	c7 01       	movw	r24, r14
    16c0:	0f 90       	pop	r0
    16c2:	df 91       	pop	r29
    16c4:	cf 91       	pop	r28
    16c6:	1f 91       	pop	r17
    16c8:	ff 90       	pop	r15
    16ca:	ef 90       	pop	r14
    16cc:	08 95       	ret

000016ce <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    16ce:	af 92       	push	r10
    16d0:	bf 92       	push	r11
    16d2:	cf 92       	push	r12
    16d4:	df 92       	push	r13
    16d6:	ff 92       	push	r15
    16d8:	0f 93       	push	r16
    16da:	1f 93       	push	r17
    16dc:	cf 93       	push	r28
    16de:	df 93       	push	r29
    16e0:	00 d0       	rcall	.+0      	; 0x16e2 <xQueueGenericSend+0x14>
    16e2:	00 d0       	rcall	.+0      	; 0x16e4 <xQueueGenericSend+0x16>
    16e4:	1f 92       	push	r1
    16e6:	cd b7       	in	r28, 0x3d	; 61
    16e8:	de b7       	in	r29, 0x3e	; 62
    16ea:	8c 01       	movw	r16, r24
    16ec:	6b 01       	movw	r12, r22
    16ee:	5d 83       	std	Y+5, r21	; 0x05
    16f0:	4c 83       	std	Y+4, r20	; 0x04
    16f2:	f2 2e       	mov	r15, r18
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    16f4:	90 e0       	ldi	r25, 0x00	; 0
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    16f6:	58 01       	movw	r10, r16
    16f8:	88 e0       	ldi	r24, 0x08	; 8
    16fa:	a8 0e       	add	r10, r24
    16fc:	b1 1c       	adc	r11, r1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    16fe:	0f b6       	in	r0, 0x3f	; 63
    1700:	f8 94       	cli
    1702:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1704:	f8 01       	movw	r30, r16
    1706:	22 8d       	ldd	r18, Z+26	; 0x1a
    1708:	83 8d       	ldd	r24, Z+27	; 0x1b
    170a:	28 17       	cp	r18, r24
    170c:	18 f0       	brcs	.+6      	; 0x1714 <xQueueGenericSend+0x46>
    170e:	f2 e0       	ldi	r31, 0x02	; 2
    1710:	ff 12       	cpse	r15, r31
    1712:	14 c0       	rjmp	.+40     	; 0x173c <xQueueGenericSend+0x6e>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1714:	4f 2d       	mov	r20, r15
    1716:	b6 01       	movw	r22, r12
    1718:	c8 01       	movw	r24, r16
    171a:	0e 94 5a 0a 	call	0x14b4	; 0x14b4 <prvCopyDataToQueue>
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    171e:	f8 01       	movw	r30, r16
    1720:	91 89       	ldd	r25, Z+17	; 0x11
    1722:	99 23       	and	r25, r25
    1724:	21 f0       	breq	.+8      	; 0x172e <xQueueGenericSend+0x60>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1726:	c8 01       	movw	r24, r16
    1728:	41 96       	adiw	r24, 0x11	; 17
    172a:	0e 94 4a 07 	call	0xe94	; 0xe94 <xTaskRemoveFromEventList>
    172e:	81 11       	cpse	r24, r1
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    1730:	0e 94 74 13 	call	0x26e8	; 0x26e8 <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    1734:	0f 90       	pop	r0
    1736:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1738:	81 e0       	ldi	r24, 0x01	; 1
    173a:	50 c0       	rjmp	.+160    	; 0x17dc <xQueueGenericSend+0x10e>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    173c:	2c 81       	ldd	r18, Y+4	; 0x04
    173e:	3d 81       	ldd	r19, Y+5	; 0x05
    1740:	23 2b       	or	r18, r19
    1742:	19 f4       	brne	.+6      	; 0x174a <xQueueGenericSend+0x7c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1744:	0f 90       	pop	r0
    1746:	0f be       	out	0x3f, r0	; 63
    1748:	48 c0       	rjmp	.+144    	; 0x17da <xQueueGenericSend+0x10c>
					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
				}
				else if( xEntryTimeSet == pdFALSE )
    174a:	91 11       	cpse	r25, r1
    174c:	04 c0       	rjmp	.+8      	; 0x1756 <xQueueGenericSend+0x88>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    174e:	ce 01       	movw	r24, r28
    1750:	01 96       	adiw	r24, 0x01	; 1
    1752:	0e 94 cc 07 	call	0xf98	; 0xf98 <vTaskInternalSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1756:	0f 90       	pop	r0
    1758:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    175a:	0e 94 52 05 	call	0xaa4	; 0xaa4 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    175e:	0f b6       	in	r0, 0x3f	; 63
    1760:	f8 94       	cli
    1762:	0f 92       	push	r0
    1764:	f8 01       	movw	r30, r16
    1766:	85 8d       	ldd	r24, Z+29	; 0x1d
    1768:	8f 3f       	cpi	r24, 0xFF	; 255
    176a:	09 f4       	brne	.+2      	; 0x176e <xQueueGenericSend+0xa0>
    176c:	15 8e       	std	Z+29, r1	; 0x1d
    176e:	f8 01       	movw	r30, r16
    1770:	86 8d       	ldd	r24, Z+30	; 0x1e
    1772:	8f 3f       	cpi	r24, 0xFF	; 255
    1774:	09 f4       	brne	.+2      	; 0x1778 <xQueueGenericSend+0xaa>
    1776:	16 8e       	std	Z+30, r1	; 0x1e
    1778:	0f 90       	pop	r0
    177a:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    177c:	be 01       	movw	r22, r28
    177e:	6c 5f       	subi	r22, 0xFC	; 252
    1780:	7f 4f       	sbci	r23, 0xFF	; 255
    1782:	ce 01       	movw	r24, r28
    1784:	01 96       	adiw	r24, 0x01	; 1
    1786:	0e 94 d7 07 	call	0xfae	; 0xfae <xTaskCheckForTimeOut>
    178a:	81 11       	cpse	r24, r1
    178c:	21 c0       	rjmp	.+66     	; 0x17d0 <xQueueGenericSend+0x102>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    178e:	0f b6       	in	r0, 0x3f	; 63
    1790:	f8 94       	cli
    1792:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    1794:	f8 01       	movw	r30, r16
    1796:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1798:	0f 90       	pop	r0
    179a:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    179c:	83 8d       	ldd	r24, Z+27	; 0x1b
    179e:	98 13       	cpse	r25, r24
    17a0:	11 c0       	rjmp	.+34     	; 0x17c4 <xQueueGenericSend+0xf6>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    17a2:	6c 81       	ldd	r22, Y+4	; 0x04
    17a4:	7d 81       	ldd	r23, Y+5	; 0x05
    17a6:	c5 01       	movw	r24, r10
    17a8:	0e 94 22 07 	call	0xe44	; 0xe44 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible that interrupts occurring now
				remove this task from the event list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    17ac:	c8 01       	movw	r24, r16
    17ae:	0e 94 bd 0a 	call	0x157a	; 0x157a <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    17b2:	0e 94 1e 06 	call	0xc3c	; 0xc3c <xTaskResumeAll>
    17b6:	88 23       	and	r24, r24
    17b8:	11 f0       	breq	.+4      	; 0x17be <xQueueGenericSend+0xf0>
    17ba:	91 e0       	ldi	r25, 0x01	; 1
    17bc:	a0 cf       	rjmp	.-192    	; 0x16fe <xQueueGenericSend+0x30>
				{
					portYIELD_WITHIN_API();
    17be:	0e 94 74 13 	call	0x26e8	; 0x26e8 <vPortYield>
    17c2:	fb cf       	rjmp	.-10     	; 0x17ba <xQueueGenericSend+0xec>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    17c4:	c8 01       	movw	r24, r16
    17c6:	0e 94 bd 0a 	call	0x157a	; 0x157a <prvUnlockQueue>
				( void ) xTaskResumeAll();
    17ca:	0e 94 1e 06 	call	0xc3c	; 0xc3c <xTaskResumeAll>
    17ce:	f5 cf       	rjmp	.-22     	; 0x17ba <xQueueGenericSend+0xec>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    17d0:	c8 01       	movw	r24, r16
    17d2:	0e 94 bd 0a 	call	0x157a	; 0x157a <prvUnlockQueue>
			( void ) xTaskResumeAll();
    17d6:	0e 94 1e 06 	call	0xc3c	; 0xc3c <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    17da:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    17dc:	0f 90       	pop	r0
    17de:	0f 90       	pop	r0
    17e0:	0f 90       	pop	r0
    17e2:	0f 90       	pop	r0
    17e4:	0f 90       	pop	r0
    17e6:	df 91       	pop	r29
    17e8:	cf 91       	pop	r28
    17ea:	1f 91       	pop	r17
    17ec:	0f 91       	pop	r16
    17ee:	ff 90       	pop	r15
    17f0:	df 90       	pop	r13
    17f2:	cf 90       	pop	r12
    17f4:	bf 90       	pop	r11
    17f6:	af 90       	pop	r10
    17f8:	08 95       	ret

000017fa <xQueueGenericSendFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    17fa:	ef 92       	push	r14
    17fc:	ff 92       	push	r15
    17fe:	1f 93       	push	r17
    1800:	cf 93       	push	r28
    1802:	df 93       	push	r29
    1804:	ec 01       	movw	r28, r24
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1806:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1808:	8b 8d       	ldd	r24, Y+27	; 0x1b
    180a:	98 17       	cp	r25, r24
    180c:	10 f0       	brcs	.+4      	; 0x1812 <xQueueGenericSendFromISR+0x18>
    180e:	22 30       	cpi	r18, 0x02	; 2
    1810:	e1 f4       	brne	.+56     	; 0x184a <xQueueGenericSendFromISR+0x50>
    1812:	7a 01       	movw	r14, r20
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    1814:	1e 8d       	ldd	r17, Y+30	; 0x1e
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1816:	42 2f       	mov	r20, r18
    1818:	ce 01       	movw	r24, r28
    181a:	0e 94 5a 0a 	call	0x14b4	; 0x14b4 <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    181e:	1f 3f       	cpi	r17, 0xFF	; 255
    1820:	81 f4       	brne	.+32     	; 0x1842 <xQueueGenericSendFromISR+0x48>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1822:	89 89       	ldd	r24, Y+17	; 0x11
    1824:	88 23       	and	r24, r24
    1826:	79 f0       	breq	.+30     	; 0x1846 <xQueueGenericSendFromISR+0x4c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1828:	ce 01       	movw	r24, r28
    182a:	41 96       	adiw	r24, 0x11	; 17
    182c:	0e 94 4a 07 	call	0xe94	; 0xe94 <xTaskRemoveFromEventList>
    1830:	88 23       	and	r24, r24
    1832:	49 f0       	breq	.+18     	; 0x1846 <xQueueGenericSendFromISR+0x4c>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    1834:	e1 14       	cp	r14, r1
    1836:	f1 04       	cpc	r15, r1
    1838:	31 f0       	breq	.+12     	; 0x1846 <xQueueGenericSendFromISR+0x4c>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    183a:	81 e0       	ldi	r24, 0x01	; 1
    183c:	f7 01       	movw	r30, r14
    183e:	80 83       	st	Z, r24
    1840:	05 c0       	rjmp	.+10     	; 0x184c <xQueueGenericSendFromISR+0x52>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    1842:	1f 5f       	subi	r17, 0xFF	; 255
    1844:	1e 8f       	std	Y+30, r17	; 0x1e
			}

			xReturn = pdPASS;
    1846:	81 e0       	ldi	r24, 0x01	; 1
    1848:	01 c0       	rjmp	.+2      	; 0x184c <xQueueGenericSendFromISR+0x52>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    184a:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    184c:	df 91       	pop	r29
    184e:	cf 91       	pop	r28
    1850:	1f 91       	pop	r17
    1852:	ff 90       	pop	r15
    1854:	ef 90       	pop	r14
    1856:	08 95       	ret

00001858 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    1858:	cf 93       	push	r28
    185a:	df 93       	push	r29
    185c:	fc 01       	movw	r30, r24
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    185e:	92 8d       	ldd	r25, Z+26	; 0x1a

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
    1860:	83 8d       	ldd	r24, Z+27	; 0x1b
    1862:	98 17       	cp	r25, r24
    1864:	c0 f4       	brcc	.+48     	; 0x1896 <xQueueGiveFromISR+0x3e>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    1866:	86 8d       	ldd	r24, Z+30	; 0x1e
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    1868:	9f 5f       	subi	r25, 0xFF	; 255
    186a:	92 8f       	std	Z+26, r25	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    186c:	8f 3f       	cpi	r24, 0xFF	; 255
    186e:	79 f4       	brne	.+30     	; 0x188e <xQueueGiveFromISR+0x36>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1870:	81 89       	ldd	r24, Z+17	; 0x11
    1872:	88 23       	and	r24, r24
    1874:	71 f0       	breq	.+28     	; 0x1892 <xQueueGiveFromISR+0x3a>
    1876:	eb 01       	movw	r28, r22
    1878:	cf 01       	movw	r24, r30
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    187a:	41 96       	adiw	r24, 0x11	; 17
    187c:	0e 94 4a 07 	call	0xe94	; 0xe94 <xTaskRemoveFromEventList>
    1880:	88 23       	and	r24, r24
    1882:	39 f0       	breq	.+14     	; 0x1892 <xQueueGiveFromISR+0x3a>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    1884:	20 97       	sbiw	r28, 0x00	; 0
    1886:	29 f0       	breq	.+10     	; 0x1892 <xQueueGiveFromISR+0x3a>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    1888:	81 e0       	ldi	r24, 0x01	; 1
    188a:	88 83       	st	Y, r24
    188c:	05 c0       	rjmp	.+10     	; 0x1898 <xQueueGiveFromISR+0x40>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    188e:	8f 5f       	subi	r24, 0xFF	; 255
    1890:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    1892:	81 e0       	ldi	r24, 0x01	; 1
    1894:	01 c0       	rjmp	.+2      	; 0x1898 <xQueueGiveFromISR+0x40>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1896:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1898:	df 91       	pop	r29
    189a:	cf 91       	pop	r28
    189c:	08 95       	ret

0000189e <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    189e:	af 92       	push	r10
    18a0:	bf 92       	push	r11
    18a2:	cf 92       	push	r12
    18a4:	df 92       	push	r13
    18a6:	ff 92       	push	r15
    18a8:	0f 93       	push	r16
    18aa:	1f 93       	push	r17
    18ac:	cf 93       	push	r28
    18ae:	df 93       	push	r29
    18b0:	00 d0       	rcall	.+0      	; 0x18b2 <xQueueReceive+0x14>
    18b2:	00 d0       	rcall	.+0      	; 0x18b4 <xQueueReceive+0x16>
    18b4:	1f 92       	push	r1
    18b6:	cd b7       	in	r28, 0x3d	; 61
    18b8:	de b7       	in	r29, 0x3e	; 62
    18ba:	8c 01       	movw	r16, r24
    18bc:	6b 01       	movw	r12, r22
    18be:	5d 83       	std	Y+5, r21	; 0x05
    18c0:	4c 83       	std	Y+4, r20	; 0x04
BaseType_t xEntryTimeSet = pdFALSE;
    18c2:	90 e0       	ldi	r25, 0x00	; 0
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    18c4:	58 01       	movw	r10, r16
    18c6:	81 e1       	ldi	r24, 0x11	; 17
    18c8:	a8 0e       	add	r10, r24
    18ca:	b1 1c       	adc	r11, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    18cc:	0f b6       	in	r0, 0x3f	; 63
    18ce:	f8 94       	cli
    18d0:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    18d2:	f8 01       	movw	r30, r16
    18d4:	f2 8c       	ldd	r15, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    18d6:	ff 20       	and	r15, r15
    18d8:	a9 f0       	breq	.+42     	; 0x1904 <xQueueReceive+0x66>
			{
				/* Data available, remove one item. */
				prvCopyDataFromQueue( pxQueue, pvBuffer );
    18da:	b6 01       	movw	r22, r12
    18dc:	c8 01       	movw	r24, r16
    18de:	0e 94 a3 0a 	call	0x1546	; 0x1546 <prvCopyDataFromQueue>
				traceQUEUE_RECEIVE( pxQueue );
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    18e2:	fa 94       	dec	r15
    18e4:	f8 01       	movw	r30, r16
    18e6:	f2 8e       	std	Z+26, r15	; 0x1a

				/* There is now space in the queue, were any tasks waiting to
				post to the queue?  If so, unblock the highest priority waiting
				task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    18e8:	80 85       	ldd	r24, Z+8	; 0x08
    18ea:	88 23       	and	r24, r24
    18ec:	39 f0       	breq	.+14     	; 0x18fc <xQueueReceive+0x5e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    18ee:	c8 01       	movw	r24, r16
    18f0:	08 96       	adiw	r24, 0x08	; 8
    18f2:	0e 94 4a 07 	call	0xe94	; 0xe94 <xTaskRemoveFromEventList>
    18f6:	81 11       	cpse	r24, r1
					{
						queueYIELD_IF_USING_PREEMPTION();
    18f8:	0e 94 74 13 	call	0x26e8	; 0x26e8 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    18fc:	0f 90       	pop	r0
    18fe:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1900:	81 e0       	ldi	r24, 0x01	; 1
    1902:	50 c0       	rjmp	.+160    	; 0x19a4 <xQueueReceive+0x106>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1904:	2c 81       	ldd	r18, Y+4	; 0x04
    1906:	3d 81       	ldd	r19, Y+5	; 0x05
    1908:	23 2b       	or	r18, r19
    190a:	19 f4       	brne	.+6      	; 0x1912 <xQueueReceive+0x74>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    190c:	0f 90       	pop	r0
    190e:	0f be       	out	0x3f, r0	; 63
    1910:	48 c0       	rjmp	.+144    	; 0x19a2 <xQueueReceive+0x104>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
    1912:	91 11       	cpse	r25, r1
    1914:	04 c0       	rjmp	.+8      	; 0x191e <xQueueReceive+0x80>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    1916:	ce 01       	movw	r24, r28
    1918:	01 96       	adiw	r24, 0x01	; 1
    191a:	0e 94 cc 07 	call	0xf98	; 0xf98 <vTaskInternalSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    191e:	0f 90       	pop	r0
    1920:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1922:	0e 94 52 05 	call	0xaa4	; 0xaa4 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1926:	0f b6       	in	r0, 0x3f	; 63
    1928:	f8 94       	cli
    192a:	0f 92       	push	r0
    192c:	f8 01       	movw	r30, r16
    192e:	85 8d       	ldd	r24, Z+29	; 0x1d
    1930:	8f 3f       	cpi	r24, 0xFF	; 255
    1932:	09 f4       	brne	.+2      	; 0x1936 <xQueueReceive+0x98>
    1934:	15 8e       	std	Z+29, r1	; 0x1d
    1936:	f8 01       	movw	r30, r16
    1938:	86 8d       	ldd	r24, Z+30	; 0x1e
    193a:	8f 3f       	cpi	r24, 0xFF	; 255
    193c:	09 f4       	brne	.+2      	; 0x1940 <xQueueReceive+0xa2>
    193e:	16 8e       	std	Z+30, r1	; 0x1e
    1940:	0f 90       	pop	r0
    1942:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1944:	be 01       	movw	r22, r28
    1946:	6c 5f       	subi	r22, 0xFC	; 252
    1948:	7f 4f       	sbci	r23, 0xFF	; 255
    194a:	ce 01       	movw	r24, r28
    194c:	01 96       	adiw	r24, 0x01	; 1
    194e:	0e 94 d7 07 	call	0xfae	; 0xfae <xTaskCheckForTimeOut>
    1952:	81 11       	cpse	r24, r1
    1954:	1c c0       	rjmp	.+56     	; 0x198e <xQueueReceive+0xf0>
		{
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1956:	c8 01       	movw	r24, r16
    1958:	0e 94 4f 0a 	call	0x149e	; 0x149e <prvIsQueueEmpty>
    195c:	88 23       	and	r24, r24
    195e:	89 f0       	breq	.+34     	; 0x1982 <xQueueReceive+0xe4>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1960:	6c 81       	ldd	r22, Y+4	; 0x04
    1962:	7d 81       	ldd	r23, Y+5	; 0x05
    1964:	c5 01       	movw	r24, r10
    1966:	0e 94 22 07 	call	0xe44	; 0xe44 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    196a:	c8 01       	movw	r24, r16
    196c:	0e 94 bd 0a 	call	0x157a	; 0x157a <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1970:	0e 94 1e 06 	call	0xc3c	; 0xc3c <xTaskResumeAll>
    1974:	88 23       	and	r24, r24
    1976:	11 f0       	breq	.+4      	; 0x197c <xQueueReceive+0xde>
    1978:	91 e0       	ldi	r25, 0x01	; 1
    197a:	a8 cf       	rjmp	.-176    	; 0x18cc <xQueueReceive+0x2e>
				{
					portYIELD_WITHIN_API();
    197c:	0e 94 74 13 	call	0x26e8	; 0x26e8 <vPortYield>
    1980:	fb cf       	rjmp	.-10     	; 0x1978 <xQueueReceive+0xda>
			}
			else
			{
				/* The queue contains data again.  Loop back to try and read the
				data. */
				prvUnlockQueue( pxQueue );
    1982:	c8 01       	movw	r24, r16
    1984:	0e 94 bd 0a 	call	0x157a	; 0x157a <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1988:	0e 94 1e 06 	call	0xc3c	; 0xc3c <xTaskResumeAll>
    198c:	f5 cf       	rjmp	.-22     	; 0x1978 <xQueueReceive+0xda>
		}
		else
		{
			/* Timed out.  If there is no data in the queue exit, otherwise loop
			back and attempt to read the data. */
			prvUnlockQueue( pxQueue );
    198e:	c8 01       	movw	r24, r16
    1990:	0e 94 bd 0a 	call	0x157a	; 0x157a <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1994:	0e 94 1e 06 	call	0xc3c	; 0xc3c <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1998:	c8 01       	movw	r24, r16
    199a:	0e 94 4f 0a 	call	0x149e	; 0x149e <prvIsQueueEmpty>
    199e:	88 23       	and	r24, r24
    19a0:	59 f3       	breq	.-42     	; 0x1978 <xQueueReceive+0xda>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    19a2:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
}
    19a4:	0f 90       	pop	r0
    19a6:	0f 90       	pop	r0
    19a8:	0f 90       	pop	r0
    19aa:	0f 90       	pop	r0
    19ac:	0f 90       	pop	r0
    19ae:	df 91       	pop	r29
    19b0:	cf 91       	pop	r28
    19b2:	1f 91       	pop	r17
    19b4:	0f 91       	pop	r16
    19b6:	ff 90       	pop	r15
    19b8:	df 90       	pop	r13
    19ba:	cf 90       	pop	r12
    19bc:	bf 90       	pop	r11
    19be:	af 90       	pop	r10
    19c0:	08 95       	ret

000019c2 <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
{
    19c2:	ef 92       	push	r14
    19c4:	ff 92       	push	r15
    19c6:	0f 93       	push	r16
    19c8:	1f 93       	push	r17
    19ca:	cf 93       	push	r28
    19cc:	df 93       	push	r29
    19ce:	00 d0       	rcall	.+0      	; 0x19d0 <xQueueSemaphoreTake+0xe>
    19d0:	00 d0       	rcall	.+0      	; 0x19d2 <xQueueSemaphoreTake+0x10>
    19d2:	1f 92       	push	r1
    19d4:	cd b7       	in	r28, 0x3d	; 61
    19d6:	de b7       	in	r29, 0x3e	; 62
    19d8:	8c 01       	movw	r16, r24
    19da:	7d 83       	std	Y+5, r23	; 0x05
    19dc:	6c 83       	std	Y+4, r22	; 0x04
BaseType_t xEntryTimeSet = pdFALSE;
    19de:	20 e0       	ldi	r18, 0x00	; 0
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    19e0:	7c 01       	movw	r14, r24
    19e2:	81 e1       	ldi	r24, 0x11	; 17
    19e4:	e8 0e       	add	r14, r24
    19e6:	f1 1c       	adc	r15, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    19e8:	0f b6       	in	r0, 0x3f	; 63
    19ea:	f8 94       	cli
    19ec:	0f 92       	push	r0
		{
			/* Semaphores are queues with an item size of 0, and where the
			number of messages in the queue is the semaphore's count value. */
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    19ee:	f8 01       	movw	r30, r16
    19f0:	92 8d       	ldd	r25, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    19f2:	99 23       	and	r25, r25
    19f4:	81 f0       	breq	.+32     	; 0x1a16 <xQueueSemaphoreTake+0x54>
			{
				traceQUEUE_RECEIVE( pxQueue );

				/* Semaphores are queues with a data size of zero and where the
				messages waiting is the semaphore's count.  Reduce the count. */
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    19f6:	91 50       	subi	r25, 0x01	; 1
    19f8:	92 8f       	std	Z+26, r25	; 0x1a
				}
				#endif /* configUSE_MUTEXES */

				/* Check to see if other tasks are blocked waiting to give the
				semaphore, and if so, unblock the highest priority such task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    19fa:	80 85       	ldd	r24, Z+8	; 0x08
    19fc:	88 23       	and	r24, r24
    19fe:	39 f0       	breq	.+14     	; 0x1a0e <xQueueSemaphoreTake+0x4c>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1a00:	c8 01       	movw	r24, r16
    1a02:	08 96       	adiw	r24, 0x08	; 8
    1a04:	0e 94 4a 07 	call	0xe94	; 0xe94 <xTaskRemoveFromEventList>
    1a08:	81 11       	cpse	r24, r1
					{
						queueYIELD_IF_USING_PREEMPTION();
    1a0a:	0e 94 74 13 	call	0x26e8	; 0x26e8 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    1a0e:	0f 90       	pop	r0
    1a10:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1a12:	81 e0       	ldi	r24, 0x01	; 1
    1a14:	50 c0       	rjmp	.+160    	; 0x1ab6 <xQueueSemaphoreTake+0xf4>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1a16:	8c 81       	ldd	r24, Y+4	; 0x04
    1a18:	9d 81       	ldd	r25, Y+5	; 0x05
    1a1a:	89 2b       	or	r24, r25
    1a1c:	19 f4       	brne	.+6      	; 0x1a24 <xQueueSemaphoreTake+0x62>
					}
					#endif /* configUSE_MUTEXES */

					/* The semaphore count was 0 and no block time is specified
					(or the block time has expired) so exit now. */
					taskEXIT_CRITICAL();
    1a1e:	0f 90       	pop	r0
    1a20:	0f be       	out	0x3f, r0	; 63
    1a22:	48 c0       	rjmp	.+144    	; 0x1ab4 <xQueueSemaphoreTake+0xf2>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
    1a24:	21 11       	cpse	r18, r1
    1a26:	04 c0       	rjmp	.+8      	; 0x1a30 <xQueueSemaphoreTake+0x6e>
				{
					/* The semaphore count was 0 and a block time was specified
					so configure the timeout structure ready to block. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    1a28:	ce 01       	movw	r24, r28
    1a2a:	01 96       	adiw	r24, 0x01	; 1
    1a2c:	0e 94 cc 07 	call	0xf98	; 0xf98 <vTaskInternalSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1a30:	0f 90       	pop	r0
    1a32:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can give to and take from the semaphore
		now the critical section has been exited. */

		vTaskSuspendAll();
    1a34:	0e 94 52 05 	call	0xaa4	; 0xaa4 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1a38:	0f b6       	in	r0, 0x3f	; 63
    1a3a:	f8 94       	cli
    1a3c:	0f 92       	push	r0
    1a3e:	f8 01       	movw	r30, r16
    1a40:	85 8d       	ldd	r24, Z+29	; 0x1d
    1a42:	8f 3f       	cpi	r24, 0xFF	; 255
    1a44:	09 f4       	brne	.+2      	; 0x1a48 <xQueueSemaphoreTake+0x86>
    1a46:	15 8e       	std	Z+29, r1	; 0x1d
    1a48:	f8 01       	movw	r30, r16
    1a4a:	86 8d       	ldd	r24, Z+30	; 0x1e
    1a4c:	8f 3f       	cpi	r24, 0xFF	; 255
    1a4e:	09 f4       	brne	.+2      	; 0x1a52 <xQueueSemaphoreTake+0x90>
    1a50:	16 8e       	std	Z+30, r1	; 0x1e
    1a52:	0f 90       	pop	r0
    1a54:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1a56:	be 01       	movw	r22, r28
    1a58:	6c 5f       	subi	r22, 0xFC	; 252
    1a5a:	7f 4f       	sbci	r23, 0xFF	; 255
    1a5c:	ce 01       	movw	r24, r28
    1a5e:	01 96       	adiw	r24, 0x01	; 1
    1a60:	0e 94 d7 07 	call	0xfae	; 0xfae <xTaskCheckForTimeOut>
    1a64:	81 11       	cpse	r24, r1
    1a66:	1c c0       	rjmp	.+56     	; 0x1aa0 <xQueueSemaphoreTake+0xde>
		{
			/* A block time is specified and not expired.  If the semaphore
			count is 0 then enter the Blocked state to wait for a semaphore to
			become available.  As semaphores are implemented with queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1a68:	c8 01       	movw	r24, r16
    1a6a:	0e 94 4f 0a 	call	0x149e	; 0x149e <prvIsQueueEmpty>
    1a6e:	88 23       	and	r24, r24
    1a70:	89 f0       	breq	.+34     	; 0x1a94 <xQueueSemaphoreTake+0xd2>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1a72:	6c 81       	ldd	r22, Y+4	; 0x04
    1a74:	7d 81       	ldd	r23, Y+5	; 0x05
    1a76:	c7 01       	movw	r24, r14
    1a78:	0e 94 22 07 	call	0xe44	; 0xe44 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1a7c:	c8 01       	movw	r24, r16
    1a7e:	0e 94 bd 0a 	call	0x157a	; 0x157a <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1a82:	0e 94 1e 06 	call	0xc3c	; 0xc3c <xTaskResumeAll>
    1a86:	88 23       	and	r24, r24
    1a88:	11 f0       	breq	.+4      	; 0x1a8e <xQueueSemaphoreTake+0xcc>
    1a8a:	21 e0       	ldi	r18, 0x01	; 1
    1a8c:	ad cf       	rjmp	.-166    	; 0x19e8 <xQueueSemaphoreTake+0x26>
				{
					portYIELD_WITHIN_API();
    1a8e:	0e 94 74 13 	call	0x26e8	; 0x26e8 <vPortYield>
    1a92:	fb cf       	rjmp	.-10     	; 0x1a8a <xQueueSemaphoreTake+0xc8>
			}
			else
			{
				/* There was no timeout and the semaphore count was not 0, so
				attempt to take the semaphore again. */
				prvUnlockQueue( pxQueue );
    1a94:	c8 01       	movw	r24, r16
    1a96:	0e 94 bd 0a 	call	0x157a	; 0x157a <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1a9a:	0e 94 1e 06 	call	0xc3c	; 0xc3c <xTaskResumeAll>
    1a9e:	f5 cf       	rjmp	.-22     	; 0x1a8a <xQueueSemaphoreTake+0xc8>
			}
		}
		else
		{
			/* Timed out. */
			prvUnlockQueue( pxQueue );
    1aa0:	c8 01       	movw	r24, r16
    1aa2:	0e 94 bd 0a 	call	0x157a	; 0x157a <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1aa6:	0e 94 1e 06 	call	0xc3c	; 0xc3c <xTaskResumeAll>

			/* If the semaphore count is 0 exit now as the timeout has
			expired.  Otherwise return to attempt to take the semaphore that is
			known to be available.  As semaphores are implemented by queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1aaa:	c8 01       	movw	r24, r16
    1aac:	0e 94 4f 0a 	call	0x149e	; 0x149e <prvIsQueueEmpty>
    1ab0:	88 23       	and	r24, r24
    1ab2:	59 f3       	breq	.-42     	; 0x1a8a <xQueueSemaphoreTake+0xc8>
					}
				}
				#endif /* configUSE_MUTEXES */

				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    1ab4:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
}
    1ab6:	0f 90       	pop	r0
    1ab8:	0f 90       	pop	r0
    1aba:	0f 90       	pop	r0
    1abc:	0f 90       	pop	r0
    1abe:	0f 90       	pop	r0
    1ac0:	df 91       	pop	r29
    1ac2:	cf 91       	pop	r28
    1ac4:	1f 91       	pop	r17
    1ac6:	0f 91       	pop	r16
    1ac8:	ff 90       	pop	r15
    1aca:	ef 90       	pop	r14
    1acc:	08 95       	ret

00001ace <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    1ace:	cf 92       	push	r12
    1ad0:	df 92       	push	r13
    1ad2:	ef 92       	push	r14
    1ad4:	ff 92       	push	r15
    1ad6:	0f 93       	push	r16
    1ad8:	1f 93       	push	r17
    1ada:	cf 93       	push	r28
    1adc:	df 93       	push	r29
    1ade:	00 d0       	rcall	.+0      	; 0x1ae0 <xQueuePeek+0x12>
    1ae0:	00 d0       	rcall	.+0      	; 0x1ae2 <xQueuePeek+0x14>
    1ae2:	1f 92       	push	r1
    1ae4:	cd b7       	in	r28, 0x3d	; 61
    1ae6:	de b7       	in	r29, 0x3e	; 62
    1ae8:	8c 01       	movw	r16, r24
    1aea:	7b 01       	movw	r14, r22
    1aec:	5d 83       	std	Y+5, r21	; 0x05
    1aee:	4c 83       	std	Y+4, r20	; 0x04
BaseType_t xEntryTimeSet = pdFALSE;
    1af0:	90 e0       	ldi	r25, 0x00	; 0
			/* Timeout has not expired yet, check to see if there is data in the
			queue now, and if not enter the Blocked state to wait for data. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1af2:	68 01       	movw	r12, r16
    1af4:	81 e1       	ldi	r24, 0x11	; 17
    1af6:	c8 0e       	add	r12, r24
    1af8:	d1 1c       	adc	r13, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    1afa:	0f b6       	in	r0, 0x3f	; 63
    1afc:	f8 94       	cli
    1afe:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1b00:	f8 01       	movw	r30, r16
    1b02:	82 8d       	ldd	r24, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1b04:	88 23       	and	r24, r24
    1b06:	b9 f0       	breq	.+46     	; 0x1b36 <xQueuePeek+0x68>
			{
				/* Remember the read position so it can be reset after the data
				is read from the queue as this function is only peeking the
				data, not removing it. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    1b08:	c6 80       	ldd	r12, Z+6	; 0x06
    1b0a:	d7 80       	ldd	r13, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1b0c:	b7 01       	movw	r22, r14
    1b0e:	c8 01       	movw	r24, r16
    1b10:	0e 94 a3 0a 	call	0x1546	; 0x1546 <prvCopyDataFromQueue>
				traceQUEUE_PEEK( pxQueue );

				/* The data is not being removed, so reset the read pointer. */
				pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    1b14:	f8 01       	movw	r30, r16
    1b16:	d7 82       	std	Z+7, r13	; 0x07
    1b18:	c6 82       	std	Z+6, r12	; 0x06

				/* The data is being left in the queue, so see if there are
				any other tasks waiting for the data. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1b1a:	81 89       	ldd	r24, Z+17	; 0x11
    1b1c:	88 23       	and	r24, r24
    1b1e:	39 f0       	breq	.+14     	; 0x1b2e <xQueuePeek+0x60>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1b20:	c8 01       	movw	r24, r16
    1b22:	41 96       	adiw	r24, 0x11	; 17
    1b24:	0e 94 4a 07 	call	0xe94	; 0xe94 <xTaskRemoveFromEventList>
    1b28:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority than this task. */
						queueYIELD_IF_USING_PREEMPTION();
    1b2a:	0e 94 74 13 	call	0x26e8	; 0x26e8 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    1b2e:	0f 90       	pop	r0
    1b30:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1b32:	81 e0       	ldi	r24, 0x01	; 1
    1b34:	50 c0       	rjmp	.+160    	; 0x1bd6 <xQueuePeek+0x108>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1b36:	2c 81       	ldd	r18, Y+4	; 0x04
    1b38:	3d 81       	ldd	r19, Y+5	; 0x05
    1b3a:	23 2b       	or	r18, r19
    1b3c:	19 f4       	brne	.+6      	; 0x1b44 <xQueuePeek+0x76>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1b3e:	0f 90       	pop	r0
    1b40:	0f be       	out	0x3f, r0	; 63
    1b42:	48 c0       	rjmp	.+144    	; 0x1bd4 <xQueuePeek+0x106>
					traceQUEUE_PEEK_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
    1b44:	91 11       	cpse	r25, r1
    1b46:	04 c0       	rjmp	.+8      	; 0x1b50 <xQueuePeek+0x82>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure ready to enter the blocked
					state. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    1b48:	ce 01       	movw	r24, r28
    1b4a:	01 96       	adiw	r24, 0x01	; 1
    1b4c:	0e 94 cc 07 	call	0xf98	; 0xf98 <vTaskInternalSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1b50:	0f 90       	pop	r0
    1b52:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1b54:	0e 94 52 05 	call	0xaa4	; 0xaa4 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1b58:	0f b6       	in	r0, 0x3f	; 63
    1b5a:	f8 94       	cli
    1b5c:	0f 92       	push	r0
    1b5e:	f8 01       	movw	r30, r16
    1b60:	85 8d       	ldd	r24, Z+29	; 0x1d
    1b62:	8f 3f       	cpi	r24, 0xFF	; 255
    1b64:	09 f4       	brne	.+2      	; 0x1b68 <xQueuePeek+0x9a>
    1b66:	15 8e       	std	Z+29, r1	; 0x1d
    1b68:	f8 01       	movw	r30, r16
    1b6a:	86 8d       	ldd	r24, Z+30	; 0x1e
    1b6c:	8f 3f       	cpi	r24, 0xFF	; 255
    1b6e:	09 f4       	brne	.+2      	; 0x1b72 <xQueuePeek+0xa4>
    1b70:	16 8e       	std	Z+30, r1	; 0x1e
    1b72:	0f 90       	pop	r0
    1b74:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1b76:	be 01       	movw	r22, r28
    1b78:	6c 5f       	subi	r22, 0xFC	; 252
    1b7a:	7f 4f       	sbci	r23, 0xFF	; 255
    1b7c:	ce 01       	movw	r24, r28
    1b7e:	01 96       	adiw	r24, 0x01	; 1
    1b80:	0e 94 d7 07 	call	0xfae	; 0xfae <xTaskCheckForTimeOut>
    1b84:	81 11       	cpse	r24, r1
    1b86:	1c c0       	rjmp	.+56     	; 0x1bc0 <xQueuePeek+0xf2>
		{
			/* Timeout has not expired yet, check to see if there is data in the
			queue now, and if not enter the Blocked state to wait for data. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1b88:	c8 01       	movw	r24, r16
    1b8a:	0e 94 4f 0a 	call	0x149e	; 0x149e <prvIsQueueEmpty>
    1b8e:	88 23       	and	r24, r24
    1b90:	89 f0       	breq	.+34     	; 0x1bb4 <xQueuePeek+0xe6>
			{
				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1b92:	6c 81       	ldd	r22, Y+4	; 0x04
    1b94:	7d 81       	ldd	r23, Y+5	; 0x05
    1b96:	c6 01       	movw	r24, r12
    1b98:	0e 94 22 07 	call	0xe44	; 0xe44 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1b9c:	c8 01       	movw	r24, r16
    1b9e:	0e 94 bd 0a 	call	0x157a	; 0x157a <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1ba2:	0e 94 1e 06 	call	0xc3c	; 0xc3c <xTaskResumeAll>
    1ba6:	88 23       	and	r24, r24
    1ba8:	11 f0       	breq	.+4      	; 0x1bae <xQueuePeek+0xe0>
    1baa:	91 e0       	ldi	r25, 0x01	; 1
    1bac:	a6 cf       	rjmp	.-180    	; 0x1afa <xQueuePeek+0x2c>
				{
					portYIELD_WITHIN_API();
    1bae:	0e 94 74 13 	call	0x26e8	; 0x26e8 <vPortYield>
    1bb2:	fb cf       	rjmp	.-10     	; 0x1baa <xQueuePeek+0xdc>
			}
			else
			{
				/* There is data in the queue now, so don't enter the blocked
				state, instead return to try and obtain the data. */
				prvUnlockQueue( pxQueue );
    1bb4:	c8 01       	movw	r24, r16
    1bb6:	0e 94 bd 0a 	call	0x157a	; 0x157a <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1bba:	0e 94 1e 06 	call	0xc3c	; 0xc3c <xTaskResumeAll>
    1bbe:	f5 cf       	rjmp	.-22     	; 0x1baa <xQueuePeek+0xdc>
		}
		else
		{
			/* The timeout has expired.  If there is still no data in the queue
			exit, otherwise go back and try to read the data again. */
			prvUnlockQueue( pxQueue );
    1bc0:	c8 01       	movw	r24, r16
    1bc2:	0e 94 bd 0a 	call	0x157a	; 0x157a <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1bc6:	0e 94 1e 06 	call	0xc3c	; 0xc3c <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1bca:	c8 01       	movw	r24, r16
    1bcc:	0e 94 4f 0a 	call	0x149e	; 0x149e <prvIsQueueEmpty>
    1bd0:	88 23       	and	r24, r24
    1bd2:	59 f3       	breq	.-42     	; 0x1baa <xQueuePeek+0xdc>
			{
				traceQUEUE_PEEK_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    1bd4:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
}
    1bd6:	0f 90       	pop	r0
    1bd8:	0f 90       	pop	r0
    1bda:	0f 90       	pop	r0
    1bdc:	0f 90       	pop	r0
    1bde:	0f 90       	pop	r0
    1be0:	df 91       	pop	r29
    1be2:	cf 91       	pop	r28
    1be4:	1f 91       	pop	r17
    1be6:	0f 91       	pop	r16
    1be8:	ff 90       	pop	r15
    1bea:	ef 90       	pop	r14
    1bec:	df 90       	pop	r13
    1bee:	cf 90       	pop	r12
    1bf0:	08 95       	ret

00001bf2 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    1bf2:	ef 92       	push	r14
    1bf4:	ff 92       	push	r15
    1bf6:	0f 93       	push	r16
    1bf8:	1f 93       	push	r17
    1bfa:	cf 93       	push	r28
    1bfc:	df 93       	push	r29
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1bfe:	fc 01       	movw	r30, r24
    1c00:	02 8d       	ldd	r16, Z+26	; 0x1a

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1c02:	00 23       	and	r16, r16
    1c04:	e9 f0       	breq	.+58     	; 0x1c40 <xQueueReceiveFromISR+0x4e>
    1c06:	7a 01       	movw	r14, r20
    1c08:	ec 01       	movw	r28, r24
		{
			const int8_t cRxLock = pxQueue->cRxLock;
    1c0a:	15 8d       	ldd	r17, Z+29	; 0x1d

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1c0c:	0e 94 a3 0a 	call	0x1546	; 0x1546 <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    1c10:	01 50       	subi	r16, 0x01	; 1
    1c12:	0a 8f       	std	Y+26, r16	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
    1c14:	1f 3f       	cpi	r17, 0xFF	; 255
    1c16:	81 f4       	brne	.+32     	; 0x1c38 <xQueueReceiveFromISR+0x46>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1c18:	88 85       	ldd	r24, Y+8	; 0x08
    1c1a:	88 23       	and	r24, r24
    1c1c:	79 f0       	breq	.+30     	; 0x1c3c <xQueueReceiveFromISR+0x4a>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1c1e:	ce 01       	movw	r24, r28
    1c20:	08 96       	adiw	r24, 0x08	; 8
    1c22:	0e 94 4a 07 	call	0xe94	; 0xe94 <xTaskRemoveFromEventList>
    1c26:	88 23       	and	r24, r24
    1c28:	49 f0       	breq	.+18     	; 0x1c3c <xQueueReceiveFromISR+0x4a>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    1c2a:	e1 14       	cp	r14, r1
    1c2c:	f1 04       	cpc	r15, r1
    1c2e:	31 f0       	breq	.+12     	; 0x1c3c <xQueueReceiveFromISR+0x4a>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    1c30:	81 e0       	ldi	r24, 0x01	; 1
    1c32:	f7 01       	movw	r30, r14
    1c34:	80 83       	st	Z, r24
    1c36:	05 c0       	rjmp	.+10     	; 0x1c42 <xQueueReceiveFromISR+0x50>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    1c38:	1f 5f       	subi	r17, 0xFF	; 255
    1c3a:	1d 8f       	std	Y+29, r17	; 0x1d
			}

			xReturn = pdPASS;
    1c3c:	81 e0       	ldi	r24, 0x01	; 1
    1c3e:	01 c0       	rjmp	.+2      	; 0x1c42 <xQueueReceiveFromISR+0x50>
		}
		else
		{
			xReturn = pdFAIL;
    1c40:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1c42:	df 91       	pop	r29
    1c44:	cf 91       	pop	r28
    1c46:	1f 91       	pop	r17
    1c48:	0f 91       	pop	r16
    1c4a:	ff 90       	pop	r15
    1c4c:	ef 90       	pop	r14
    1c4e:	08 95       	ret

00001c50 <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    1c50:	0f 93       	push	r16
    1c52:	1f 93       	push	r17
    1c54:	cf 93       	push	r28
    1c56:	df 93       	push	r29
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1c58:	fc 01       	movw	r30, r24
    1c5a:	22 8d       	ldd	r18, Z+26	; 0x1a
    1c5c:	22 23       	and	r18, r18
    1c5e:	49 f0       	breq	.+18     	; 0x1c72 <xQueuePeekFromISR+0x22>
    1c60:	ec 01       	movw	r28, r24
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    1c62:	06 81       	ldd	r16, Z+6	; 0x06
    1c64:	17 81       	ldd	r17, Z+7	; 0x07
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1c66:	0e 94 a3 0a 	call	0x1546	; 0x1546 <prvCopyDataFromQueue>
			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    1c6a:	1f 83       	std	Y+7, r17	; 0x07
    1c6c:	0e 83       	std	Y+6, r16	; 0x06

			xReturn = pdPASS;
    1c6e:	81 e0       	ldi	r24, 0x01	; 1
    1c70:	01 c0       	rjmp	.+2      	; 0x1c74 <xQueuePeekFromISR+0x24>
		}
		else
		{
			xReturn = pdFAIL;
    1c72:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1c74:	df 91       	pop	r29
    1c76:	cf 91       	pop	r28
    1c78:	1f 91       	pop	r17
    1c7a:	0f 91       	pop	r16
    1c7c:	08 95       	ret

00001c7e <uxQueueMessagesWaiting>:
{
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    1c7e:	0f b6       	in	r0, 0x3f	; 63
    1c80:	f8 94       	cli
    1c82:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    1c84:	fc 01       	movw	r30, r24
    1c86:	82 8d       	ldd	r24, Z+26	; 0x1a
	}
	taskEXIT_CRITICAL();
    1c88:	0f 90       	pop	r0
    1c8a:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1c8c:	08 95       	ret

00001c8e <uxQueueSpacesAvailable>:
Queue_t *pxQueue;

	pxQueue = ( Queue_t * ) xQueue;
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1c8e:	0f b6       	in	r0, 0x3f	; 63
    1c90:	f8 94       	cli
    1c92:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    1c94:	fc 01       	movw	r30, r24
    1c96:	22 8d       	ldd	r18, Z+26	; 0x1a
	}
	taskEXIT_CRITICAL();
    1c98:	0f 90       	pop	r0
    1c9a:	0f be       	out	0x3f, r0	; 63
	pxQueue = ( Queue_t * ) xQueue;
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    1c9c:	83 8d       	ldd	r24, Z+27	; 0x1b
	}
	taskEXIT_CRITICAL();

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1c9e:	82 1b       	sub	r24, r18
    1ca0:	08 95       	ret

00001ca2 <uxQueueMessagesWaitingFromISR>:
{
UBaseType_t uxReturn;

	configASSERT( xQueue );

	uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    1ca2:	fc 01       	movw	r30, r24
    1ca4:	82 8d       	ldd	r24, Z+26	; 0x1a

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1ca6:	08 95       	ret

00001ca8 <vQueueDelete>:

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
    1ca8:	0c 94 8f 12 	jmp	0x251e	; 0x251e <vPortFree>

00001cac <xQueueIsQueueEmptyFromISR>:
BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( UBaseType_t ) 0 )
    1cac:	fc 01       	movw	r30, r24
    1cae:	92 8d       	ldd	r25, Z+26	; 0x1a
    1cb0:	81 e0       	ldi	r24, 0x01	; 1
    1cb2:	91 11       	cpse	r25, r1
    1cb4:	80 e0       	ldi	r24, 0x00	; 0
	{
		xReturn = pdFALSE;
	}

	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    1cb6:	08 95       	ret

00001cb8 <xQueueIsQueueFullFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    1cb8:	fc 01       	movw	r30, r24
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( ( Queue_t * ) xQueue )->uxLength )
    1cba:	22 8d       	ldd	r18, Z+26	; 0x1a
    1cbc:	81 e0       	ldi	r24, 0x01	; 1
    1cbe:	93 8d       	ldd	r25, Z+27	; 0x1b
    1cc0:	29 13       	cpse	r18, r25
    1cc2:	80 e0       	ldi	r24, 0x00	; 0
	{
		xReturn = pdFALSE;
	}

	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    1cc4:	08 95       	ret

00001cc6 <xQueueCRSend>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRSend( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait )
	{
    1cc6:	cf 93       	push	r28
    1cc8:	df 93       	push	r29
    1cca:	ec 01       	movw	r28, r24
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;

		/* If the queue is already full we may have to block.  A critical section
		is required to prevent an interrupt removing something from the queue
		between the check to see if the queue is full and blocking on the queue. */
		portDISABLE_INTERRUPTS();
    1ccc:	f8 94       	cli

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1cce:	0f b6       	in	r0, 0x3f	; 63
    1cd0:	f8 94       	cli
    1cd2:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    1cd4:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1cd6:	9b 8d       	ldd	r25, Y+27	; 0x1b
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1cd8:	0f 90       	pop	r0
    1cda:	0f be       	out	0x3f, r0	; 63
		/* If the queue is already full we may have to block.  A critical section
		is required to prevent an interrupt removing something from the queue
		between the check to see if the queue is full and blocking on the queue. */
		portDISABLE_INTERRUPTS();
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1cdc:	89 13       	cpse	r24, r25
    1cde:	0f c0       	rjmp	.+30     	; 0x1cfe <xQueueCRSend+0x38>
			{
				/* The queue is full - do we want to block or just leave without
				posting? */
				if( xTicksToWait > ( TickType_t ) 0 )
    1ce0:	41 15       	cp	r20, r1
    1ce2:	51 05       	cpc	r21, r1
    1ce4:	49 f0       	breq	.+18     	; 0x1cf8 <xQueueCRSend+0x32>
				{
					/* As this is called from a coroutine we cannot block directly, but
					return indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
    1ce6:	be 01       	movw	r22, r28
    1ce8:	68 5f       	subi	r22, 0xF8	; 248
    1cea:	7f 4f       	sbci	r23, 0xFF	; 255
    1cec:	ca 01       	movw	r24, r20
    1cee:	0e 94 42 10 	call	0x2084	; 0x2084 <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
    1cf2:	78 94       	sei
					return errQUEUE_BLOCKED;
    1cf4:	8c ef       	ldi	r24, 0xFC	; 252
    1cf6:	1b c0       	rjmp	.+54     	; 0x1d2e <xQueueCRSend+0x68>
				}
				else
				{
					portENABLE_INTERRUPTS();
    1cf8:	78 94       	sei
					return errQUEUE_FULL;
    1cfa:	80 e0       	ldi	r24, 0x00	; 0
    1cfc:	18 c0       	rjmp	.+48     	; 0x1d2e <xQueueCRSend+0x68>
				}
			}
		}
		portENABLE_INTERRUPTS();
    1cfe:	78 94       	sei

		portDISABLE_INTERRUPTS();
    1d00:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1d02:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1d04:	89 17       	cp	r24, r25
    1d06:	88 f4       	brcc	.+34     	; 0x1d2a <xQueueCRSend+0x64>
			{
				/* There is room in the queue, copy the data into the queue. */
				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    1d08:	40 e0       	ldi	r20, 0x00	; 0
    1d0a:	ce 01       	movw	r24, r28
    1d0c:	0e 94 5a 0a 	call	0x14b4	; 0x14b4 <prvCopyDataToQueue>
				xReturn = pdPASS;

				/* Were any co-routines waiting for data to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1d10:	89 89       	ldd	r24, Y+17	; 0x11
    1d12:	81 11       	cpse	r24, r1
    1d14:	02 c0       	rjmp	.+4      	; 0x1d1a <xQueueCRSend+0x54>
		{
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
			{
				/* There is room in the queue, copy the data into the queue. */
				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
				xReturn = pdPASS;
    1d16:	81 e0       	ldi	r24, 0x01	; 1
    1d18:	09 c0       	rjmp	.+18     	; 0x1d2c <xQueueCRSend+0x66>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1d1a:	ce 01       	movw	r24, r28
    1d1c:	41 96       	adiw	r24, 0x11	; 17
    1d1e:	0e 94 71 11 	call	0x22e2	; 0x22e2 <xCoRoutineRemoveFromEventList>
    1d22:	88 23       	and	r24, r24
    1d24:	c1 f3       	breq	.-16     	; 0x1d16 <xQueueCRSend+0x50>
					{
						/* The co-routine waiting has a higher priority so record
						that a yield might be appropriate. */
						xReturn = errQUEUE_YIELD;
    1d26:	8b ef       	ldi	r24, 0xFB	; 251
    1d28:	01 c0       	rjmp	.+2      	; 0x1d2c <xQueueCRSend+0x66>
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else
			{
				xReturn = errQUEUE_FULL;
    1d2a:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		portENABLE_INTERRUPTS();
    1d2c:	78 94       	sei

		return xReturn;
	}
    1d2e:	df 91       	pop	r29
    1d30:	cf 91       	pop	r28
    1d32:	08 95       	ret

00001d34 <xQueueCRReceive>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRReceive( QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait )
	{
    1d34:	cf 93       	push	r28
    1d36:	df 93       	push	r29
    1d38:	ec 01       	movw	r28, r24
    1d3a:	fb 01       	movw	r30, r22
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;

		/* If the queue is already empty we may have to block.  A critical section
		is required to prevent an interrupt adding something to the queue
		between the check to see if the queue is empty and blocking on the queue. */
		portDISABLE_INTERRUPTS();
    1d3c:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    1d3e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1d40:	81 11       	cpse	r24, r1
    1d42:	0f c0       	rjmp	.+30     	; 0x1d62 <xQueueCRReceive+0x2e>
			{
				/* There are no messages in the queue, do we want to block or just
				leave with nothing? */
				if( xTicksToWait > ( TickType_t ) 0 )
    1d44:	41 15       	cp	r20, r1
    1d46:	51 05       	cpc	r21, r1
    1d48:	49 f0       	breq	.+18     	; 0x1d5c <xQueueCRReceive+0x28>
				{
					/* As this is a co-routine we cannot block directly, but return
					indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
    1d4a:	be 01       	movw	r22, r28
    1d4c:	6f 5e       	subi	r22, 0xEF	; 239
    1d4e:	7f 4f       	sbci	r23, 0xFF	; 255
    1d50:	ca 01       	movw	r24, r20
    1d52:	0e 94 42 10 	call	0x2084	; 0x2084 <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
    1d56:	78 94       	sei
					return errQUEUE_BLOCKED;
    1d58:	8c ef       	ldi	r24, 0xFC	; 252
    1d5a:	30 c0       	rjmp	.+96     	; 0x1dbc <xQueueCRReceive+0x88>
				}
				else
				{
					portENABLE_INTERRUPTS();
    1d5c:	78 94       	sei
					return errQUEUE_FULL;
    1d5e:	80 e0       	ldi	r24, 0x00	; 0
    1d60:	2d c0       	rjmp	.+90     	; 0x1dbc <xQueueCRReceive+0x88>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portENABLE_INTERRUPTS();
    1d62:	78 94       	sei

		portDISABLE_INTERRUPTS();
    1d64:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1d66:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1d68:	88 23       	and	r24, r24
    1d6a:	31 f1       	breq	.+76     	; 0x1db8 <xQueueCRReceive+0x84>
			{
				/* Data is available from the queue. */
				pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    1d6c:	4c 8d       	ldd	r20, Y+28	; 0x1c
    1d6e:	50 e0       	ldi	r21, 0x00	; 0
    1d70:	2e 81       	ldd	r18, Y+6	; 0x06
    1d72:	3f 81       	ldd	r19, Y+7	; 0x07
    1d74:	24 0f       	add	r18, r20
    1d76:	35 1f       	adc	r19, r21
    1d78:	3f 83       	std	Y+7, r19	; 0x07
    1d7a:	2e 83       	std	Y+6, r18	; 0x06
				if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
    1d7c:	8a 81       	ldd	r24, Y+2	; 0x02
    1d7e:	9b 81       	ldd	r25, Y+3	; 0x03
    1d80:	28 17       	cp	r18, r24
    1d82:	39 07       	cpc	r19, r25
    1d84:	20 f0       	brcs	.+8      	; 0x1d8e <xQueueCRReceive+0x5a>
				{
					pxQueue->u.pcReadFrom = pxQueue->pcHead;
    1d86:	88 81       	ld	r24, Y
    1d88:	99 81       	ldd	r25, Y+1	; 0x01
    1d8a:	9f 83       	std	Y+7, r25	; 0x07
    1d8c:	8e 83       	std	Y+6, r24	; 0x06
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				--( pxQueue->uxMessagesWaiting );
    1d8e:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1d90:	91 50       	subi	r25, 0x01	; 1
    1d92:	9a 8f       	std	Y+26, r25	; 0x1a
				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    1d94:	6e 81       	ldd	r22, Y+6	; 0x06
    1d96:	7f 81       	ldd	r23, Y+7	; 0x07
    1d98:	cf 01       	movw	r24, r30
    1d9a:	0e 94 5f 17 	call	0x2ebe	; 0x2ebe <memcpy>

				xReturn = pdPASS;

				/* Were any co-routines waiting for space to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1d9e:	88 85       	ldd	r24, Y+8	; 0x08
    1da0:	81 11       	cpse	r24, r1
    1da2:	02 c0       	rjmp	.+4      	; 0x1da8 <xQueueCRReceive+0x74>
					mtCOVERAGE_TEST_MARKER();
				}
				--( pxQueue->uxMessagesWaiting );
				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );

				xReturn = pdPASS;
    1da4:	81 e0       	ldi	r24, 0x01	; 1
    1da6:	09 c0       	rjmp	.+18     	; 0x1dba <xQueueCRReceive+0x86>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1da8:	ce 01       	movw	r24, r28
    1daa:	08 96       	adiw	r24, 0x08	; 8
    1dac:	0e 94 71 11 	call	0x22e2	; 0x22e2 <xCoRoutineRemoveFromEventList>
    1db0:	88 23       	and	r24, r24
    1db2:	c1 f3       	breq	.-16     	; 0x1da4 <xQueueCRReceive+0x70>
					{
						xReturn = errQUEUE_YIELD;
    1db4:	8b ef       	ldi	r24, 0xFB	; 251
    1db6:	01 c0       	rjmp	.+2      	; 0x1dba <xQueueCRReceive+0x86>
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else
			{
				xReturn = pdFAIL;
    1db8:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		portENABLE_INTERRUPTS();
    1dba:	78 94       	sei

		return xReturn;
	}
    1dbc:	df 91       	pop	r29
    1dbe:	cf 91       	pop	r28
    1dc0:	08 95       	ret

00001dc2 <xQueueCRSendFromISR>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t xCoRoutinePreviouslyWoken )
	{
    1dc2:	0f 93       	push	r16
    1dc4:	1f 93       	push	r17
    1dc6:	cf 93       	push	r28
    1dc8:	8c 01       	movw	r16, r24
    1dca:	c4 2f       	mov	r28, r20
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;

		/* Cannot block within an ISR so if there is no space on the queue then
		exit without doing anything. */
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1dcc:	fc 01       	movw	r30, r24
    1dce:	92 8d       	ldd	r25, Z+26	; 0x1a
    1dd0:	83 8d       	ldd	r24, Z+27	; 0x1b
    1dd2:	98 17       	cp	r25, r24
    1dd4:	10 f0       	brcs	.+4      	; 0x1dda <xQueueCRSendFromISR+0x18>
    1dd6:	4c 2f       	mov	r20, r28
    1dd8:	12 c0       	rjmp	.+36     	; 0x1dfe <xQueueCRSendFromISR+0x3c>
		{
			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    1dda:	40 e0       	ldi	r20, 0x00	; 0
    1ddc:	c8 01       	movw	r24, r16
    1dde:	0e 94 5a 0a 	call	0x14b4	; 0x14b4 <prvCopyDataToQueue>

			/* We only want to wake one co-routine per ISR, so check that a
			co-routine has not already been woken. */
			if( xCoRoutinePreviouslyWoken == pdFALSE )
    1de2:	c1 11       	cpse	r28, r1
    1de4:	f8 cf       	rjmp	.-16     	; 0x1dd6 <xQueueCRSendFromISR+0x14>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1de6:	f8 01       	movw	r30, r16
    1de8:	81 89       	ldd	r24, Z+17	; 0x11
    1dea:	88 23       	and	r24, r24
    1dec:	39 f0       	breq	.+14     	; 0x1dfc <xQueueCRSendFromISR+0x3a>
				{
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1dee:	c8 01       	movw	r24, r16
    1df0:	41 96       	adiw	r24, 0x11	; 17
    1df2:	0e 94 71 11 	call	0x22e2	; 0x22e2 <xCoRoutineRemoveFromEventList>
    1df6:	41 e0       	ldi	r20, 0x01	; 1
    1df8:	81 11       	cpse	r24, r1
    1dfa:	01 c0       	rjmp	.+2      	; 0x1dfe <xQueueCRSendFromISR+0x3c>
    1dfc:	40 e0       	ldi	r20, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xCoRoutinePreviouslyWoken;
	}
    1dfe:	84 2f       	mov	r24, r20
    1e00:	cf 91       	pop	r28
    1e02:	1f 91       	pop	r17
    1e04:	0f 91       	pop	r16
    1e06:	08 95       	ret

00001e08 <xQueueCRReceiveFromISR>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxCoRoutineWoken )
	{
    1e08:	0f 93       	push	r16
    1e0a:	1f 93       	push	r17
    1e0c:	cf 93       	push	r28
    1e0e:	df 93       	push	r29
    1e10:	fc 01       	movw	r30, r24
	BaseType_t xReturn;
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;

		/* We cannot block from an ISR, so check there is data available. If
		not then just leave without doing anything. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1e12:	82 8d       	ldd	r24, Z+26	; 0x1a
    1e14:	88 23       	and	r24, r24
    1e16:	79 f1       	breq	.+94     	; 0x1e76 <xQueueCRReceiveFromISR+0x6e>
		{
			/* Copy the data from the queue. */
			pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    1e18:	24 8d       	ldd	r18, Z+28	; 0x1c
    1e1a:	30 e0       	ldi	r19, 0x00	; 0
    1e1c:	a6 81       	ldd	r26, Z+6	; 0x06
    1e1e:	b7 81       	ldd	r27, Z+7	; 0x07
    1e20:	a2 0f       	add	r26, r18
    1e22:	b3 1f       	adc	r27, r19
    1e24:	b7 83       	std	Z+7, r27	; 0x07
    1e26:	a6 83       	std	Z+6, r26	; 0x06
			if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
    1e28:	82 81       	ldd	r24, Z+2	; 0x02
    1e2a:	93 81       	ldd	r25, Z+3	; 0x03
    1e2c:	a8 17       	cp	r26, r24
    1e2e:	b9 07       	cpc	r27, r25
    1e30:	20 f0       	brcs	.+8      	; 0x1e3a <xQueueCRReceiveFromISR+0x32>
			{
				pxQueue->u.pcReadFrom = pxQueue->pcHead;
    1e32:	80 81       	ld	r24, Z
    1e34:	91 81       	ldd	r25, Z+1	; 0x01
    1e36:	97 83       	std	Z+7, r25	; 0x07
    1e38:	86 83       	std	Z+6, r24	; 0x06
    1e3a:	8a 01       	movw	r16, r20
    1e3c:	cb 01       	movw	r24, r22
    1e3e:	ef 01       	movw	r28, r30
			}
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
			--( pxQueue->uxMessagesWaiting );
    1e40:	42 8d       	ldd	r20, Z+26	; 0x1a
    1e42:	41 50       	subi	r20, 0x01	; 1
    1e44:	42 8f       	std	Z+26, r20	; 0x1a
			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    1e46:	66 81       	ldd	r22, Z+6	; 0x06
    1e48:	77 81       	ldd	r23, Z+7	; 0x07
    1e4a:	a9 01       	movw	r20, r18
    1e4c:	0e 94 5f 17 	call	0x2ebe	; 0x2ebe <memcpy>

			if( ( *pxCoRoutineWoken ) == pdFALSE )
    1e50:	f8 01       	movw	r30, r16
    1e52:	80 81       	ld	r24, Z
    1e54:	88 23       	and	r24, r24
    1e56:	11 f0       	breq	.+4      	; 0x1e5c <xQueueCRReceiveFromISR+0x54>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			xReturn = pdPASS;
    1e58:	81 e0       	ldi	r24, 0x01	; 1
    1e5a:	0e c0       	rjmp	.+28     	; 0x1e78 <xQueueCRReceiveFromISR+0x70>
			--( pxQueue->uxMessagesWaiting );
			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );

			if( ( *pxCoRoutineWoken ) == pdFALSE )
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1e5c:	88 85       	ldd	r24, Y+8	; 0x08
    1e5e:	88 23       	and	r24, r24
    1e60:	d9 f3       	breq	.-10     	; 0x1e58 <xQueueCRReceiveFromISR+0x50>
				{
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1e62:	ce 01       	movw	r24, r28
    1e64:	08 96       	adiw	r24, 0x08	; 8
    1e66:	0e 94 71 11 	call	0x22e2	; 0x22e2 <xCoRoutineRemoveFromEventList>
    1e6a:	88 23       	and	r24, r24
    1e6c:	a9 f3       	breq	.-22     	; 0x1e58 <xQueueCRReceiveFromISR+0x50>
					{
						*pxCoRoutineWoken = pdTRUE;
    1e6e:	81 e0       	ldi	r24, 0x01	; 1
    1e70:	f8 01       	movw	r30, r16
    1e72:	80 83       	st	Z, r24
    1e74:	01 c0       	rjmp	.+2      	; 0x1e78 <xQueueCRReceiveFromISR+0x70>

			xReturn = pdPASS;
		}
		else
		{
			xReturn = pdFAIL;
    1e76:	80 e0       	ldi	r24, 0x00	; 0
		}

		return xReturn;
	}
    1e78:	df 91       	pop	r29
    1e7a:	cf 91       	pop	r28
    1e7c:	1f 91       	pop	r17
    1e7e:	0f 91       	pop	r16
    1e80:	08 95       	ret

00001e82 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    1e82:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1e84:	03 96       	adiw	r24, 0x03	; 3
    1e86:	92 83       	std	Z+2, r25	; 0x02
    1e88:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1e8a:	2f ef       	ldi	r18, 0xFF	; 255
    1e8c:	3f ef       	ldi	r19, 0xFF	; 255
    1e8e:	34 83       	std	Z+4, r19	; 0x04
    1e90:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1e92:	96 83       	std	Z+6, r25	; 0x06
    1e94:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1e96:	90 87       	std	Z+8, r25	; 0x08
    1e98:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    1e9a:	10 82       	st	Z, r1
    1e9c:	08 95       	ret

00001e9e <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    1e9e:	fc 01       	movw	r30, r24
    1ea0:	11 86       	std	Z+9, r1	; 0x09
    1ea2:	10 86       	std	Z+8, r1	; 0x08
    1ea4:	08 95       	ret

00001ea6 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1ea6:	cf 93       	push	r28
    1ea8:	df 93       	push	r29
    1eaa:	9c 01       	movw	r18, r24
    1eac:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    1eae:	dc 01       	movw	r26, r24
    1eb0:	11 96       	adiw	r26, 0x01	; 1
    1eb2:	cd 91       	ld	r28, X+
    1eb4:	dc 91       	ld	r29, X
    1eb6:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    1eb8:	d3 83       	std	Z+3, r29	; 0x03
    1eba:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    1ebc:	8c 81       	ldd	r24, Y+4	; 0x04
    1ebe:	9d 81       	ldd	r25, Y+5	; 0x05
    1ec0:	95 83       	std	Z+5, r25	; 0x05
    1ec2:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    1ec4:	8c 81       	ldd	r24, Y+4	; 0x04
    1ec6:	9d 81       	ldd	r25, Y+5	; 0x05
    1ec8:	dc 01       	movw	r26, r24
    1eca:	13 96       	adiw	r26, 0x03	; 3
    1ecc:	7c 93       	st	X, r23
    1ece:	6e 93       	st	-X, r22
    1ed0:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
    1ed2:	7d 83       	std	Y+5, r23	; 0x05
    1ed4:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1ed6:	31 87       	std	Z+9, r19	; 0x09
    1ed8:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    1eda:	f9 01       	movw	r30, r18
    1edc:	80 81       	ld	r24, Z
    1ede:	8f 5f       	subi	r24, 0xFF	; 255
    1ee0:	80 83       	st	Z, r24
}
    1ee2:	df 91       	pop	r29
    1ee4:	cf 91       	pop	r28
    1ee6:	08 95       	ret

00001ee8 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1ee8:	0f 93       	push	r16
    1eea:	1f 93       	push	r17
    1eec:	cf 93       	push	r28
    1eee:	df 93       	push	r29
    1ef0:	8c 01       	movw	r16, r24
    1ef2:	fb 01       	movw	r30, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    1ef4:	80 81       	ld	r24, Z
    1ef6:	91 81       	ldd	r25, Z+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1ef8:	8f 3f       	cpi	r24, 0xFF	; 255
    1efa:	2f ef       	ldi	r18, 0xFF	; 255
    1efc:	92 07       	cpc	r25, r18
    1efe:	21 f4       	brne	.+8      	; 0x1f08 <vListInsert+0x20>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    1f00:	e8 01       	movw	r28, r16
    1f02:	af 81       	ldd	r26, Y+7	; 0x07
    1f04:	b8 85       	ldd	r27, Y+8	; 0x08
    1f06:	0e c0       	rjmp	.+28     	; 0x1f24 <vListInsert+0x3c>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1f08:	d8 01       	movw	r26, r16
    1f0a:	13 96       	adiw	r26, 0x03	; 3
    1f0c:	12 96       	adiw	r26, 0x02	; 2
    1f0e:	2d 91       	ld	r18, X+
    1f10:	3c 91       	ld	r19, X
    1f12:	13 97       	sbiw	r26, 0x03	; 3
    1f14:	e9 01       	movw	r28, r18
    1f16:	48 81       	ld	r20, Y
    1f18:	59 81       	ldd	r21, Y+1	; 0x01
    1f1a:	84 17       	cp	r24, r20
    1f1c:	95 07       	cpc	r25, r21
    1f1e:	10 f0       	brcs	.+4      	; 0x1f24 <vListInsert+0x3c>
    1f20:	d9 01       	movw	r26, r18
    1f22:	f4 cf       	rjmp	.-24     	; 0x1f0c <vListInsert+0x24>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    1f24:	12 96       	adiw	r26, 0x02	; 2
    1f26:	8d 91       	ld	r24, X+
    1f28:	9c 91       	ld	r25, X
    1f2a:	13 97       	sbiw	r26, 0x03	; 3
    1f2c:	93 83       	std	Z+3, r25	; 0x03
    1f2e:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    1f30:	ec 01       	movw	r28, r24
    1f32:	fd 83       	std	Y+5, r31	; 0x05
    1f34:	ec 83       	std	Y+4, r30	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    1f36:	b5 83       	std	Z+5, r27	; 0x05
    1f38:	a4 83       	std	Z+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
    1f3a:	13 96       	adiw	r26, 0x03	; 3
    1f3c:	fc 93       	st	X, r31
    1f3e:	ee 93       	st	-X, r30
    1f40:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1f42:	11 87       	std	Z+9, r17	; 0x09
    1f44:	00 87       	std	Z+8, r16	; 0x08

	( pxList->uxNumberOfItems )++;
    1f46:	f8 01       	movw	r30, r16
    1f48:	80 81       	ld	r24, Z
    1f4a:	8f 5f       	subi	r24, 0xFF	; 255
    1f4c:	80 83       	st	Z, r24
}
    1f4e:	df 91       	pop	r29
    1f50:	cf 91       	pop	r28
    1f52:	1f 91       	pop	r17
    1f54:	0f 91       	pop	r16
    1f56:	08 95       	ret

00001f58 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    1f58:	cf 93       	push	r28
    1f5a:	df 93       	push	r29
    1f5c:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
    1f5e:	a0 85       	ldd	r26, Z+8	; 0x08
    1f60:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1f62:	82 81       	ldd	r24, Z+2	; 0x02
    1f64:	93 81       	ldd	r25, Z+3	; 0x03
    1f66:	24 81       	ldd	r18, Z+4	; 0x04
    1f68:	35 81       	ldd	r19, Z+5	; 0x05
    1f6a:	ec 01       	movw	r28, r24
    1f6c:	3d 83       	std	Y+5, r19	; 0x05
    1f6e:	2c 83       	std	Y+4, r18	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1f70:	c4 81       	ldd	r28, Z+4	; 0x04
    1f72:	d5 81       	ldd	r29, Z+5	; 0x05
    1f74:	9b 83       	std	Y+3, r25	; 0x03
    1f76:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1f78:	11 96       	adiw	r26, 0x01	; 1
    1f7a:	8d 91       	ld	r24, X+
    1f7c:	9c 91       	ld	r25, X
    1f7e:	12 97       	sbiw	r26, 0x02	; 2
    1f80:	8e 17       	cp	r24, r30
    1f82:	9f 07       	cpc	r25, r31
    1f84:	21 f4       	brne	.+8      	; 0x1f8e <uxListRemove+0x36>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1f86:	12 96       	adiw	r26, 0x02	; 2
    1f88:	dc 93       	st	X, r29
    1f8a:	ce 93       	st	-X, r28
    1f8c:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
    1f8e:	11 86       	std	Z+9, r1	; 0x09
    1f90:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    1f92:	8c 91       	ld	r24, X
    1f94:	81 50       	subi	r24, 0x01	; 1
    1f96:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
    1f98:	8c 91       	ld	r24, X
}
    1f9a:	df 91       	pop	r29
    1f9c:	cf 91       	pop	r28
    1f9e:	08 95       	ret

00001fa0 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

BaseType_t xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, UBaseType_t uxPriority, UBaseType_t uxIndex )
{
    1fa0:	cf 92       	push	r12
    1fa2:	df 92       	push	r13
    1fa4:	ef 92       	push	r14
    1fa6:	ff 92       	push	r15
    1fa8:	1f 93       	push	r17
    1faa:	cf 93       	push	r28
    1fac:	df 93       	push	r29
    1fae:	6c 01       	movw	r12, r24
    1fb0:	16 2f       	mov	r17, r22
    1fb2:	f4 2e       	mov	r15, r20
BaseType_t xReturn;
CRCB_t *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( CRCB_t * ) pvPortMalloc( sizeof( CRCB_t ) );
    1fb4:	8a e1       	ldi	r24, 0x1A	; 26
    1fb6:	90 e0       	ldi	r25, 0x00	; 0
    1fb8:	0e 94 da 11 	call	0x23b4	; 0x23b4 <pvPortMalloc>
    1fbc:	ec 01       	movw	r28, r24
	if( pxCoRoutine )
    1fbe:	89 2b       	or	r24, r25
    1fc0:	09 f4       	brne	.+2      	; 0x1fc4 <xCoRoutineCreate+0x24>
    1fc2:	57 c0       	rjmp	.+174    	; 0x2072 <xCoRoutineCreate+0xd2>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
    1fc4:	80 91 b3 01 	lds	r24, 0x01B3
    1fc8:	90 91 b4 01 	lds	r25, 0x01B4
    1fcc:	89 2b       	or	r24, r25
    1fce:	21 f5       	brne	.+72     	; 0x2018 <xCoRoutineCreate+0x78>
		{
			pxCurrentCoRoutine = pxCoRoutine;
    1fd0:	d0 93 b4 01 	sts	0x01B4, r29
    1fd4:	c0 93 b3 01 	sts	0x01B3, r28
{
UBaseType_t uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( List_t * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    1fd8:	8b ed       	ldi	r24, 0xDB	; 219
    1fda:	91 e0       	ldi	r25, 0x01	; 1
    1fdc:	0e 94 41 0f 	call	0x1e82	; 0x1e82 <vListInitialise>
    1fe0:	84 ee       	ldi	r24, 0xE4	; 228
    1fe2:	91 e0       	ldi	r25, 0x01	; 1
    1fe4:	0e 94 41 0f 	call	0x1e82	; 0x1e82 <vListInitialise>
	}

	vListInitialise( ( List_t * ) &xDelayedCoRoutineList1 );
    1fe8:	82 ed       	ldi	r24, 0xD2	; 210
    1fea:	91 e0       	ldi	r25, 0x01	; 1
    1fec:	0e 94 41 0f 	call	0x1e82	; 0x1e82 <vListInitialise>
	vListInitialise( ( List_t * ) &xDelayedCoRoutineList2 );
    1ff0:	89 ec       	ldi	r24, 0xC9	; 201
    1ff2:	91 e0       	ldi	r25, 0x01	; 1
    1ff4:	0e 94 41 0f 	call	0x1e82	; 0x1e82 <vListInitialise>
	vListInitialise( ( List_t * ) &xPendingReadyCoRoutineList );
    1ff8:	8c eb       	ldi	r24, 0xBC	; 188
    1ffa:	91 e0       	ldi	r25, 0x01	; 1
    1ffc:	0e 94 41 0f 	call	0x1e82	; 0x1e82 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    2000:	82 ed       	ldi	r24, 0xD2	; 210
    2002:	91 e0       	ldi	r25, 0x01	; 1
    2004:	90 93 c8 01 	sts	0x01C8, r25
    2008:	80 93 c7 01 	sts	0x01C7, r24
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    200c:	89 ec       	ldi	r24, 0xC9	; 201
    200e:	91 e0       	ldi	r25, 0x01	; 1
    2010:	90 93 c6 01 	sts	0x01C6, r25
    2014:	80 93 c5 01 	sts	0x01C5, r24
    2018:	11 11       	cpse	r17, r1
    201a:	11 e0       	ldi	r17, 0x01	; 1
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
    201c:	19 8e       	std	Y+25, r1	; 0x19
    201e:	18 8e       	std	Y+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
    2020:	1e 8b       	std	Y+22, r17	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
    2022:	ff 8a       	std	Y+23, r15	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    2024:	fe 01       	movw	r30, r28
    2026:	c1 92       	st	Z+, r12
    2028:	d1 92       	st	Z+, r13
    202a:	7f 01       	movw	r14, r30

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    202c:	cf 01       	movw	r24, r30
    202e:	0e 94 4f 0f 	call	0x1e9e	; 0x1e9e <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    2032:	ce 01       	movw	r24, r28
    2034:	0c 96       	adiw	r24, 0x0c	; 12
    2036:	0e 94 4f 0f 	call	0x1e9e	; 0x1e9e <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the ListItem_t.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    203a:	d9 87       	std	Y+9, r29	; 0x09
    203c:	c8 87       	std	Y+8, r28	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    203e:	db 8b       	std	Y+19, r29	; 0x13
    2040:	ca 8b       	std	Y+18, r28	; 0x12

		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), ( ( TickType_t ) configMAX_CO_ROUTINE_PRIORITIES - ( TickType_t ) uxPriority ) );
    2042:	82 e0       	ldi	r24, 0x02	; 2
    2044:	90 e0       	ldi	r25, 0x00	; 0
    2046:	81 1b       	sub	r24, r17
    2048:	91 09       	sbc	r25, r1
    204a:	9d 87       	std	Y+13, r25	; 0x0d
    204c:	8c 87       	std	Y+12, r24	; 0x0c

		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
    204e:	9e 89       	ldd	r25, Y+22	; 0x16
    2050:	80 91 bb 01 	lds	r24, 0x01BB
    2054:	89 17       	cp	r24, r25
    2056:	10 f4       	brcc	.+4      	; 0x205c <xCoRoutineCreate+0xbc>
    2058:	90 93 bb 01 	sts	0x01BB, r25
    205c:	f9 e0       	ldi	r31, 0x09	; 9
    205e:	9f 9f       	mul	r25, r31
    2060:	c0 01       	movw	r24, r0
    2062:	11 24       	eor	r1, r1
    2064:	b7 01       	movw	r22, r14
    2066:	85 52       	subi	r24, 0x25	; 37
    2068:	9e 4f       	sbci	r25, 0xFE	; 254
    206a:	0e 94 53 0f 	call	0x1ea6	; 0x1ea6 <vListInsertEnd>

		xReturn = pdPASS;
    206e:	81 e0       	ldi	r24, 0x01	; 1
    2070:	01 c0       	rjmp	.+2      	; 0x2074 <xCoRoutineCreate+0xd4>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    2072:	8f ef       	ldi	r24, 0xFF	; 255
	}

	return xReturn;
}
    2074:	df 91       	pop	r29
    2076:	cf 91       	pop	r28
    2078:	1f 91       	pop	r17
    207a:	ff 90       	pop	r15
    207c:	ef 90       	pop	r14
    207e:	df 90       	pop	r13
    2080:	cf 90       	pop	r12
    2082:	08 95       	ret

00002084 <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( TickType_t xTicksToDelay, List_t *pxEventList )
{
    2084:	0f 93       	push	r16
    2086:	1f 93       	push	r17
    2088:	cf 93       	push	r28
    208a:	df 93       	push	r29
    208c:	8b 01       	movw	r16, r22
TickType_t xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    208e:	c0 91 b9 01 	lds	r28, 0x01B9
    2092:	d0 91 ba 01 	lds	r29, 0x01BA
    2096:	c8 0f       	add	r28, r24
    2098:	d9 1f       	adc	r29, r25

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	( void ) uxListRemove( ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    209a:	80 91 b3 01 	lds	r24, 0x01B3
    209e:	90 91 b4 01 	lds	r25, 0x01B4
    20a2:	02 96       	adiw	r24, 0x02	; 2
    20a4:	0e 94 ac 0f 	call	0x1f58	; 0x1f58 <uxListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    20a8:	e0 91 b3 01 	lds	r30, 0x01B3
    20ac:	f0 91 b4 01 	lds	r31, 0x01B4
    20b0:	d3 83       	std	Z+3, r29	; 0x03
    20b2:	c2 83       	std	Z+2, r28	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
    20b4:	80 91 b9 01 	lds	r24, 0x01B9
    20b8:	90 91 ba 01 	lds	r25, 0x01BA
    20bc:	bf 01       	movw	r22, r30
    20be:	6e 5f       	subi	r22, 0xFE	; 254
    20c0:	7f 4f       	sbci	r23, 0xFF	; 255
    20c2:	c8 17       	cp	r28, r24
    20c4:	d9 07       	cpc	r29, r25
    20c6:	28 f4       	brcc	.+10     	; 0x20d2 <vCoRoutineAddToDelayedList+0x4e>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( List_t * ) pxOverflowDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    20c8:	80 91 c5 01 	lds	r24, 0x01C5
    20cc:	90 91 c6 01 	lds	r25, 0x01C6
    20d0:	04 c0       	rjmp	.+8      	; 0x20da <vCoRoutineAddToDelayedList+0x56>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( List_t * ) pxDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    20d2:	80 91 c7 01 	lds	r24, 0x01C7
    20d6:	90 91 c8 01 	lds	r25, 0x01C8
    20da:	0e 94 74 0f 	call	0x1ee8	; 0x1ee8 <vListInsert>
	}

	if( pxEventList )
    20de:	01 15       	cp	r16, r1
    20e0:	11 05       	cpc	r17, r1
    20e2:	69 f0       	breq	.+26     	; 0x20fe <vCoRoutineAddToDelayedList+0x7a>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    20e4:	60 91 b3 01 	lds	r22, 0x01B3
    20e8:	70 91 b4 01 	lds	r23, 0x01B4
    20ec:	64 5f       	subi	r22, 0xF4	; 244
    20ee:	7f 4f       	sbci	r23, 0xFF	; 255
    20f0:	c8 01       	movw	r24, r16
	}
}
    20f2:	df 91       	pop	r29
    20f4:	cf 91       	pop	r28
    20f6:	1f 91       	pop	r17
    20f8:	0f 91       	pop	r16

	if( pxEventList )
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    20fa:	0c 94 74 0f 	jmp	0x1ee8	; 0x1ee8 <vListInsert>
	}
}
    20fe:	df 91       	pop	r29
    2100:	cf 91       	pop	r28
    2102:	1f 91       	pop	r17
    2104:	0f 91       	pop	r16
    2106:	08 95       	ret

00002108 <vCoRoutineSchedule>:
	xLastTickCount = xCoRoutineTickCount;
}
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    2108:	ff 92       	push	r15
    210a:	0f 93       	push	r16
    210c:	1f 93       	push	r17
    210e:	cf 93       	push	r28
    2110:	df 93       	push	r29
			( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
		}
		portENABLE_INTERRUPTS();

		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
    2112:	99 e0       	ldi	r25, 0x09	; 9
    2114:	f9 2e       	mov	r15, r25
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    2116:	80 91 bc 01 	lds	r24, 0x01BC
    211a:	88 23       	and	r24, r24
    211c:	11 f1       	breq	.+68     	; 0x2162 <vCoRoutineSchedule+0x5a>
	{
		CRCB_t *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    211e:	f8 94       	cli
		{
			pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );
    2120:	e0 91 c1 01 	lds	r30, 0x01C1
    2124:	f0 91 c2 01 	lds	r31, 0x01C2
    2128:	c6 81       	ldd	r28, Z+6	; 0x06
    212a:	d7 81       	ldd	r29, Z+7	; 0x07
			( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    212c:	ce 01       	movw	r24, r28
    212e:	0c 96       	adiw	r24, 0x0c	; 12
    2130:	0e 94 ac 0f 	call	0x1f58	; 0x1f58 <uxListRemove>
		}
		portENABLE_INTERRUPTS();
    2134:	78 94       	sei

		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    2136:	8e 01       	movw	r16, r28
    2138:	0e 5f       	subi	r16, 0xFE	; 254
    213a:	1f 4f       	sbci	r17, 0xFF	; 255
    213c:	c8 01       	movw	r24, r16
    213e:	0e 94 ac 0f 	call	0x1f58	; 0x1f58 <uxListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
    2142:	9e 89       	ldd	r25, Y+22	; 0x16
    2144:	80 91 bb 01 	lds	r24, 0x01BB
    2148:	89 17       	cp	r24, r25
    214a:	10 f4       	brcc	.+4      	; 0x2150 <vCoRoutineSchedule+0x48>
    214c:	90 93 bb 01 	sts	0x01BB, r25
    2150:	f9 9e       	mul	r15, r25
    2152:	c0 01       	movw	r24, r0
    2154:	11 24       	eor	r1, r1
    2156:	b8 01       	movw	r22, r16
    2158:	85 52       	subi	r24, 0x25	; 37
    215a:	9e 4f       	sbci	r25, 0xFE	; 254
    215c:	0e 94 53 0f 	call	0x1ea6	; 0x1ea6 <vListInsertEnd>
    2160:	da cf       	rjmp	.-76     	; 0x2116 <vCoRoutineSchedule+0xe>

static void prvCheckDelayedList( void )
{
CRCB_t *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    2162:	0e 94 58 05 	call	0xab0	; 0xab0 <xTaskGetTickCount>
    2166:	20 91 b7 01 	lds	r18, 0x01B7
    216a:	30 91 b8 01 	lds	r19, 0x01B8
    216e:	82 1b       	sub	r24, r18
    2170:	93 0b       	sbc	r25, r19
    2172:	90 93 b6 01 	sts	0x01B6, r25
    2176:	80 93 b5 01 	sts	0x01B5, r24
					( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
				}
			}
			portENABLE_INTERRUPTS();

			prvAddCoRoutineToReadyQueue( pxCRCB );
    217a:	89 e0       	ldi	r24, 0x09	; 9
    217c:	f8 2e       	mov	r15, r24
static void prvCheckDelayedList( void )
{
CRCB_t *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    217e:	20 91 b5 01 	lds	r18, 0x01B5
    2182:	30 91 b6 01 	lds	r19, 0x01B6
    2186:	80 91 b9 01 	lds	r24, 0x01B9
    218a:	90 91 ba 01 	lds	r25, 0x01BA
    218e:	21 15       	cp	r18, r1
    2190:	31 05       	cpc	r19, r1
    2192:	09 f4       	brne	.+2      	; 0x2196 <vCoRoutineSchedule+0x8e>
    2194:	54 c0       	rjmp	.+168    	; 0x223e <vCoRoutineSchedule+0x136>
	{
		xCoRoutineTickCount++;
    2196:	01 96       	adiw	r24, 0x01	; 1
    2198:	90 93 ba 01 	sts	0x01BA, r25
    219c:	80 93 b9 01 	sts	0x01B9, r24
		xPassedTicks--;
    21a0:	21 50       	subi	r18, 0x01	; 1
    21a2:	31 09       	sbc	r19, r1
    21a4:	30 93 b6 01 	sts	0x01B6, r19
    21a8:	20 93 b5 01 	sts	0x01B5, r18

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    21ac:	89 2b       	or	r24, r25
    21ae:	09 f0       	breq	.+2      	; 0x21b2 <vCoRoutineSchedule+0xaa>
    21b0:	3e c0       	rjmp	.+124    	; 0x222e <vCoRoutineSchedule+0x126>
		{
			List_t * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    21b2:	80 91 c7 01 	lds	r24, 0x01C7
    21b6:	90 91 c8 01 	lds	r25, 0x01C8
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    21ba:	20 91 c5 01 	lds	r18, 0x01C5
    21be:	30 91 c6 01 	lds	r19, 0x01C6
    21c2:	30 93 c8 01 	sts	0x01C8, r19
    21c6:	20 93 c7 01 	sts	0x01C7, r18
			pxOverflowDelayedCoRoutineList = pxTemp;
    21ca:	90 93 c6 01 	sts	0x01C6, r25
    21ce:	80 93 c5 01 	sts	0x01C5, r24
    21d2:	2d c0       	rjmp	.+90     	; 0x222e <vCoRoutineSchedule+0x126>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    21d4:	05 80       	ldd	r0, Z+5	; 0x05
    21d6:	f6 81       	ldd	r31, Z+6	; 0x06
    21d8:	e0 2d       	mov	r30, r0
    21da:	c6 81       	ldd	r28, Z+6	; 0x06
    21dc:	d7 81       	ldd	r29, Z+7	; 0x07

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )
    21de:	20 91 b9 01 	lds	r18, 0x01B9
    21e2:	30 91 ba 01 	lds	r19, 0x01BA
    21e6:	8a 81       	ldd	r24, Y+2	; 0x02
    21e8:	9b 81       	ldd	r25, Y+3	; 0x03
    21ea:	28 17       	cp	r18, r24
    21ec:	39 07       	cpc	r19, r25
    21ee:	38 f2       	brcs	.-114    	; 0x217e <vCoRoutineSchedule+0x76>
			{
				/* Timeout not yet expired. */
				break;
			}

			portDISABLE_INTERRUPTS();
    21f0:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				( void ) uxListRemove( &( pxCRCB->xGenericListItem ) );
    21f2:	8e 01       	movw	r16, r28
    21f4:	0e 5f       	subi	r16, 0xFE	; 254
    21f6:	1f 4f       	sbci	r17, 0xFF	; 255
    21f8:	c8 01       	movw	r24, r16
    21fa:	0e 94 ac 0f 	call	0x1f58	; 0x1f58 <uxListRemove>

				/* Is the co-routine waiting on an event also? */
				if( pxCRCB->xEventListItem.pvContainer )
    21fe:	8c 89       	ldd	r24, Y+20	; 0x14
    2200:	9d 89       	ldd	r25, Y+21	; 0x15
    2202:	89 2b       	or	r24, r25
    2204:	21 f0       	breq	.+8      	; 0x220e <vCoRoutineSchedule+0x106>
				{
					( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
    2206:	ce 01       	movw	r24, r28
    2208:	0c 96       	adiw	r24, 0x0c	; 12
    220a:	0e 94 ac 0f 	call	0x1f58	; 0x1f58 <uxListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    220e:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );
    2210:	9e 89       	ldd	r25, Y+22	; 0x16
    2212:	80 91 bb 01 	lds	r24, 0x01BB
    2216:	89 17       	cp	r24, r25
    2218:	10 f4       	brcc	.+4      	; 0x221e <vCoRoutineSchedule+0x116>
    221a:	90 93 bb 01 	sts	0x01BB, r25
    221e:	f9 9e       	mul	r15, r25
    2220:	c0 01       	movw	r24, r0
    2222:	11 24       	eor	r1, r1
    2224:	b8 01       	movw	r22, r16
    2226:	85 52       	subi	r24, 0x25	; 37
    2228:	9e 4f       	sbci	r25, 0xFE	; 254
    222a:	0e 94 53 0f 	call	0x1ea6	; 0x1ea6 <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    222e:	e0 91 c7 01 	lds	r30, 0x01C7
    2232:	f0 91 c8 01 	lds	r31, 0x01C8
    2236:	80 81       	ld	r24, Z
    2238:	81 11       	cpse	r24, r1
    223a:	cc cf       	rjmp	.-104    	; 0x21d4 <vCoRoutineSchedule+0xcc>
    223c:	a0 cf       	rjmp	.-192    	; 0x217e <vCoRoutineSchedule+0x76>

			prvAddCoRoutineToReadyQueue( pxCRCB );
		}
	}

	xLastTickCount = xCoRoutineTickCount;
    223e:	90 93 b8 01 	sts	0x01B8, r25
    2242:	80 93 b7 01 	sts	0x01B7, r24
    2246:	80 91 bb 01 	lds	r24, 0x01BB

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    224a:	69 e0       	ldi	r22, 0x09	; 9
    224c:	48 2f       	mov	r20, r24
    224e:	50 e0       	ldi	r21, 0x00	; 0
    2250:	64 9f       	mul	r22, r20
    2252:	90 01       	movw	r18, r0
    2254:	65 9f       	mul	r22, r21
    2256:	30 0d       	add	r19, r0
    2258:	11 24       	eor	r1, r1
    225a:	f9 01       	movw	r30, r18
    225c:	e5 52       	subi	r30, 0x25	; 37
    225e:	fe 4f       	sbci	r31, 0xFE	; 254
    2260:	90 81       	ld	r25, Z
    2262:	91 11       	cpse	r25, r1
    2264:	0c c0       	rjmp	.+24     	; 0x227e <vCoRoutineSchedule+0x176>
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    2266:	81 11       	cpse	r24, r1
    2268:	08 c0       	rjmp	.+16     	; 0x227a <vCoRoutineSchedule+0x172>
    226a:	10 92 bb 01 	sts	0x01BB, r1

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );

	return;
}
    226e:	df 91       	pop	r29
    2270:	cf 91       	pop	r28
    2272:	1f 91       	pop	r17
    2274:	0f 91       	pop	r16
    2276:	ff 90       	pop	r15
    2278:	08 95       	ret
		if( uxTopCoRoutineReadyPriority == 0 )
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
    227a:	81 50       	subi	r24, 0x01	; 1
    227c:	e7 cf       	rjmp	.-50     	; 0x224c <vCoRoutineSchedule+0x144>
    227e:	80 93 bb 01 	sts	0x01BB, r24
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    2282:	a1 81       	ldd	r26, Z+1	; 0x01
    2284:	b2 81       	ldd	r27, Z+2	; 0x02
    2286:	12 96       	adiw	r26, 0x02	; 2
    2288:	0d 90       	ld	r0, X+
    228a:	bc 91       	ld	r27, X
    228c:	a0 2d       	mov	r26, r0
    228e:	b2 83       	std	Z+2, r27	; 0x02
    2290:	a1 83       	std	Z+1, r26	; 0x01
    2292:	22 52       	subi	r18, 0x22	; 34
    2294:	3e 4f       	sbci	r19, 0xFE	; 254
    2296:	a2 17       	cp	r26, r18
    2298:	b3 07       	cpc	r27, r19
    229a:	31 f4       	brne	.+12     	; 0x22a8 <vCoRoutineSchedule+0x1a0>
    229c:	12 96       	adiw	r26, 0x02	; 2
    229e:	8d 91       	ld	r24, X+
    22a0:	9c 91       	ld	r25, X
    22a2:	13 97       	sbiw	r26, 0x03	; 3
    22a4:	92 83       	std	Z+2, r25	; 0x02
    22a6:	81 83       	std	Z+1, r24	; 0x01
    22a8:	89 e0       	ldi	r24, 0x09	; 9
    22aa:	84 9f       	mul	r24, r20
    22ac:	f0 01       	movw	r30, r0
    22ae:	85 9f       	mul	r24, r21
    22b0:	f0 0d       	add	r31, r0
    22b2:	11 24       	eor	r1, r1
    22b4:	e5 52       	subi	r30, 0x25	; 37
    22b6:	fe 4f       	sbci	r31, 0xFE	; 254
    22b8:	01 80       	ldd	r0, Z+1	; 0x01
    22ba:	f2 81       	ldd	r31, Z+2	; 0x02
    22bc:	e0 2d       	mov	r30, r0
    22be:	86 81       	ldd	r24, Z+6	; 0x06
    22c0:	97 81       	ldd	r25, Z+7	; 0x07
    22c2:	90 93 b4 01 	sts	0x01B4, r25
    22c6:	80 93 b3 01 	sts	0x01B3, r24

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    22ca:	dc 01       	movw	r26, r24
    22cc:	ed 91       	ld	r30, X+
    22ce:	fc 91       	ld	r31, X
    22d0:	11 97       	sbiw	r26, 0x01	; 1
    22d2:	57 96       	adiw	r26, 0x17	; 23
    22d4:	6c 91       	ld	r22, X

	return;
}
    22d6:	df 91       	pop	r29
    22d8:	cf 91       	pop	r28
    22da:	1f 91       	pop	r17
    22dc:	0f 91       	pop	r16
    22de:	ff 90       	pop	r15
	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    22e0:	09 94       	ijmp

000022e2 <xCoRoutineRemoveFromEventList>:
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
}
/*-----------------------------------------------------------*/

BaseType_t xCoRoutineRemoveFromEventList( const List_t *pxEventList )
{
    22e2:	0f 93       	push	r16
    22e4:	1f 93       	push	r17
    22e6:	cf 93       	push	r28
    22e8:	df 93       	push	r29
BaseType_t xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    22ea:	dc 01       	movw	r26, r24
    22ec:	15 96       	adiw	r26, 0x05	; 5
    22ee:	ed 91       	ld	r30, X+
    22f0:	fc 91       	ld	r31, X
    22f2:	16 97       	sbiw	r26, 0x06	; 6
    22f4:	c6 81       	ldd	r28, Z+6	; 0x06
    22f6:	d7 81       	ldd	r29, Z+7	; 0x07
	( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    22f8:	8e 01       	movw	r16, r28
    22fa:	04 5f       	subi	r16, 0xF4	; 244
    22fc:	1f 4f       	sbci	r17, 0xFF	; 255
    22fe:	c8 01       	movw	r24, r16
    2300:	0e 94 ac 0f 	call	0x1f58	; 0x1f58 <uxListRemove>
	vListInsertEnd( ( List_t * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    2304:	b8 01       	movw	r22, r16
    2306:	8c eb       	ldi	r24, 0xBC	; 188
    2308:	91 e0       	ldi	r25, 0x01	; 1
    230a:	0e 94 53 0f 	call	0x1ea6	; 0x1ea6 <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    230e:	e0 91 b3 01 	lds	r30, 0x01B3
    2312:	f0 91 b4 01 	lds	r31, 0x01B4
    2316:	81 e0       	ldi	r24, 0x01	; 1
    2318:	2e 89       	ldd	r18, Y+22	; 0x16
    231a:	96 89       	ldd	r25, Z+22	; 0x16
    231c:	29 17       	cp	r18, r25
    231e:	08 f4       	brcc	.+2      	; 0x2322 <xCoRoutineRemoveFromEventList+0x40>
    2320:	80 e0       	ldi	r24, 0x00	; 0
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
    2322:	df 91       	pop	r29
    2324:	cf 91       	pop	r28
    2326:	1f 91       	pop	r17
    2328:	0f 91       	pop	r16
    232a:	08 95       	ret

0000232c <prvInsertBlockIntoFreeList>:
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
}
/*-----------------------------------------------------------*/

static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert )
{
    232c:	cf 93       	push	r28
    232e:	df 93       	push	r29
    2330:	fc 01       	movw	r30, r24
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
    2332:	a5 ef       	ldi	r26, 0xF5	; 245
    2334:	b1 e0       	ldi	r27, 0x01	; 1
    2336:	cd 91       	ld	r28, X+
    2338:	dc 91       	ld	r29, X
    233a:	11 97       	sbiw	r26, 0x01	; 1
    233c:	ce 17       	cp	r28, r30
    233e:	df 07       	cpc	r29, r31
    2340:	10 f4       	brcc	.+4      	; 0x2346 <prvInsertBlockIntoFreeList+0x1a>
    2342:	de 01       	movw	r26, r28
    2344:	f8 cf       	rjmp	.-16     	; 0x2336 <prvInsertBlockIntoFreeList+0xa>
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
    2346:	12 96       	adiw	r26, 0x02	; 2
    2348:	8d 91       	ld	r24, X+
    234a:	9c 91       	ld	r25, X
    234c:	13 97       	sbiw	r26, 0x03	; 3
    234e:	9d 01       	movw	r18, r26
    2350:	28 0f       	add	r18, r24
    2352:	39 1f       	adc	r19, r25
    2354:	2e 17       	cp	r18, r30
    2356:	3f 07       	cpc	r19, r31
    2358:	49 f4       	brne	.+18     	; 0x236c <prvInsertBlockIntoFreeList+0x40>
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
    235a:	22 81       	ldd	r18, Z+2	; 0x02
    235c:	33 81       	ldd	r19, Z+3	; 0x03
    235e:	82 0f       	add	r24, r18
    2360:	93 1f       	adc	r25, r19
    2362:	13 96       	adiw	r26, 0x03	; 3
    2364:	9c 93       	st	X, r25
    2366:	8e 93       	st	-X, r24
    2368:	12 97       	sbiw	r26, 0x02	; 2
    236a:	fd 01       	movw	r30, r26
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
    236c:	82 81       	ldd	r24, Z+2	; 0x02
    236e:	93 81       	ldd	r25, Z+3	; 0x03
    2370:	9f 01       	movw	r18, r30
    2372:	28 0f       	add	r18, r24
    2374:	39 1f       	adc	r19, r25
    2376:	2c 17       	cp	r18, r28
    2378:	3d 07       	cpc	r19, r29
    237a:	91 f4       	brne	.+36     	; 0x23a0 <prvInsertBlockIntoFreeList+0x74>
	{
		if( pxIterator->pxNextFreeBlock != pxEnd )
    237c:	20 91 f3 01 	lds	r18, 0x01F3
    2380:	30 91 f4 01 	lds	r19, 0x01F4
    2384:	c2 17       	cp	r28, r18
    2386:	d3 07       	cpc	r29, r19
    2388:	59 f0       	breq	.+22     	; 0x23a0 <prvInsertBlockIntoFreeList+0x74>
		{
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
    238a:	2a 81       	ldd	r18, Y+2	; 0x02
    238c:	3b 81       	ldd	r19, Y+3	; 0x03
    238e:	82 0f       	add	r24, r18
    2390:	93 1f       	adc	r25, r19
    2392:	93 83       	std	Z+3, r25	; 0x03
    2394:	82 83       	std	Z+2, r24	; 0x02
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
    2396:	88 81       	ld	r24, Y
    2398:	99 81       	ldd	r25, Y+1	; 0x01
    239a:	91 83       	std	Z+1, r25	; 0x01
    239c:	80 83       	st	Z, r24
    239e:	02 c0       	rjmp	.+4      	; 0x23a4 <prvInsertBlockIntoFreeList+0x78>
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
		}
	}
	else
	{
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
    23a0:	d1 83       	std	Z+1, r29	; 0x01
    23a2:	c0 83       	st	Z, r28

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
    23a4:	ae 17       	cp	r26, r30
    23a6:	bf 07       	cpc	r27, r31
    23a8:	11 f0       	breq	.+4      	; 0x23ae <prvInsertBlockIntoFreeList+0x82>
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
    23aa:	ed 93       	st	X+, r30
    23ac:	fc 93       	st	X, r31
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    23ae:	df 91       	pop	r29
    23b0:	cf 91       	pop	r28
    23b2:	08 95       	ret

000023b4 <pvPortMalloc>:
static size_t xBlockAllocatedBit = 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    23b4:	cf 92       	push	r12
    23b6:	df 92       	push	r13
    23b8:	ef 92       	push	r14
    23ba:	ff 92       	push	r15
    23bc:	0f 93       	push	r16
    23be:	1f 93       	push	r17
    23c0:	cf 93       	push	r28
    23c2:	df 93       	push	r29
    23c4:	ec 01       	movw	r28, r24
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
void *pvReturn = NULL;

	vTaskSuspendAll();
    23c6:	0e 94 52 05 	call	0xaa4	; 0xaa4 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( pxEnd == NULL )
    23ca:	80 91 f3 01 	lds	r24, 0x01F3
    23ce:	90 91 f4 01 	lds	r25, 0x01F4
    23d2:	89 2b       	or	r24, r25
    23d4:	81 f5       	brne	.+96     	; 0x2436 <pvPortMalloc+0x82>

	pucAlignedHeap = ( uint8_t * ) uxAddress;

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
    23d6:	89 ef       	ldi	r24, 0xF9	; 249
    23d8:	91 e0       	ldi	r25, 0x01	; 1
    23da:	90 93 f6 01 	sts	0x01F6, r25
    23de:	80 93 f5 01 	sts	0x01F5, r24
	xStart.xBlockSize = ( size_t ) 0;
    23e2:	10 92 f8 01 	sts	0x01F8, r1
    23e6:	10 92 f7 01 	sts	0x01F7, r1

	/* pxEnd is used to mark the end of the list of free blocks and is inserted
	at the end of the heap space. */
	uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;
	uxAddress -= xHeapStructSize;
    23ea:	21 ed       	ldi	r18, 0xD1	; 209
    23ec:	37 e0       	ldi	r19, 0x07	; 7
	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
	pxEnd = ( void * ) uxAddress;
    23ee:	30 93 f4 01 	sts	0x01F4, r19
    23f2:	20 93 f3 01 	sts	0x01F3, r18
	pxEnd->xBlockSize = 0;
    23f6:	10 92 d4 07 	sts	0x07D4, r1
    23fa:	10 92 d3 07 	sts	0x07D3, r1
	pxEnd->pxNextFreeBlock = NULL;
    23fe:	10 92 d2 07 	sts	0x07D2, r1
    2402:	10 92 d1 07 	sts	0x07D1, r1

	/* To start with there is a single free block that is sized to take up the
	entire heap space, minus the space taken by pxEnd. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
    2406:	88 ed       	ldi	r24, 0xD8	; 216
    2408:	95 e0       	ldi	r25, 0x05	; 5
    240a:	90 93 fc 01 	sts	0x01FC, r25
    240e:	80 93 fb 01 	sts	0x01FB, r24
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
    2412:	30 93 fa 01 	sts	0x01FA, r19
    2416:	20 93 f9 01 	sts	0x01F9, r18

	/* Only one block exists - and it covers the entire usable heap space. */
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
    241a:	90 93 f0 01 	sts	0x01F0, r25
    241e:	80 93 ef 01 	sts	0x01EF, r24
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
    2422:	90 93 f2 01 	sts	0x01F2, r25
    2426:	80 93 f1 01 	sts	0x01F1, r24

	/* Work out the position of the top bit in a size_t variable. */
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
    242a:	80 e0       	ldi	r24, 0x00	; 0
    242c:	90 e8       	ldi	r25, 0x80	; 128
    242e:	90 93 ee 01 	sts	0x01EE, r25
    2432:	80 93 ed 01 	sts	0x01ED, r24

		/* Check the requested block size is not so large that the top bit is
		set.  The top bit of the block size member of the BlockLink_t structure
		is used to determine who owns the block - the application or the
		kernel, so it must be free. */
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
    2436:	e0 90 ed 01 	lds	r14, 0x01ED
    243a:	f0 90 ee 01 	lds	r15, 0x01EE
    243e:	ce 01       	movw	r24, r28
    2440:	8e 21       	and	r24, r14
    2442:	9f 21       	and	r25, r15
    2444:	89 2b       	or	r24, r25
    2446:	09 f0       	breq	.+2      	; 0x244a <pvPortMalloc+0x96>
    2448:	5c c0       	rjmp	.+184    	; 0x2502 <pvPortMalloc+0x14e>
		{
			/* The wanted size is increased so it can contain a BlockLink_t
			structure in addition to the requested amount of bytes. */
			if( xWantedSize > 0 )
    244a:	20 97       	sbiw	r28, 0x00	; 0
    244c:	09 f4       	brne	.+2      	; 0x2450 <pvPortMalloc+0x9c>
    244e:	59 c0       	rjmp	.+178    	; 0x2502 <pvPortMalloc+0x14e>
			{
				xWantedSize += xHeapStructSize;
    2450:	9e 01       	movw	r18, r28
    2452:	2c 5f       	subi	r18, 0xFC	; 252
    2454:	3f 4f       	sbci	r19, 0xFF	; 255
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
    2456:	09 f4       	brne	.+2      	; 0x245a <pvPortMalloc+0xa6>
    2458:	54 c0       	rjmp	.+168    	; 0x2502 <pvPortMalloc+0x14e>
    245a:	c0 90 f1 01 	lds	r12, 0x01F1
    245e:	d0 90 f2 01 	lds	r13, 0x01F2
    2462:	c2 16       	cp	r12, r18
    2464:	d3 06       	cpc	r13, r19
    2466:	08 f4       	brcc	.+2      	; 0x246a <pvPortMalloc+0xb6>
    2468:	4c c0       	rjmp	.+152    	; 0x2502 <pvPortMalloc+0x14e>
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
				pxBlock = xStart.pxNextFreeBlock;
    246a:	c0 91 f5 01 	lds	r28, 0x01F5
    246e:	d0 91 f6 01 	lds	r29, 0x01F6

			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
    2472:	e5 ef       	ldi	r30, 0xF5	; 245
    2474:	f1 e0       	ldi	r31, 0x01	; 1
				pxBlock = xStart.pxNextFreeBlock;
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
    2476:	4a 81       	ldd	r20, Y+2	; 0x02
    2478:	5b 81       	ldd	r21, Y+3	; 0x03
    247a:	42 17       	cp	r20, r18
    247c:	53 07       	cpc	r21, r19
    247e:	40 f0       	brcs	.+16     	; 0x2490 <pvPortMalloc+0xdc>
					pxBlock = pxBlock->pxNextFreeBlock;
				}

				/* If the end marker was reached then a block of adequate size
				was	not found. */
				if( pxBlock != pxEnd )
    2480:	80 91 f3 01 	lds	r24, 0x01F3
    2484:	90 91 f4 01 	lds	r25, 0x01F4
    2488:	c8 17       	cp	r28, r24
    248a:	d9 07       	cpc	r29, r25
    248c:	41 f4       	brne	.+16     	; 0x249e <pvPortMalloc+0xea>
    248e:	39 c0       	rjmp	.+114    	; 0x2502 <pvPortMalloc+0x14e>
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
				pxBlock = xStart.pxNextFreeBlock;
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
    2490:	88 81       	ld	r24, Y
    2492:	99 81       	ldd	r25, Y+1	; 0x01
    2494:	00 97       	sbiw	r24, 0x00	; 0
    2496:	a1 f3       	breq	.-24     	; 0x2480 <pvPortMalloc+0xcc>
    2498:	fe 01       	movw	r30, r28
    249a:	ec 01       	movw	r28, r24
    249c:	ec cf       	rjmp	.-40     	; 0x2476 <pvPortMalloc+0xc2>
				was	not found. */
				if( pxBlock != pxEnd )
				{
					/* Return the memory space pointed to - jumping over the
					BlockLink_t structure at its start. */
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
    249e:	00 81       	ld	r16, Z
    24a0:	11 81       	ldd	r17, Z+1	; 0x01
    24a2:	0c 5f       	subi	r16, 0xFC	; 252
    24a4:	1f 4f       	sbci	r17, 0xFF	; 255

					/* This block is being returned for use so must be taken out
					of the list of free blocks. */
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
    24a6:	88 81       	ld	r24, Y
    24a8:	99 81       	ldd	r25, Y+1	; 0x01
    24aa:	91 83       	std	Z+1, r25	; 0x01
    24ac:	80 83       	st	Z, r24

					/* If the block is larger than required it can be split into
					two. */
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
    24ae:	42 1b       	sub	r20, r18
    24b0:	53 0b       	sbc	r21, r19
    24b2:	49 30       	cpi	r20, 0x09	; 9
    24b4:	51 05       	cpc	r21, r1
    24b6:	50 f0       	brcs	.+20     	; 0x24cc <pvPortMalloc+0x118>
					{
						/* This block is to be split into two.  Create a new
						block following the number of bytes requested. The void
						cast is used to prevent byte alignment warnings from the
						compiler. */
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
    24b8:	ce 01       	movw	r24, r28
    24ba:	82 0f       	add	r24, r18
    24bc:	93 1f       	adc	r25, r19
						configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );

						/* Calculate the sizes of two blocks split from the
						single block. */
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
    24be:	fc 01       	movw	r30, r24
    24c0:	53 83       	std	Z+3, r21	; 0x03
    24c2:	42 83       	std	Z+2, r20	; 0x02
						pxBlock->xBlockSize = xWantedSize;
    24c4:	3b 83       	std	Y+3, r19	; 0x03
    24c6:	2a 83       	std	Y+2, r18	; 0x02

						/* Insert the new block into the list of free blocks. */
						prvInsertBlockIntoFreeList( pxNewBlockLink );
    24c8:	0e 94 96 11 	call	0x232c	; 0x232c <prvInsertBlockIntoFreeList>
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					xFreeBytesRemaining -= pxBlock->xBlockSize;
    24cc:	2a 81       	ldd	r18, Y+2	; 0x02
    24ce:	3b 81       	ldd	r19, Y+3	; 0x03
    24d0:	c6 01       	movw	r24, r12
    24d2:	82 1b       	sub	r24, r18
    24d4:	93 0b       	sbc	r25, r19
    24d6:	90 93 f2 01 	sts	0x01F2, r25
    24da:	80 93 f1 01 	sts	0x01F1, r24

					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
    24de:	40 91 ef 01 	lds	r20, 0x01EF
    24e2:	50 91 f0 01 	lds	r21, 0x01F0
    24e6:	84 17       	cp	r24, r20
    24e8:	95 07       	cpc	r25, r21
    24ea:	20 f4       	brcc	.+8      	; 0x24f4 <pvPortMalloc+0x140>
					{
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
    24ec:	90 93 f0 01 	sts	0x01F0, r25
    24f0:	80 93 ef 01 	sts	0x01EF, r24
						mtCOVERAGE_TEST_MARKER();
					}

					/* The block is being returned - it is allocated and owned
					by the application and has no "next" block. */
					pxBlock->xBlockSize |= xBlockAllocatedBit;
    24f4:	e2 2a       	or	r14, r18
    24f6:	f3 2a       	or	r15, r19
    24f8:	fb 82       	std	Y+3, r15	; 0x03
    24fa:	ea 82       	std	Y+2, r14	; 0x02
					pxBlock->pxNextFreeBlock = NULL;
    24fc:	19 82       	std	Y+1, r1	; 0x01
    24fe:	18 82       	st	Y, r1
    2500:	02 c0       	rjmp	.+4      	; 0x2506 <pvPortMalloc+0x152>
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
void *pvReturn = NULL;
    2502:	00 e0       	ldi	r16, 0x00	; 0
    2504:	10 e0       	ldi	r17, 0x00	; 0
			mtCOVERAGE_TEST_MARKER();
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    2506:	0e 94 1e 06 	call	0xc3c	; 0xc3c <xTaskResumeAll>
	}
	#endif

	configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
	return pvReturn;
}
    250a:	c8 01       	movw	r24, r16
    250c:	df 91       	pop	r29
    250e:	cf 91       	pop	r28
    2510:	1f 91       	pop	r17
    2512:	0f 91       	pop	r16
    2514:	ff 90       	pop	r15
    2516:	ef 90       	pop	r14
    2518:	df 90       	pop	r13
    251a:	cf 90       	pop	r12
    251c:	08 95       	ret

0000251e <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    251e:	cf 93       	push	r28
    2520:	df 93       	push	r29
uint8_t *puc = ( uint8_t * ) pv;
BlockLink_t *pxLink;

	if( pv != NULL )
    2522:	00 97       	sbiw	r24, 0x00	; 0
    2524:	61 f1       	breq	.+88     	; 0x257e <vPortFree+0x60>

		/* Check the block is actually allocated. */
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
		configASSERT( pxLink->pxNextFreeBlock == NULL );

		if( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 )
    2526:	ec 01       	movw	r28, r24
    2528:	24 97       	sbiw	r28, 0x04	; 4
    252a:	8a 81       	ldd	r24, Y+2	; 0x02
    252c:	9b 81       	ldd	r25, Y+3	; 0x03
    252e:	20 91 ed 01 	lds	r18, 0x01ED
    2532:	30 91 ee 01 	lds	r19, 0x01EE
    2536:	a9 01       	movw	r20, r18
    2538:	48 23       	and	r20, r24
    253a:	59 23       	and	r21, r25
    253c:	45 2b       	or	r20, r21
    253e:	f9 f0       	breq	.+62     	; 0x257e <vPortFree+0x60>
		{
			if( pxLink->pxNextFreeBlock == NULL )
    2540:	48 81       	ld	r20, Y
    2542:	59 81       	ldd	r21, Y+1	; 0x01
    2544:	45 2b       	or	r20, r21
    2546:	d9 f4       	brne	.+54     	; 0x257e <vPortFree+0x60>
			{
				/* The block is being returned to the heap - it is no longer
				allocated. */
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
    2548:	20 95       	com	r18
    254a:	30 95       	com	r19
    254c:	82 23       	and	r24, r18
    254e:	93 23       	and	r25, r19
    2550:	9b 83       	std	Y+3, r25	; 0x03
    2552:	8a 83       	std	Y+2, r24	; 0x02

				vTaskSuspendAll();
    2554:	0e 94 52 05 	call	0xaa4	; 0xaa4 <vTaskSuspendAll>
				{
					/* Add this block to the list of free blocks. */
					xFreeBytesRemaining += pxLink->xBlockSize;
    2558:	20 91 f1 01 	lds	r18, 0x01F1
    255c:	30 91 f2 01 	lds	r19, 0x01F2
    2560:	8a 81       	ldd	r24, Y+2	; 0x02
    2562:	9b 81       	ldd	r25, Y+3	; 0x03
    2564:	82 0f       	add	r24, r18
    2566:	93 1f       	adc	r25, r19
    2568:	90 93 f2 01 	sts	0x01F2, r25
    256c:	80 93 f1 01 	sts	0x01F1, r24
					traceFREE( pv, pxLink->xBlockSize );
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
    2570:	ce 01       	movw	r24, r28
    2572:	0e 94 96 11 	call	0x232c	; 0x232c <prvInsertBlockIntoFreeList>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
    2576:	df 91       	pop	r29
    2578:	cf 91       	pop	r28
					/* Add this block to the list of free blocks. */
					xFreeBytesRemaining += pxLink->xBlockSize;
					traceFREE( pv, pxLink->xBlockSize );
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
				}
				( void ) xTaskResumeAll();
    257a:	0c 94 1e 06 	jmp	0xc3c	; 0xc3c <xTaskResumeAll>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
    257e:	df 91       	pop	r29
    2580:	cf 91       	pop	r28
    2582:	08 95       	ret

00002584 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return xFreeBytesRemaining;
}
    2584:	80 91 f1 01 	lds	r24, 0x01F1
    2588:	90 91 f2 01 	lds	r25, 0x01F2
    258c:	08 95       	ret

0000258e <xPortGetMinimumEverFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetMinimumEverFreeHeapSize( void )
{
	return xMinimumEverFreeBytesRemaining;
}
    258e:	80 91 ef 01 	lds	r24, 0x01EF
    2592:	90 91 f0 01 	lds	r25, 0x01F0
    2596:	08 95       	ret

00002598 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    2598:	08 95       	ret

0000259a <pxPortInitialiseStack>:
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    259a:	31 e1       	ldi	r19, 0x11	; 17
    259c:	fc 01       	movw	r30, r24
    259e:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
    25a0:	31 97       	sbiw	r30, 0x01	; 1
    25a2:	22 e2       	ldi	r18, 0x22	; 34
    25a4:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
    25a6:	31 97       	sbiw	r30, 0x01	; 1
    25a8:	a3 e3       	ldi	r26, 0x33	; 51
    25aa:	a0 83       	st	Z, r26
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    25ac:	31 97       	sbiw	r30, 0x01	; 1
    25ae:	60 83       	st	Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    25b0:	31 97       	sbiw	r30, 0x01	; 1
    25b2:	70 83       	st	Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    25b4:	31 97       	sbiw	r30, 0x01	; 1
    25b6:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    25b8:	31 97       	sbiw	r30, 0x01	; 1
    25ba:	60 e8       	ldi	r22, 0x80	; 128
    25bc:	60 83       	st	Z, r22
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    25be:	31 97       	sbiw	r30, 0x01	; 1
    25c0:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    25c2:	31 97       	sbiw	r30, 0x01	; 1
    25c4:	62 e0       	ldi	r22, 0x02	; 2
    25c6:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    25c8:	31 97       	sbiw	r30, 0x01	; 1
    25ca:	63 e0       	ldi	r22, 0x03	; 3
    25cc:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    25ce:	31 97       	sbiw	r30, 0x01	; 1
    25d0:	64 e0       	ldi	r22, 0x04	; 4
    25d2:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    25d4:	31 97       	sbiw	r30, 0x01	; 1
    25d6:	65 e0       	ldi	r22, 0x05	; 5
    25d8:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    25da:	31 97       	sbiw	r30, 0x01	; 1
    25dc:	66 e0       	ldi	r22, 0x06	; 6
    25de:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    25e0:	31 97       	sbiw	r30, 0x01	; 1
    25e2:	67 e0       	ldi	r22, 0x07	; 7
    25e4:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    25e6:	31 97       	sbiw	r30, 0x01	; 1
    25e8:	68 e0       	ldi	r22, 0x08	; 8
    25ea:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    25ec:	31 97       	sbiw	r30, 0x01	; 1
    25ee:	69 e0       	ldi	r22, 0x09	; 9
    25f0:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    25f2:	31 97       	sbiw	r30, 0x01	; 1
    25f4:	60 e1       	ldi	r22, 0x10	; 16
    25f6:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    25f8:	31 97       	sbiw	r30, 0x01	; 1
    25fa:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    25fc:	31 97       	sbiw	r30, 0x01	; 1
    25fe:	32 e1       	ldi	r19, 0x12	; 18
    2600:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    2602:	31 97       	sbiw	r30, 0x01	; 1
    2604:	33 e1       	ldi	r19, 0x13	; 19
    2606:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    2608:	31 97       	sbiw	r30, 0x01	; 1
    260a:	34 e1       	ldi	r19, 0x14	; 20
    260c:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    260e:	31 97       	sbiw	r30, 0x01	; 1
    2610:	35 e1       	ldi	r19, 0x15	; 21
    2612:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    2614:	31 97       	sbiw	r30, 0x01	; 1
    2616:	36 e1       	ldi	r19, 0x16	; 22
    2618:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    261a:	31 97       	sbiw	r30, 0x01	; 1
    261c:	37 e1       	ldi	r19, 0x17	; 23
    261e:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    2620:	31 97       	sbiw	r30, 0x01	; 1
    2622:	38 e1       	ldi	r19, 0x18	; 24
    2624:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    2626:	31 97       	sbiw	r30, 0x01	; 1
    2628:	39 e1       	ldi	r19, 0x19	; 25
    262a:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    262c:	31 97       	sbiw	r30, 0x01	; 1
    262e:	30 e2       	ldi	r19, 0x20	; 32
    2630:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    2632:	31 97       	sbiw	r30, 0x01	; 1
    2634:	31 e2       	ldi	r19, 0x21	; 33
    2636:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    2638:	31 97       	sbiw	r30, 0x01	; 1
    263a:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    263c:	31 97       	sbiw	r30, 0x01	; 1
    263e:	23 e2       	ldi	r18, 0x23	; 35
    2640:	20 83       	st	Z, r18
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2642:	31 97       	sbiw	r30, 0x01	; 1
    2644:	40 83       	st	Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2646:	31 97       	sbiw	r30, 0x01	; 1
    2648:	50 83       	st	Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    264a:	31 97       	sbiw	r30, 0x01	; 1
    264c:	26 e2       	ldi	r18, 0x26	; 38
    264e:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    2650:	31 97       	sbiw	r30, 0x01	; 1
    2652:	27 e2       	ldi	r18, 0x27	; 39
    2654:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    2656:	31 97       	sbiw	r30, 0x01	; 1
    2658:	28 e2       	ldi	r18, 0x28	; 40
    265a:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    265c:	31 97       	sbiw	r30, 0x01	; 1
    265e:	29 e2       	ldi	r18, 0x29	; 41
    2660:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    2662:	31 97       	sbiw	r30, 0x01	; 1
    2664:	20 e3       	ldi	r18, 0x30	; 48
    2666:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    2668:	31 97       	sbiw	r30, 0x01	; 1
    266a:	21 e3       	ldi	r18, 0x31	; 49
    266c:	20 83       	st	Z, r18
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
    266e:	86 97       	sbiw	r24, 0x26	; 38
    2670:	08 95       	ret

00002672 <xPortStartScheduler>:
	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	ulCompareMatch >>= 8;
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	OCR1AH = ucHighByte;
    2672:	10 92 89 00 	sts	0x0089, r1
	OCR1AL = ucLowByte;
    2676:	8c e7       	ldi	r24, 0x7C	; 124
    2678:	80 93 88 00 	sts	0x0088, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
    267c:	8b e0       	ldi	r24, 0x0B	; 11
    267e:	80 93 81 00 	sts	0x0081, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK1;
    2682:	ef e6       	ldi	r30, 0x6F	; 111
    2684:	f0 e0       	ldi	r31, 0x00	; 0
    2686:	80 81       	ld	r24, Z
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    2688:	82 60       	ori	r24, 0x02	; 2
	TIMSK1 = ucLowByte;
    268a:	80 83       	st	Z, r24
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    268c:	a0 91 56 01 	lds	r26, 0x0156
    2690:	b0 91 57 01 	lds	r27, 0x0157
    2694:	cd 91       	ld	r28, X+
    2696:	cd bf       	out	0x3d, r28	; 61
    2698:	dd 91       	ld	r29, X+
    269a:	de bf       	out	0x3e, r29	; 62
    269c:	ff 91       	pop	r31
    269e:	ef 91       	pop	r30
    26a0:	df 91       	pop	r29
    26a2:	cf 91       	pop	r28
    26a4:	bf 91       	pop	r27
    26a6:	af 91       	pop	r26
    26a8:	9f 91       	pop	r25
    26aa:	8f 91       	pop	r24
    26ac:	7f 91       	pop	r23
    26ae:	6f 91       	pop	r22
    26b0:	5f 91       	pop	r21
    26b2:	4f 91       	pop	r20
    26b4:	3f 91       	pop	r19
    26b6:	2f 91       	pop	r18
    26b8:	1f 91       	pop	r17
    26ba:	0f 91       	pop	r16
    26bc:	ff 90       	pop	r15
    26be:	ef 90       	pop	r14
    26c0:	df 90       	pop	r13
    26c2:	cf 90       	pop	r12
    26c4:	bf 90       	pop	r11
    26c6:	af 90       	pop	r10
    26c8:	9f 90       	pop	r9
    26ca:	8f 90       	pop	r8
    26cc:	7f 90       	pop	r7
    26ce:	6f 90       	pop	r6
    26d0:	5f 90       	pop	r5
    26d2:	4f 90       	pop	r4
    26d4:	3f 90       	pop	r3
    26d6:	2f 90       	pop	r2
    26d8:	1f 90       	pop	r1
    26da:	0f 90       	pop	r0
    26dc:	0f be       	out	0x3f, r0	; 63
    26de:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    26e0:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
    26e2:	81 e0       	ldi	r24, 0x01	; 1
    26e4:	08 95       	ret

000026e6 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    26e6:	08 95       	ret

000026e8 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    26e8:	0f 92       	push	r0
    26ea:	0f b6       	in	r0, 0x3f	; 63
    26ec:	f8 94       	cli
    26ee:	0f 92       	push	r0
    26f0:	1f 92       	push	r1
    26f2:	11 24       	eor	r1, r1
    26f4:	2f 92       	push	r2
    26f6:	3f 92       	push	r3
    26f8:	4f 92       	push	r4
    26fa:	5f 92       	push	r5
    26fc:	6f 92       	push	r6
    26fe:	7f 92       	push	r7
    2700:	8f 92       	push	r8
    2702:	9f 92       	push	r9
    2704:	af 92       	push	r10
    2706:	bf 92       	push	r11
    2708:	cf 92       	push	r12
    270a:	df 92       	push	r13
    270c:	ef 92       	push	r14
    270e:	ff 92       	push	r15
    2710:	0f 93       	push	r16
    2712:	1f 93       	push	r17
    2714:	2f 93       	push	r18
    2716:	3f 93       	push	r19
    2718:	4f 93       	push	r20
    271a:	5f 93       	push	r21
    271c:	6f 93       	push	r22
    271e:	7f 93       	push	r23
    2720:	8f 93       	push	r24
    2722:	9f 93       	push	r25
    2724:	af 93       	push	r26
    2726:	bf 93       	push	r27
    2728:	cf 93       	push	r28
    272a:	df 93       	push	r29
    272c:	ef 93       	push	r30
    272e:	ff 93       	push	r31
    2730:	a0 91 56 01 	lds	r26, 0x0156
    2734:	b0 91 57 01 	lds	r27, 0x0157
    2738:	0d b6       	in	r0, 0x3d	; 61
    273a:	0d 92       	st	X+, r0
    273c:	0e b6       	in	r0, 0x3e	; 62
    273e:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    2740:	0e 94 df 06 	call	0xdbe	; 0xdbe <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    2744:	a0 91 56 01 	lds	r26, 0x0156
    2748:	b0 91 57 01 	lds	r27, 0x0157
    274c:	cd 91       	ld	r28, X+
    274e:	cd bf       	out	0x3d, r28	; 61
    2750:	dd 91       	ld	r29, X+
    2752:	de bf       	out	0x3e, r29	; 62
    2754:	ff 91       	pop	r31
    2756:	ef 91       	pop	r30
    2758:	df 91       	pop	r29
    275a:	cf 91       	pop	r28
    275c:	bf 91       	pop	r27
    275e:	af 91       	pop	r26
    2760:	9f 91       	pop	r25
    2762:	8f 91       	pop	r24
    2764:	7f 91       	pop	r23
    2766:	6f 91       	pop	r22
    2768:	5f 91       	pop	r21
    276a:	4f 91       	pop	r20
    276c:	3f 91       	pop	r19
    276e:	2f 91       	pop	r18
    2770:	1f 91       	pop	r17
    2772:	0f 91       	pop	r16
    2774:	ff 90       	pop	r15
    2776:	ef 90       	pop	r14
    2778:	df 90       	pop	r13
    277a:	cf 90       	pop	r12
    277c:	bf 90       	pop	r11
    277e:	af 90       	pop	r10
    2780:	9f 90       	pop	r9
    2782:	8f 90       	pop	r8
    2784:	7f 90       	pop	r7
    2786:	6f 90       	pop	r6
    2788:	5f 90       	pop	r5
    278a:	4f 90       	pop	r4
    278c:	3f 90       	pop	r3
    278e:	2f 90       	pop	r2
    2790:	1f 90       	pop	r1
    2792:	0f 90       	pop	r0
    2794:	0f be       	out	0x3f, r0	; 63
    2796:	0f 90       	pop	r0

	asm volatile ( "ret" );
    2798:	08 95       	ret

0000279a <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    279a:	0f 92       	push	r0
    279c:	0f b6       	in	r0, 0x3f	; 63
    279e:	f8 94       	cli
    27a0:	0f 92       	push	r0
    27a2:	1f 92       	push	r1
    27a4:	11 24       	eor	r1, r1
    27a6:	2f 92       	push	r2
    27a8:	3f 92       	push	r3
    27aa:	4f 92       	push	r4
    27ac:	5f 92       	push	r5
    27ae:	6f 92       	push	r6
    27b0:	7f 92       	push	r7
    27b2:	8f 92       	push	r8
    27b4:	9f 92       	push	r9
    27b6:	af 92       	push	r10
    27b8:	bf 92       	push	r11
    27ba:	cf 92       	push	r12
    27bc:	df 92       	push	r13
    27be:	ef 92       	push	r14
    27c0:	ff 92       	push	r15
    27c2:	0f 93       	push	r16
    27c4:	1f 93       	push	r17
    27c6:	2f 93       	push	r18
    27c8:	3f 93       	push	r19
    27ca:	4f 93       	push	r20
    27cc:	5f 93       	push	r21
    27ce:	6f 93       	push	r22
    27d0:	7f 93       	push	r23
    27d2:	8f 93       	push	r24
    27d4:	9f 93       	push	r25
    27d6:	af 93       	push	r26
    27d8:	bf 93       	push	r27
    27da:	cf 93       	push	r28
    27dc:	df 93       	push	r29
    27de:	ef 93       	push	r30
    27e0:	ff 93       	push	r31
    27e2:	a0 91 56 01 	lds	r26, 0x0156
    27e6:	b0 91 57 01 	lds	r27, 0x0157
    27ea:	0d b6       	in	r0, 0x3d	; 61
    27ec:	0d 92       	st	X+, r0
    27ee:	0e b6       	in	r0, 0x3e	; 62
    27f0:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    27f2:	0e 94 72 05 	call	0xae4	; 0xae4 <xTaskIncrementTick>
    27f6:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    27f8:	0e 94 df 06 	call	0xdbe	; 0xdbe <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    27fc:	a0 91 56 01 	lds	r26, 0x0156
    2800:	b0 91 57 01 	lds	r27, 0x0157
    2804:	cd 91       	ld	r28, X+
    2806:	cd bf       	out	0x3d, r28	; 61
    2808:	dd 91       	ld	r29, X+
    280a:	de bf       	out	0x3e, r29	; 62
    280c:	ff 91       	pop	r31
    280e:	ef 91       	pop	r30
    2810:	df 91       	pop	r29
    2812:	cf 91       	pop	r28
    2814:	bf 91       	pop	r27
    2816:	af 91       	pop	r26
    2818:	9f 91       	pop	r25
    281a:	8f 91       	pop	r24
    281c:	7f 91       	pop	r23
    281e:	6f 91       	pop	r22
    2820:	5f 91       	pop	r21
    2822:	4f 91       	pop	r20
    2824:	3f 91       	pop	r19
    2826:	2f 91       	pop	r18
    2828:	1f 91       	pop	r17
    282a:	0f 91       	pop	r16
    282c:	ff 90       	pop	r15
    282e:	ef 90       	pop	r14
    2830:	df 90       	pop	r13
    2832:	cf 90       	pop	r12
    2834:	bf 90       	pop	r11
    2836:	af 90       	pop	r10
    2838:	9f 90       	pop	r9
    283a:	8f 90       	pop	r8
    283c:	7f 90       	pop	r7
    283e:	6f 90       	pop	r6
    2840:	5f 90       	pop	r5
    2842:	4f 90       	pop	r4
    2844:	3f 90       	pop	r3
    2846:	2f 90       	pop	r2
    2848:	1f 90       	pop	r1
    284a:	0f 90       	pop	r0
    284c:	0f be       	out	0x3f, r0	; 63
    284e:	0f 90       	pop	r0

	asm volatile ( "ret" );
    2850:	08 95       	ret

00002852 <__vector_11>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
    2852:	0e 94 cd 13 	call	0x279a	; 0x279a <vPortYieldFromTick>
		asm volatile ( "reti" );
    2856:	18 95       	reti

00002858 <prvFlashCoRoutine>:
	crEND();
}
/*-----------------------------------------------------------*/

static void prvFlashCoRoutine( CoRoutineHandle_t xHandle, UBaseType_t uxIndex )
{
    2858:	0f 93       	push	r16
    285a:	1f 93       	push	r17
    285c:	cf 93       	push	r28
    285e:	df 93       	push	r29
    2860:	1f 92       	push	r1
    2862:	cd b7       	in	r28, 0x3d	; 61
    2864:	de b7       	in	r29, 0x3e	; 62
    2866:	8c 01       	movw	r16, r24
static as we do not need it to maintain their state between blocks. */
BaseType_t xResult;
UBaseType_t uxLEDToFlash;

	/* Co-routines MUST start with a call to crSTART. */
	crSTART( xHandle );
    2868:	fc 01       	movw	r30, r24
    286a:	80 8d       	ldd	r24, Z+24	; 0x18
    286c:	91 8d       	ldd	r25, Z+25	; 0x19
    286e:	80 37       	cpi	r24, 0x70	; 112
    2870:	f1 e0       	ldi	r31, 0x01	; 1
    2872:	9f 07       	cpc	r25, r31
    2874:	b1 f0       	breq	.+44     	; 0x28a2 <prvFlashCoRoutine+0x4a>
    2876:	81 37       	cpi	r24, 0x71	; 113
    2878:	21 e0       	ldi	r18, 0x01	; 1
    287a:	92 07       	cpc	r25, r18
    287c:	51 f1       	breq	.+84     	; 0x28d2 <prvFlashCoRoutine+0x7a>
    287e:	89 2b       	or	r24, r25
    2880:	61 f5       	brne	.+88     	; 0x28da <prvFlashCoRoutine+0x82>
	( void ) uxIndex;

	for( ;; )
	{
		/* Block to wait for the number of the LED to flash. */
		crQUEUE_RECEIVE( xHandle, xFlashQueue, &uxLEDToFlash, portMAX_DELAY, &xResult );
    2882:	4f ef       	ldi	r20, 0xFF	; 255
    2884:	5f ef       	ldi	r21, 0xFF	; 255
    2886:	be 01       	movw	r22, r28
    2888:	6f 5f       	subi	r22, 0xFF	; 255
    288a:	7f 4f       	sbci	r23, 0xFF	; 255
    288c:	80 91 d5 07 	lds	r24, 0x07D5
    2890:	90 91 d6 07 	lds	r25, 0x07D6
    2894:	0e 94 9a 0e 	call	0x1d34	; 0x1d34 <xQueueCRReceive>
    2898:	8c 3f       	cpi	r24, 0xFC	; 252
    289a:	71 f4       	brne	.+28     	; 0x28b8 <prvFlashCoRoutine+0x60>
    289c:	80 e7       	ldi	r24, 0x70	; 112
    289e:	91 e0       	ldi	r25, 0x01	; 1
    28a0:	0f c0       	rjmp	.+30     	; 0x28c0 <prvFlashCoRoutine+0x68>
    28a2:	40 e0       	ldi	r20, 0x00	; 0
    28a4:	50 e0       	ldi	r21, 0x00	; 0
    28a6:	be 01       	movw	r22, r28
    28a8:	6f 5f       	subi	r22, 0xFF	; 255
    28aa:	7f 4f       	sbci	r23, 0xFF	; 255
    28ac:	80 91 d5 07 	lds	r24, 0x07D5
    28b0:	90 91 d6 07 	lds	r25, 0x07D6
    28b4:	0e 94 9a 0e 	call	0x1d34	; 0x1d34 <xQueueCRReceive>
    28b8:	8b 3f       	cpi	r24, 0xFB	; 251
    28ba:	31 f4       	brne	.+12     	; 0x28c8 <prvFlashCoRoutine+0x70>
    28bc:	81 e7       	ldi	r24, 0x71	; 113
    28be:	91 e0       	ldi	r25, 0x01	; 1
    28c0:	f8 01       	movw	r30, r16
    28c2:	91 8f       	std	Z+25, r25	; 0x19
    28c4:	80 8f       	std	Z+24, r24	; 0x18
    28c6:	09 c0       	rjmp	.+18     	; 0x28da <prvFlashCoRoutine+0x82>

		if( xResult != pdPASS )
    28c8:	81 30       	cpi	r24, 0x01	; 1
    28ca:	19 f0       	breq	.+6      	; 0x28d2 <prvFlashCoRoutine+0x7a>
		{
			/* We would not expect to wake unless we received something. */
			xCoRoutineFlashStatus = pdFAIL;
    28cc:	10 92 05 01 	sts	0x0105, r1
    28d0:	d8 cf       	rjmp	.-80     	; 0x2882 <prvFlashCoRoutine+0x2a>
		}
		else
		{
			/* We received the number of an LED to flash - flash it! */
			vParTestToggleLED( uxLEDToFlash );
    28d2:	89 81       	ldd	r24, Y+1	; 0x01
    28d4:	0e 94 ba 00 	call	0x174	; 0x174 <vParTestToggleLED>
    28d8:	d4 cf       	rjmp	.-88     	; 0x2882 <prvFlashCoRoutine+0x2a>
		}
	}

	/* Co-routines MUST end with a call to crEND. */
	crEND();
}
    28da:	0f 90       	pop	r0
    28dc:	df 91       	pop	r29
    28de:	cf 91       	pop	r28
    28e0:	1f 91       	pop	r17
    28e2:	0f 91       	pop	r16
    28e4:	08 95       	ret

000028e6 <prvFixedDelayCoRoutine>:
	}
}
/*-----------------------------------------------------------*/

static void prvFixedDelayCoRoutine( CoRoutineHandle_t xHandle, UBaseType_t uxIndex )
{
    28e6:	0f 93       	push	r16
    28e8:	1f 93       	push	r17
    28ea:	cf 93       	push	r28
    28ec:	df 93       	push	r29
    28ee:	1f 92       	push	r1
    28f0:	cd b7       	in	r28, 0x3d	; 61
    28f2:	de b7       	in	r29, 0x3e	; 62
    28f4:	8c 01       	movw	r16, r24
    28f6:	69 83       	std	Y+1, r22	; 0x01
																400 / portTICK_PERIOD_MS,
																450 / portTICK_PERIOD_MS,
																500  / portTICK_PERIOD_MS };

	/* Co-routines MUST start with a call to crSTART. */
	crSTART( xHandle );
    28f8:	fc 01       	movw	r30, r24
    28fa:	20 8d       	ldd	r18, Z+24	; 0x18
    28fc:	31 8d       	ldd	r19, Z+25	; 0x19
    28fe:	20 33       	cpi	r18, 0x30	; 48
    2900:	f1 e0       	ldi	r31, 0x01	; 1
    2902:	3f 07       	cpc	r19, r31
    2904:	d9 f0       	breq	.+54     	; 0x293c <prvFixedDelayCoRoutine+0x56>
    2906:	18 f4       	brcc	.+6      	; 0x290e <prvFixedDelayCoRoutine+0x28>
    2908:	23 2b       	or	r18, r19
    290a:	41 f0       	breq	.+16     	; 0x291c <prvFixedDelayCoRoutine+0x36>
    290c:	3e c0       	rjmp	.+124    	; 0x298a <prvFixedDelayCoRoutine+0xa4>
    290e:	21 33       	cpi	r18, 0x31	; 49
    2910:	e1 e0       	ldi	r30, 0x01	; 1
    2912:	3e 07       	cpc	r19, r30
    2914:	39 f1       	breq	.+78     	; 0x2964 <prvFixedDelayCoRoutine+0x7e>
    2916:	24 34       	cpi	r18, 0x44	; 68
    2918:	31 40       	sbci	r19, 0x01	; 1
    291a:	b9 f5       	brne	.+110    	; 0x298a <prvFixedDelayCoRoutine+0xa4>

	for( ;; )
	{
		/* Post our uxIndex value onto the queue.  This is used as the LED to
		flash. */
		crQUEUE_SEND( xHandle, xFlashQueue, ( void * ) &uxIndex, crfPOSTING_BLOCK_TIME, &xResult );
    291c:	40 e0       	ldi	r20, 0x00	; 0
    291e:	50 e0       	ldi	r21, 0x00	; 0
    2920:	be 01       	movw	r22, r28
    2922:	6f 5f       	subi	r22, 0xFF	; 255
    2924:	7f 4f       	sbci	r23, 0xFF	; 255
    2926:	80 91 d5 07 	lds	r24, 0x07D5
    292a:	90 91 d6 07 	lds	r25, 0x07D6
    292e:	0e 94 63 0e 	call	0x1cc6	; 0x1cc6 <xQueueCRSend>
    2932:	8c 3f       	cpi	r24, 0xFC	; 252
    2934:	71 f4       	brne	.+28     	; 0x2952 <prvFixedDelayCoRoutine+0x6c>
    2936:	80 e3       	ldi	r24, 0x30	; 48
    2938:	91 e0       	ldi	r25, 0x01	; 1
    293a:	24 c0       	rjmp	.+72     	; 0x2984 <prvFixedDelayCoRoutine+0x9e>
    293c:	40 e0       	ldi	r20, 0x00	; 0
    293e:	50 e0       	ldi	r21, 0x00	; 0
    2940:	be 01       	movw	r22, r28
    2942:	6f 5f       	subi	r22, 0xFF	; 255
    2944:	7f 4f       	sbci	r23, 0xFF	; 255
    2946:	80 91 d5 07 	lds	r24, 0x07D5
    294a:	90 91 d6 07 	lds	r25, 0x07D6
    294e:	0e 94 63 0e 	call	0x1cc6	; 0x1cc6 <xQueueCRSend>
    2952:	8b 3f       	cpi	r24, 0xFB	; 251
    2954:	19 f4       	brne	.+6      	; 0x295c <prvFixedDelayCoRoutine+0x76>
    2956:	81 e3       	ldi	r24, 0x31	; 49
    2958:	91 e0       	ldi	r25, 0x01	; 1
    295a:	14 c0       	rjmp	.+40     	; 0x2984 <prvFixedDelayCoRoutine+0x9e>

		if( xResult != pdPASS )
    295c:	81 30       	cpi	r24, 0x01	; 1
    295e:	11 f0       	breq	.+4      	; 0x2964 <prvFixedDelayCoRoutine+0x7e>
		{
			/* For the reasons stated at the top of the file we should always
			find that we can post to the queue.  If we could not then an error
			has occurred. */
			xCoRoutineFlashStatus = pdFAIL;
    2960:	10 92 05 01 	sts	0x0105, r1
		}

		crDELAY( xHandle, xFlashRates[ uxIndex ] );
    2964:	e9 81       	ldd	r30, Y+1	; 0x01
    2966:	f0 e0       	ldi	r31, 0x00	; 0
    2968:	ee 0f       	add	r30, r30
    296a:	ff 1f       	adc	r31, r31
    296c:	ea 5f       	subi	r30, 0xFA	; 250
    296e:	fe 4f       	sbci	r31, 0xFE	; 254
    2970:	80 81       	ld	r24, Z
    2972:	91 81       	ldd	r25, Z+1	; 0x01
    2974:	00 97       	sbiw	r24, 0x00	; 0
    2976:	21 f0       	breq	.+8      	; 0x2980 <prvFixedDelayCoRoutine+0x9a>
    2978:	60 e0       	ldi	r22, 0x00	; 0
    297a:	70 e0       	ldi	r23, 0x00	; 0
    297c:	0e 94 42 10 	call	0x2084	; 0x2084 <vCoRoutineAddToDelayedList>
    2980:	84 e4       	ldi	r24, 0x44	; 68
    2982:	91 e0       	ldi	r25, 0x01	; 1
    2984:	f8 01       	movw	r30, r16
    2986:	91 8f       	std	Z+25, r25	; 0x19
    2988:	80 8f       	std	Z+24, r24	; 0x18
	}

	/* Co-routines MUST end with a call to crEND. */
	crEND();
}
    298a:	0f 90       	pop	r0
    298c:	df 91       	pop	r29
    298e:	cf 91       	pop	r28
    2990:	1f 91       	pop	r17
    2992:	0f 91       	pop	r16
    2994:	08 95       	ret

00002996 <vStartFlashCoRoutines>:

/*
 * See the header file for details.
 */
void vStartFlashCoRoutines( UBaseType_t uxNumberToCreate )
{
    2996:	cf 93       	push	r28
    2998:	df 93       	push	r29
    299a:	d8 2f       	mov	r29, r24
    299c:	89 30       	cpi	r24, 0x09	; 9
    299e:	08 f0       	brcs	.+2      	; 0x29a2 <vStartFlashCoRoutines+0xc>
    29a0:	d8 e0       	ldi	r29, 0x08	; 8
	{
		uxNumberToCreate = crfMAX_FLASH_TASKS;
	}

	/* Create the queue used to pass data between the co-routines. */
	xFlashQueue = xQueueCreate( crfQUEUE_LENGTH, sizeof( UBaseType_t ) );
    29a2:	40 e0       	ldi	r20, 0x00	; 0
    29a4:	61 e0       	ldi	r22, 0x01	; 1
    29a6:	81 e0       	ldi	r24, 0x01	; 1
    29a8:	0e 94 35 0b 	call	0x166a	; 0x166a <xQueueGenericCreate>
    29ac:	90 93 d6 07 	sts	0x07D6, r25
    29b0:	80 93 d5 07 	sts	0x07D5, r24

	if( xFlashQueue )
    29b4:	89 2b       	or	r24, r25
    29b6:	99 f0       	breq	.+38     	; 0x29de <vStartFlashCoRoutines+0x48>
    29b8:	c0 e0       	ldi	r28, 0x00	; 0
	{
		/* Create uxNumberToCreate 'fixed delay' co-routines. */
		for( uxIndex = 0; uxIndex < uxNumberToCreate; uxIndex++ )
    29ba:	cd 17       	cp	r28, r29
    29bc:	41 f0       	breq	.+16     	; 0x29ce <vStartFlashCoRoutines+0x38>
		{
			xCoRoutineCreate( prvFixedDelayCoRoutine, crfFIXED_DELAY_PRIORITY, uxIndex );
    29be:	4c 2f       	mov	r20, r28
    29c0:	60 e0       	ldi	r22, 0x00	; 0
    29c2:	83 e7       	ldi	r24, 0x73	; 115
    29c4:	94 e1       	ldi	r25, 0x14	; 20
    29c6:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <xCoRoutineCreate>
	xFlashQueue = xQueueCreate( crfQUEUE_LENGTH, sizeof( UBaseType_t ) );

	if( xFlashQueue )
	{
		/* Create uxNumberToCreate 'fixed delay' co-routines. */
		for( uxIndex = 0; uxIndex < uxNumberToCreate; uxIndex++ )
    29ca:	cf 5f       	subi	r28, 0xFF	; 255
    29cc:	f6 cf       	rjmp	.-20     	; 0x29ba <vStartFlashCoRoutines+0x24>
		{
			xCoRoutineCreate( prvFixedDelayCoRoutine, crfFIXED_DELAY_PRIORITY, uxIndex );
		}

		/* Create the 'flash' co-routine. */
		xCoRoutineCreate( prvFlashCoRoutine, crfFLASH_PRIORITY, crfFLASH_INDEX );
    29ce:	40 e0       	ldi	r20, 0x00	; 0
    29d0:	61 e0       	ldi	r22, 0x01	; 1
    29d2:	8c e2       	ldi	r24, 0x2C	; 44
    29d4:	94 e1       	ldi	r25, 0x14	; 20
	}
}
    29d6:	df 91       	pop	r29
    29d8:	cf 91       	pop	r28
		{
			xCoRoutineCreate( prvFixedDelayCoRoutine, crfFIXED_DELAY_PRIORITY, uxIndex );
		}

		/* Create the 'flash' co-routine. */
		xCoRoutineCreate( prvFlashCoRoutine, crfFLASH_PRIORITY, crfFLASH_INDEX );
    29da:	0c 94 d0 0f 	jmp	0x1fa0	; 0x1fa0 <xCoRoutineCreate>
	}
}
    29de:	df 91       	pop	r29
    29e0:	cf 91       	pop	r28
    29e2:	08 95       	ret

000029e4 <xAreFlashCoRoutinesStillRunning>:
BaseType_t xAreFlashCoRoutinesStillRunning( void )
{
	/* Return pdPASS or pdFAIL depending on whether an error has been detected
	or not. */
	return xCoRoutineFlashStatus;
}
    29e4:	80 91 05 01 	lds	r24, 0x0105
    29e8:	08 95       	ret

000029ea <vCompeteingIntMathTask>:
	}
}
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vCompeteingIntMathTask, pvParameters )
{
    29ea:	cf 93       	push	r28
    29ec:	df 93       	push	r29
    29ee:	00 d0       	rcall	.+0      	; 0x29f0 <vCompeteingIntMathTask+0x6>
    29f0:	00 d0       	rcall	.+0      	; 0x29f2 <vCompeteingIntMathTask+0x8>
    29f2:	cd b7       	in	r28, 0x3d	; 61
    29f4:	de b7       	in	r29, 0x3e	; 62
    29f6:	7c 01       	movw	r14, r24
/* These variables are all effectively set to constants so they are volatile to
ensure the compiler does not just get rid of them. */
volatile long lValue;
short sError = pdFALSE;
    29f8:	00 e0       	ldi	r16, 0x00	; 0
    29fa:	10 e0       	ldi	r17, 0x00	; 0
	/* Keep performing a calculation and checking the result against a constant. */
	for( ;; )
	{
		/* Perform the calculation.  This will store partial value in
		registers, resulting in a good test of the context switch mechanism. */
		lValue = intgCONST1;
    29fc:	8b e7       	ldi	r24, 0x7B	; 123
    29fe:	88 2e       	mov	r8, r24
    2a00:	91 2c       	mov	r9, r1
    2a02:	a1 2c       	mov	r10, r1
    2a04:	b1 2c       	mov	r11, r1
		}
		#endif

		/* Finish off the calculation. */
		lValue *= intgCONST3;
		lValue /= intgCONST4;
    2a06:	97 e0       	ldi	r25, 0x07	; 7
    2a08:	49 2e       	mov	r4, r25
    2a0a:	51 2c       	mov	r5, r1
    2a0c:	61 2c       	mov	r6, r1
    2a0e:	71 2c       	mov	r7, r1
		{
			/* We have not encountered any errors, so set the flag that show
			we are still executing.  This will be periodically cleared by
			the check task. */
			portENTER_CRITICAL();
				*pxTaskHasExecuted = pdTRUE;
    2a10:	dd 24       	eor	r13, r13
    2a12:	d3 94       	inc	r13
	/* Keep performing a calculation and checking the result against a constant. */
	for( ;; )
	{
		/* Perform the calculation.  This will store partial value in
		registers, resulting in a good test of the context switch mechanism. */
		lValue = intgCONST1;
    2a14:	89 82       	std	Y+1, r8	; 0x01
    2a16:	9a 82       	std	Y+2, r9	; 0x02
    2a18:	ab 82       	std	Y+3, r10	; 0x03
    2a1a:	bc 82       	std	Y+4, r11	; 0x04
		lValue += intgCONST2;
    2a1c:	89 81       	ldd	r24, Y+1	; 0x01
    2a1e:	9a 81       	ldd	r25, Y+2	; 0x02
    2a20:	ab 81       	ldd	r26, Y+3	; 0x03
    2a22:	bc 81       	ldd	r27, Y+4	; 0x04
    2a24:	89 5b       	subi	r24, 0xB9	; 185
    2a26:	9b 46       	sbci	r25, 0x6B	; 107
    2a28:	ac 4f       	sbci	r26, 0xFC	; 252
    2a2a:	bf 4f       	sbci	r27, 0xFF	; 255
    2a2c:	89 83       	std	Y+1, r24	; 0x01
    2a2e:	9a 83       	std	Y+2, r25	; 0x02
    2a30:	ab 83       	std	Y+3, r26	; 0x03
    2a32:	bc 83       	std	Y+4, r27	; 0x04
			taskYIELD();
		}
		#endif

		/* Finish off the calculation. */
		lValue *= intgCONST3;
    2a34:	29 81       	ldd	r18, Y+1	; 0x01
    2a36:	3a 81       	ldd	r19, Y+2	; 0x02
    2a38:	4b 81       	ldd	r20, Y+3	; 0x03
    2a3a:	5c 81       	ldd	r21, Y+4	; 0x04
    2a3c:	ad ef       	ldi	r26, 0xFD	; 253
    2a3e:	bf ef       	ldi	r27, 0xFF	; 255
    2a40:	0e 94 4b 17 	call	0x2e96	; 0x2e96 <__mulohisi3>
    2a44:	69 83       	std	Y+1, r22	; 0x01
    2a46:	7a 83       	std	Y+2, r23	; 0x02
    2a48:	8b 83       	std	Y+3, r24	; 0x03
    2a4a:	9c 83       	std	Y+4, r25	; 0x04
		lValue /= intgCONST4;
    2a4c:	69 81       	ldd	r22, Y+1	; 0x01
    2a4e:	7a 81       	ldd	r23, Y+2	; 0x02
    2a50:	8b 81       	ldd	r24, Y+3	; 0x03
    2a52:	9c 81       	ldd	r25, Y+4	; 0x04
    2a54:	a3 01       	movw	r20, r6
    2a56:	92 01       	movw	r18, r4
    2a58:	0e 94 1e 17 	call	0x2e3c	; 0x2e3c <__divmodsi4>
    2a5c:	29 83       	std	Y+1, r18	; 0x01
    2a5e:	3a 83       	std	Y+2, r19	; 0x02
    2a60:	4b 83       	std	Y+3, r20	; 0x03
    2a62:	5c 83       	std	Y+4, r21	; 0x04

		/* If the calculation is found to be incorrect we stop setting the
		TaskHasExecuted variable so the check task can see an error has
		occurred. */
		if( lValue != intgEXPECTED_ANSWER ) /*lint !e774 volatile used to prevent this being optimised out. */
    2a64:	89 81       	ldd	r24, Y+1	; 0x01
    2a66:	9a 81       	ldd	r25, Y+2	; 0x02
    2a68:	ab 81       	ldd	r26, Y+3	; 0x03
    2a6a:	bc 81       	ldd	r27, Y+4	; 0x04
    2a6c:	8b 31       	cpi	r24, 0x1B	; 27
    2a6e:	97 47       	sbci	r25, 0x77	; 119
    2a70:	ae 4f       	sbci	r26, 0xFE	; 254
    2a72:	bf 4f       	sbci	r27, 0xFF	; 255
    2a74:	19 f0       	breq	.+6      	; 0x2a7c <vCompeteingIntMathTask+0x92>
    2a76:	01 e0       	ldi	r16, 0x01	; 1
    2a78:	10 e0       	ldi	r17, 0x00	; 0
    2a7a:	cc cf       	rjmp	.-104    	; 0x2a14 <vCompeteingIntMathTask+0x2a>
		{
			sError = pdTRUE;
		}

		if( sError == pdFALSE )
    2a7c:	01 15       	cp	r16, r1
    2a7e:	11 05       	cpc	r17, r1
    2a80:	d1 f7       	brne	.-12     	; 0x2a76 <vCompeteingIntMathTask+0x8c>
		{
			/* We have not encountered any errors, so set the flag that show
			we are still executing.  This will be periodically cleared by
			the check task. */
			portENTER_CRITICAL();
    2a82:	0f b6       	in	r0, 0x3f	; 63
    2a84:	f8 94       	cli
    2a86:	0f 92       	push	r0
				*pxTaskHasExecuted = pdTRUE;
    2a88:	f7 01       	movw	r30, r14
    2a8a:	d0 82       	st	Z, r13
			portEXIT_CRITICAL();
    2a8c:	0f 90       	pop	r0
    2a8e:	0f be       	out	0x3f, r0	; 63
    2a90:	c1 cf       	rjmp	.-126    	; 0x2a14 <vCompeteingIntMathTask+0x2a>

00002a92 <vStartIntegerMathTasks>:
static BaseType_t xTaskCheck[ intgNUMBER_OF_TASKS ] = { ( BaseType_t ) pdFALSE };

/*-----------------------------------------------------------*/

void vStartIntegerMathTasks( UBaseType_t uxPriority )
{
    2a92:	ef 92       	push	r14
    2a94:	ff 92       	push	r15
    2a96:	0f 93       	push	r16
short sTask;

	for( sTask = 0; sTask < intgNUMBER_OF_TASKS; sTask++ )
	{
		xTaskCreate( vCompeteingIntMathTask, "IntMath", intgSTACK_SIZE, ( void * ) &( xTaskCheck[ sTask ] ), uxPriority, ( TaskHandle_t * ) NULL );
    2a98:	e1 2c       	mov	r14, r1
    2a9a:	f1 2c       	mov	r15, r1
    2a9c:	08 2f       	mov	r16, r24
    2a9e:	27 ed       	ldi	r18, 0xD7	; 215
    2aa0:	37 e0       	ldi	r19, 0x07	; 7
    2aa2:	45 e5       	ldi	r20, 0x55	; 85
    2aa4:	50 e0       	ldi	r21, 0x00	; 0
    2aa6:	6b e2       	ldi	r22, 0x2B	; 43
    2aa8:	71 e0       	ldi	r23, 0x01	; 1
    2aaa:	85 ef       	ldi	r24, 0xF5	; 245
    2aac:	94 e1       	ldi	r25, 0x14	; 20
    2aae:	0e 94 d4 03 	call	0x7a8	; 0x7a8 <xTaskCreate>
	}
}
    2ab2:	0f 91       	pop	r16
    2ab4:	ff 90       	pop	r15
    2ab6:	ef 90       	pop	r14
    2ab8:	08 95       	ret

00002aba <xAreIntegerMathsTaskStillRunning>:

	/* Check the maths tasks are still running by ensuring their check variables
	are still being set to true. */
	for( sTask = 0; sTask < intgNUMBER_OF_TASKS; sTask++ )
	{
		if( xTaskCheck[ sTask ] == pdFALSE )
    2aba:	81 e0       	ldi	r24, 0x01	; 1
    2abc:	90 91 d7 07 	lds	r25, 0x07D7
    2ac0:	91 11       	cpse	r25, r1
    2ac2:	01 c0       	rjmp	.+2      	; 0x2ac6 <xAreIntegerMathsTaskStillRunning+0xc>
    2ac4:	80 e0       	ldi	r24, 0x00	; 0
			xReturn = pdFALSE;
		}

		/* Reset the check variable so we can tell if it has been set by
		the next time around. */
		xTaskCheck[ sTask ] = pdFALSE;
    2ac6:	10 92 d7 07 	sts	0x07D7, r1
	}

	return xReturn;
}
    2aca:	08 95       	ret

00002acc <vPolledQueueProducer>:
	}
}
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vPolledQueueProducer, pvParameters )
{
    2acc:	cf 93       	push	r28
    2ace:	df 93       	push	r29
    2ad0:	00 d0       	rcall	.+0      	; 0x2ad2 <vPolledQueueProducer+0x6>
    2ad2:	cd b7       	in	r28, 0x3d	; 61
    2ad4:	de b7       	in	r29, 0x3e	; 62
    2ad6:	7c 01       	movw	r14, r24
uint16_t usValue = ( uint16_t ) 0;
    2ad8:	1a 82       	std	Y+2, r1	; 0x02
    2ada:	19 82       	std	Y+1, r1	; 0x01
BaseType_t xError = pdFALSE, xLoop;
    2adc:	00 e0       	ldi	r16, 0x00	; 0
    2ade:	13 e0       	ldi	r17, 0x03	; 3
	for( ;; )
	{
		for( xLoop = 0; xLoop < pollqVALUES_TO_PRODUCE; xLoop++ )
		{
			/* Send an incrementing number on the queue without blocking. */
			if( xQueueSend( *( ( QueueHandle_t * ) pvParameters ), ( void * ) &usValue, pollqNO_DELAY ) != pdPASS )
    2ae0:	20 e0       	ldi	r18, 0x00	; 0
    2ae2:	40 e0       	ldi	r20, 0x00	; 0
    2ae4:	50 e0       	ldi	r21, 0x00	; 0
    2ae6:	be 01       	movw	r22, r28
    2ae8:	6f 5f       	subi	r22, 0xFF	; 255
    2aea:	7f 4f       	sbci	r23, 0xFF	; 255
    2aec:	f7 01       	movw	r30, r14
    2aee:	80 81       	ld	r24, Z
    2af0:	91 81       	ldd	r25, Z+1	; 0x01
    2af2:	0e 94 67 0b 	call	0x16ce	; 0x16ce <xQueueGenericSend>
    2af6:	81 30       	cpi	r24, 0x01	; 1
    2af8:	99 f4       	brne	.+38     	; 0x2b20 <vPolledQueueProducer+0x54>
				has been an error. */
				xError = pdTRUE;
			}
			else
			{
				if( xError == pdFALSE )
    2afa:	01 11       	cpse	r16, r1
    2afc:	0a c0       	rjmp	.+20     	; 0x2b12 <vPolledQueueProducer+0x46>
				{
					/* If an error has ever been recorded we stop incrementing the
					check variable. */
					portENTER_CRITICAL();
    2afe:	0f b6       	in	r0, 0x3f	; 63
    2b00:	f8 94       	cli
    2b02:	0f 92       	push	r0
						xPollingProducerCount++;
    2b04:	90 91 da 07 	lds	r25, 0x07DA
    2b08:	9f 5f       	subi	r25, 0xFF	; 255
    2b0a:	90 93 da 07 	sts	0x07DA, r25
					portEXIT_CRITICAL();
    2b0e:	0f 90       	pop	r0
    2b10:	0f be       	out	0x3f, r0	; 63
				}

				/* Update the value we are going to post next time around. */
				usValue++;
    2b12:	29 81       	ldd	r18, Y+1	; 0x01
    2b14:	3a 81       	ldd	r19, Y+2	; 0x02
    2b16:	2f 5f       	subi	r18, 0xFF	; 255
    2b18:	3f 4f       	sbci	r19, 0xFF	; 255
    2b1a:	3a 83       	std	Y+2, r19	; 0x02
    2b1c:	29 83       	std	Y+1, r18	; 0x01
    2b1e:	01 c0       	rjmp	.+2      	; 0x2b22 <vPolledQueueProducer+0x56>
			/* Send an incrementing number on the queue without blocking. */
			if( xQueueSend( *( ( QueueHandle_t * ) pvParameters ), ( void * ) &usValue, pollqNO_DELAY ) != pdPASS )
			{
				/* We should never find the queue full so if we get here there
				has been an error. */
				xError = pdTRUE;
    2b20:	01 e0       	ldi	r16, 0x01	; 1
    2b22:	11 50       	subi	r17, 0x01	; 1
uint16_t usValue = ( uint16_t ) 0;
BaseType_t xError = pdFALSE, xLoop;

	for( ;; )
	{
		for( xLoop = 0; xLoop < pollqVALUES_TO_PRODUCE; xLoop++ )
    2b24:	e9 f6       	brne	.-70     	; 0x2ae0 <vPolledQueueProducer+0x14>
			}
		}

		/* Wait before we start posting again to ensure the consumer runs and
		empties the queue. */
		vTaskDelay( pollqPRODUCER_DELAY );
    2b26:	83 e0       	ldi	r24, 0x03	; 3
    2b28:	90 e0       	ldi	r25, 0x00	; 0
    2b2a:	0e 94 c4 06 	call	0xd88	; 0xd88 <vTaskDelay>
	}
    2b2e:	d7 cf       	rjmp	.-82     	; 0x2ade <vPolledQueueProducer+0x12>

00002b30 <vPolledQueueConsumer>:
}  /*lint !e818 Function prototype must conform to API. */
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vPolledQueueConsumer, pvParameters )
{
    2b30:	cf 93       	push	r28
    2b32:	df 93       	push	r29
    2b34:	00 d0       	rcall	.+0      	; 0x2b36 <vPolledQueueConsumer+0x6>
    2b36:	cd b7       	in	r28, 0x3d	; 61
    2b38:	de b7       	in	r29, 0x3e	; 62
    2b3a:	6c 01       	movw	r12, r24
uint16_t usData, usExpectedValue = ( uint16_t ) 0;
BaseType_t xError = pdFALSE;
    2b3c:	f1 2c       	mov	r15, r1
}  /*lint !e818 Function prototype must conform to API. */
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vPolledQueueConsumer, pvParameters )
{
uint16_t usData, usExpectedValue = ( uint16_t ) 0;
    2b3e:	00 e0       	ldi	r16, 0x00	; 0
    2b40:	10 e0       	ldi	r17, 0x00	; 0
BaseType_t xError = pdFALSE;

	for( ;; )
	{
		/* Loop until the queue is empty. */
		while( uxQueueMessagesWaiting( *( ( QueueHandle_t * ) pvParameters ) ) )
    2b42:	f6 01       	movw	r30, r12
    2b44:	80 81       	ld	r24, Z
    2b46:	91 81       	ldd	r25, Z+1	; 0x01
    2b48:	0e 94 3f 0e 	call	0x1c7e	; 0x1c7e <uxQueueMessagesWaiting>
    2b4c:	88 23       	and	r24, r24
    2b4e:	21 f1       	breq	.+72     	; 0x2b98 <vPolledQueueConsumer+0x68>
		{
			if( xQueueReceive( *( ( QueueHandle_t * ) pvParameters ), &usData, pollqNO_DELAY ) == pdPASS )
    2b50:	40 e0       	ldi	r20, 0x00	; 0
    2b52:	50 e0       	ldi	r21, 0x00	; 0
    2b54:	be 01       	movw	r22, r28
    2b56:	6f 5f       	subi	r22, 0xFF	; 255
    2b58:	7f 4f       	sbci	r23, 0xFF	; 255
    2b5a:	f6 01       	movw	r30, r12
    2b5c:	80 81       	ld	r24, Z
    2b5e:	91 81       	ldd	r25, Z+1	; 0x01
    2b60:	0e 94 4f 0c 	call	0x189e	; 0x189e <xQueueReceive>
    2b64:	81 30       	cpi	r24, 0x01	; 1
    2b66:	69 f7       	brne	.-38     	; 0x2b42 <vPolledQueueConsumer+0x12>
			{
				if( usData != usExpectedValue )
    2b68:	29 81       	ldd	r18, Y+1	; 0x01
    2b6a:	3a 81       	ldd	r19, Y+2	; 0x02
    2b6c:	20 17       	cp	r18, r16
    2b6e:	31 07       	cpc	r19, r17
    2b70:	69 f4       	brne	.+26     	; 0x2b8c <vPolledQueueConsumer+0x5c>
					value should again be correct. */
					usExpectedValue = usData;
				}
				else
				{
					if( xError == pdFALSE )
    2b72:	f1 10       	cpse	r15, r1
    2b74:	0d c0       	rjmp	.+26     	; 0x2b90 <vPolledQueueConsumer+0x60>
					{
						/* Only increment the check variable if no errors have
						occurred. */
						portENTER_CRITICAL();
    2b76:	0f b6       	in	r0, 0x3f	; 63
    2b78:	f8 94       	cli
    2b7a:	0f 92       	push	r0
							xPollingConsumerCount++;
    2b7c:	90 91 db 07 	lds	r25, 0x07DB
    2b80:	9f 5f       	subi	r25, 0xFF	; 255
    2b82:	90 93 db 07 	sts	0x07DB, r25
						portEXIT_CRITICAL();
    2b86:	0f 90       	pop	r0
    2b88:	0f be       	out	0x3f, r0	; 63
    2b8a:	02 c0       	rjmp	.+4      	; 0x2b90 <vPolledQueueConsumer+0x60>
			{
				if( usData != usExpectedValue )
				{
					/* This is not what we expected to receive so an error has
					occurred. */
					xError = pdTRUE;
    2b8c:	ff 24       	eor	r15, r15
    2b8e:	f3 94       	inc	r15
						portEXIT_CRITICAL();
					}
				}

				/* Next time round we would expect the number to be one higher. */
				usExpectedValue++;
    2b90:	89 01       	movw	r16, r18
    2b92:	0f 5f       	subi	r16, 0xFF	; 255
    2b94:	1f 4f       	sbci	r17, 0xFF	; 255
    2b96:	d5 cf       	rjmp	.-86     	; 0x2b42 <vPolledQueueConsumer+0x12>
			}
		}

		/* Now the queue is empty we block, allowing the producer to place more
		items in the queue. */
		vTaskDelay( pollqCONSUMER_DELAY );
    2b98:	8f ee       	ldi	r24, 0xEF	; 239
    2b9a:	9f ef       	ldi	r25, 0xFF	; 255
    2b9c:	0e 94 c4 06 	call	0xd88	; 0xd88 <vTaskDelay>
	}
    2ba0:	d0 cf       	rjmp	.-96     	; 0x2b42 <vPolledQueueConsumer+0x12>

00002ba2 <vStartPolledQueueTasks>:
static volatile BaseType_t xPollingConsumerCount = pollqINITIAL_VALUE, xPollingProducerCount = pollqINITIAL_VALUE;

/*-----------------------------------------------------------*/

void vStartPolledQueueTasks( UBaseType_t uxPriority )
{
    2ba2:	ef 92       	push	r14
    2ba4:	ff 92       	push	r15
    2ba6:	0f 93       	push	r16
    2ba8:	cf 93       	push	r28
    2baa:	c8 2f       	mov	r28, r24
static QueueHandle_t xPolledQueue;

	/* Create the queue used by the producer and consumer. */
	xPolledQueue = xQueueCreate( pollqQUEUE_SIZE, ( UBaseType_t ) sizeof( uint16_t ) );
    2bac:	40 e0       	ldi	r20, 0x00	; 0
    2bae:	62 e0       	ldi	r22, 0x02	; 2
    2bb0:	8a e0       	ldi	r24, 0x0A	; 10
    2bb2:	0e 94 35 0b 	call	0x166a	; 0x166a <xQueueGenericCreate>
    2bb6:	90 93 d9 07 	sts	0x07D9, r25
    2bba:	80 93 d8 07 	sts	0x07D8, r24

	if( xPolledQueue != NULL )
    2bbe:	89 2b       	or	r24, r25
    2bc0:	b9 f0       	breq	.+46     	; 0x2bf0 <vStartPolledQueueTasks+0x4e>
		by the pre-processor if configQUEUE_REGISTRY_SIZE is not defined or is
		defined to be less than 1. */
		vQueueAddToRegistry( xPolledQueue, "Poll_Test_Queue" );

		/* Spawn the producer and consumer. */
		xTaskCreate( vPolledQueueConsumer, "QConsNB", pollqSTACK_SIZE, ( void * ) &xPolledQueue, uxPriority, ( TaskHandle_t * ) NULL );
    2bc2:	e1 2c       	mov	r14, r1
    2bc4:	f1 2c       	mov	r15, r1
    2bc6:	0c 2f       	mov	r16, r28
    2bc8:	28 ed       	ldi	r18, 0xD8	; 216
    2bca:	37 e0       	ldi	r19, 0x07	; 7
    2bcc:	45 e5       	ldi	r20, 0x55	; 85
    2bce:	50 e0       	ldi	r21, 0x00	; 0
    2bd0:	63 e3       	ldi	r22, 0x33	; 51
    2bd2:	71 e0       	ldi	r23, 0x01	; 1
    2bd4:	88 e9       	ldi	r24, 0x98	; 152
    2bd6:	95 e1       	ldi	r25, 0x15	; 21
    2bd8:	0e 94 d4 03 	call	0x7a8	; 0x7a8 <xTaskCreate>
		xTaskCreate( vPolledQueueProducer, "QProdNB", pollqSTACK_SIZE, ( void * ) &xPolledQueue, uxPriority, ( TaskHandle_t * ) NULL );
    2bdc:	28 ed       	ldi	r18, 0xD8	; 216
    2bde:	37 e0       	ldi	r19, 0x07	; 7
    2be0:	45 e5       	ldi	r20, 0x55	; 85
    2be2:	50 e0       	ldi	r21, 0x00	; 0
    2be4:	6b e3       	ldi	r22, 0x3B	; 59
    2be6:	71 e0       	ldi	r23, 0x01	; 1
    2be8:	86 e6       	ldi	r24, 0x66	; 102
    2bea:	95 e1       	ldi	r25, 0x15	; 21
    2bec:	0e 94 d4 03 	call	0x7a8	; 0x7a8 <xTaskCreate>
	}
}
    2bf0:	cf 91       	pop	r28
    2bf2:	0f 91       	pop	r16
    2bf4:	ff 90       	pop	r15
    2bf6:	ef 90       	pop	r14
    2bf8:	08 95       	ret

00002bfa <xArePollingQueuesStillRunning>:

	/* Check both the consumer and producer poll count to check they have both
	been changed since out last trip round.  We do not need a critical section
	around the check variables as this is called from a higher priority than
	the other tasks that access the same variables. */
	if( ( xPollingConsumerCount == pollqINITIAL_VALUE ) ||
    2bfa:	80 91 db 07 	lds	r24, 0x07DB
    2bfe:	88 23       	and	r24, r24
    2c00:	29 f0       	breq	.+10     	; 0x2c0c <xArePollingQueuesStillRunning+0x12>
		( xPollingProducerCount == pollqINITIAL_VALUE )
    2c02:	90 91 da 07 	lds	r25, 0x07DA

	/* Check both the consumer and producer poll count to check they have both
	been changed since out last trip round.  We do not need a critical section
	around the check variables as this is called from a higher priority than
	the other tasks that access the same variables. */
	if( ( xPollingConsumerCount == pollqINITIAL_VALUE ) ||
    2c06:	81 e0       	ldi	r24, 0x01	; 1
    2c08:	91 11       	cpse	r25, r1
    2c0a:	01 c0       	rjmp	.+2      	; 0x2c0e <xArePollingQueuesStillRunning+0x14>
		( xPollingProducerCount == pollqINITIAL_VALUE )
	  )
	{
		xReturn = pdFALSE;
    2c0c:	80 e0       	ldi	r24, 0x00	; 0
		xReturn = pdTRUE;
	}

	/* Set the check variables back down so we know if they have been
	incremented the next time around. */
	xPollingConsumerCount = pollqINITIAL_VALUE;
    2c0e:	10 92 db 07 	sts	0x07DB, r1
	xPollingProducerCount = pollqINITIAL_VALUE;
    2c12:	10 92 da 07 	sts	0x07DA, r1

	return xReturn;
}
    2c16:	08 95       	ret

00002c18 <vComRxTask>:
	}
} /*lint !e715 !e818 pvParameters is required for a task function even if it is not referenced. */
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vComRxTask, pvParameters )
{
    2c18:	cf 93       	push	r28
    2c1a:	df 93       	push	r29
    2c1c:	1f 92       	push	r1
    2c1e:	cd b7       	in	r28, 0x3d	; 61
    2c20:	de b7       	in	r29, 0x3e	; 62
signed char cExpectedByte, cByteRxed;
BaseType_t xResyncRequired = pdFALSE, xErrorOccurred = pdFALSE;
    2c22:	00 e0       	ldi	r16, 0x00	; 0

	for( ;; )
	{
		/* We expect to receive the characters from comFIRST_BYTE to
		comLAST_BYTE in an incrementing order.  Loop to receive each byte. */
		for( cExpectedByte = comFIRST_BYTE; cExpectedByte <= comLAST_BYTE; cExpectedByte++ )
    2c24:	11 e4       	ldi	r17, 0x41	; 65
		{
			/* Block on the queue that contains received bytes until a byte is
			available. */
			if( xSerialGetChar( xPort, &cByteRxed, comRX_BLOCK_TIME ) )
    2c26:	4f ef       	ldi	r20, 0xFF	; 255
    2c28:	5f ef       	ldi	r21, 0xFF	; 255
    2c2a:	be 01       	movw	r22, r28
    2c2c:	6f 5f       	subi	r22, 0xFF	; 255
    2c2e:	7f 4f       	sbci	r23, 0xFF	; 255
    2c30:	80 e0       	ldi	r24, 0x00	; 0
    2c32:	90 e0       	ldi	r25, 0x00	; 0
    2c34:	0e 94 27 01 	call	0x24e	; 0x24e <xSerialGetChar>
    2c38:	88 23       	and	r24, r24
    2c3a:	41 f0       	breq	.+16     	; 0x2c4c <vComRxTask+0x34>
			{
				/* Was this the byte we were expecting?  If so, toggle the LED,
				otherwise we are out on sync and should break out of the loop
				until the expected character sequence is about to restart. */
				if( cByteRxed == cExpectedByte )
    2c3c:	89 81       	ldd	r24, Y+1	; 0x01
    2c3e:	81 13       	cpse	r24, r17
    2c40:	0a c0       	rjmp	.+20     	; 0x2c56 <vComRxTask+0x3e>
				{
					vParTestToggleLED( uxBaseLED + comRX_LED_OFFSET );
    2c42:	80 91 dd 07 	lds	r24, 0x07DD
    2c46:	8f 5f       	subi	r24, 0xFF	; 255
    2c48:	0e 94 ba 00 	call	0x174	; 0x174 <vParTestToggleLED>
    2c4c:	1f 5f       	subi	r17, 0xFF	; 255

	for( ;; )
	{
		/* We expect to receive the characters from comFIRST_BYTE to
		comLAST_BYTE in an incrementing order.  Loop to receive each byte. */
		for( cExpectedByte = comFIRST_BYTE; cExpectedByte <= comLAST_BYTE; cExpectedByte++ )
    2c4e:	19 35       	cpi	r17, 0x59	; 89
    2c50:	51 f7       	brne	.-44     	; 0x2c26 <vComRxTask+0xe>
    2c52:	10 e0       	ldi	r17, 0x00	; 0
    2c54:	01 c0       	rjmp	.+2      	; 0x2c58 <vComRxTask+0x40>
				{
					vParTestToggleLED( uxBaseLED + comRX_LED_OFFSET );
				}
				else
				{
					xResyncRequired = pdTRUE;
    2c56:	11 e0       	ldi	r17, 0x01	; 1
				}
			}
		}

		/* Turn the LED off while we are not doing anything. */
		vParTestSetLED( uxBaseLED + comRX_LED_OFFSET, pdFALSE );
    2c58:	80 91 dd 07 	lds	r24, 0x07DD
    2c5c:	60 e0       	ldi	r22, 0x00	; 0
    2c5e:	8f 5f       	subi	r24, 0xFF	; 255
    2c60:	0e 94 96 00 	call	0x12c	; 0x12c <vParTestSetLED>

		/* Did we break out of the loop because the characters were received in
		an unexpected order?  If so wait here until the character sequence is
		about to restart. */
		if( xResyncRequired == pdTRUE )
    2c64:	11 30       	cpi	r17, 0x01	; 1
    2c66:	79 f4       	brne	.+30     	; 0x2c86 <vComRxTask+0x6e>
		{
			while( cByteRxed != comLAST_BYTE )
    2c68:	89 81       	ldd	r24, Y+1	; 0x01
    2c6a:	88 35       	cpi	r24, 0x58	; 88
    2c6c:	51 f0       	breq	.+20     	; 0x2c82 <vComRxTask+0x6a>
			{
				/* Block until the next char is available. */
				xSerialGetChar( xPort, &cByteRxed, comRX_BLOCK_TIME );
    2c6e:	4f ef       	ldi	r20, 0xFF	; 255
    2c70:	5f ef       	ldi	r21, 0xFF	; 255
    2c72:	be 01       	movw	r22, r28
    2c74:	6f 5f       	subi	r22, 0xFF	; 255
    2c76:	7f 4f       	sbci	r23, 0xFF	; 255
    2c78:	80 e0       	ldi	r24, 0x00	; 0
    2c7a:	90 e0       	ldi	r25, 0x00	; 0
    2c7c:	0e 94 27 01 	call	0x24e	; 0x24e <xSerialGetChar>
    2c80:	f3 cf       	rjmp	.-26     	; 0x2c68 <vComRxTask+0x50>

			/* Note that an error occurred which caused us to have to resync.
			We use this to stop incrementing the loop counter so
			sAreComTestTasksStillRunning() will return false - indicating an
			error. */
			xErrorOccurred++;
    2c82:	0f 5f       	subi	r16, 0xFF	; 255
    2c84:	cf cf       	rjmp	.-98     	; 0x2c24 <vComRxTask+0xc>
			/* We have now resynced with the Tx task and can continue. */
			xResyncRequired = pdFALSE;
		}
		else
		{
			if( xErrorOccurred < comTOTAL_PERMISSIBLE_ERRORS )
    2c86:	02 30       	cpi	r16, 0x02	; 2
    2c88:	6c f6       	brge	.-102    	; 0x2c24 <vComRxTask+0xc>
				occurring (i.e. an unexpected character being received) will
				prevent this counter being incremented for the rest of the
				execution.   Don't worry about mutual exclusion on this
				variable - it doesn't really matter as we just want it
				to change. */
				uxRxLoops++;
    2c8a:	80 91 dc 07 	lds	r24, 0x07DC
    2c8e:	8f 5f       	subi	r24, 0xFF	; 255
    2c90:	80 93 dc 07 	sts	0x07DC, r24
    2c94:	c7 cf       	rjmp	.-114    	; 0x2c24 <vComRxTask+0xc>

00002c96 <vComTxTask>:
		re-sending.  Wait a pseudo-random time as this will provide a better
		test. */
		xTimeToWait = xTaskGetTickCount() + comOFFSET_TIME;

		/* Make sure we don't wait too long... */
		xTimeToWait %= comTX_MAX_BLOCK_TIME;
    2c96:	06 e9       	ldi	r16, 0x96	; 150
    2c98:	10 e0       	ldi	r17, 0x00	; 0

	for( ;; )
	{
		/* Simply transmit a sequence of characters from comFIRST_BYTE to
		comLAST_BYTE. */
		for( cByteToSend = comFIRST_BYTE; cByteToSend <= comLAST_BYTE; cByteToSend++ )
    2c9a:	c1 e4       	ldi	r28, 0x41	; 65
		{
			if( xSerialPutChar( xPort, cByteToSend, comNO_BLOCK ) == pdPASS )
    2c9c:	40 e0       	ldi	r20, 0x00	; 0
    2c9e:	50 e0       	ldi	r21, 0x00	; 0
    2ca0:	6c 2f       	mov	r22, r28
    2ca2:	80 e0       	ldi	r24, 0x00	; 0
    2ca4:	90 e0       	ldi	r25, 0x00	; 0
    2ca6:	0e 94 33 01 	call	0x266	; 0x266 <xSerialPutChar>
    2caa:	81 30       	cpi	r24, 0x01	; 1
    2cac:	21 f4       	brne	.+8      	; 0x2cb6 <vComTxTask+0x20>
			{
				vParTestToggleLED( uxBaseLED + comTX_LED_OFFSET );
    2cae:	80 91 dd 07 	lds	r24, 0x07DD
    2cb2:	0e 94 ba 00 	call	0x174	; 0x174 <vParTestToggleLED>
    2cb6:	cf 5f       	subi	r28, 0xFF	; 255

	for( ;; )
	{
		/* Simply transmit a sequence of characters from comFIRST_BYTE to
		comLAST_BYTE. */
		for( cByteToSend = comFIRST_BYTE; cByteToSend <= comLAST_BYTE; cByteToSend++ )
    2cb8:	c9 35       	cpi	r28, 0x59	; 89
    2cba:	81 f7       	brne	.-32     	; 0x2c9c <vComTxTask+0x6>
				vParTestToggleLED( uxBaseLED + comTX_LED_OFFSET );
			}
		}

		/* Turn the LED off while we are not doing anything. */
		vParTestSetLED( uxBaseLED + comTX_LED_OFFSET, pdFALSE );
    2cbc:	60 e0       	ldi	r22, 0x00	; 0
    2cbe:	80 91 dd 07 	lds	r24, 0x07DD
    2cc2:	0e 94 96 00 	call	0x12c	; 0x12c <vParTestSetLED>

		/* We have posted all the characters in the string - wait before
		re-sending.  Wait a pseudo-random time as this will provide a better
		test. */
		xTimeToWait = xTaskGetTickCount() + comOFFSET_TIME;
    2cc6:	0e 94 58 05 	call	0xab0	; 0xab0 <xTaskGetTickCount>
    2cca:	03 96       	adiw	r24, 0x03	; 3

		/* Make sure we don't wait too long... */
		xTimeToWait %= comTX_MAX_BLOCK_TIME;
    2ccc:	b8 01       	movw	r22, r16
    2cce:	0e 94 e8 16 	call	0x2dd0	; 0x2dd0 <__udivmodhi4>

		/* ...but we do want to wait. */
		if( xTimeToWait < comTX_MIN_BLOCK_TIME )
    2cd2:	82 33       	cpi	r24, 0x32	; 50
    2cd4:	91 05       	cpc	r25, r1
    2cd6:	10 f4       	brcc	.+4      	; 0x2cdc <vComTxTask+0x46>
		{
			xTimeToWait = comTX_MIN_BLOCK_TIME;
    2cd8:	82 e3       	ldi	r24, 0x32	; 50
    2cda:	90 e0       	ldi	r25, 0x00	; 0
		}

		vTaskDelay( xTimeToWait );
    2cdc:	0e 94 c4 06 	call	0xd88	; 0xd88 <vTaskDelay>
	}
    2ce0:	dc cf       	rjmp	.-72     	; 0x2c9a <vComTxTask+0x4>

00002ce2 <vAltStartComTestTasks>:
static volatile UBaseType_t uxRxLoops = comINITIAL_RX_COUNT_VALUE;

/*-----------------------------------------------------------*/

void vAltStartComTestTasks( UBaseType_t uxPriority, uint32_t ulBaudRate, UBaseType_t uxLED )
{
    2ce2:	ef 92       	push	r14
    2ce4:	ff 92       	push	r15
    2ce6:	0f 93       	push	r16
    2ce8:	cf 93       	push	r28
    2cea:	c8 2f       	mov	r28, r24
    2cec:	cb 01       	movw	r24, r22
    2cee:	ba 01       	movw	r22, r20
	/* Initialise the com port then spawn the Rx and Tx tasks. */
	uxBaseLED = uxLED;
    2cf0:	20 93 dd 07 	sts	0x07DD, r18
	xSerialPortInitMinimal( ulBaudRate, comBUFFER_LEN );
    2cf4:	48 e1       	ldi	r20, 0x18	; 24
    2cf6:	0e 94 de 00 	call	0x1bc	; 0x1bc <xSerialPortInitMinimal>

	/* The Tx task is spawned with a lower priority than the Rx task. */
	xTaskCreate( vComTxTask, "COMTx", comSTACK_SIZE, NULL, uxPriority - 1, ( TaskHandle_t * ) NULL );
    2cfa:	0f ef       	ldi	r16, 0xFF	; 255
    2cfc:	0c 0f       	add	r16, r28
    2cfe:	e1 2c       	mov	r14, r1
    2d00:	f1 2c       	mov	r15, r1
    2d02:	20 e0       	ldi	r18, 0x00	; 0
    2d04:	30 e0       	ldi	r19, 0x00	; 0
    2d06:	45 e5       	ldi	r20, 0x55	; 85
    2d08:	50 e0       	ldi	r21, 0x00	; 0
    2d0a:	63 e4       	ldi	r22, 0x43	; 67
    2d0c:	71 e0       	ldi	r23, 0x01	; 1
    2d0e:	8b e4       	ldi	r24, 0x4B	; 75
    2d10:	96 e1       	ldi	r25, 0x16	; 22
    2d12:	0e 94 d4 03 	call	0x7a8	; 0x7a8 <xTaskCreate>
	xTaskCreate( vComRxTask, "COMRx", comSTACK_SIZE, NULL, uxPriority, ( TaskHandle_t * ) NULL );
    2d16:	0c 2f       	mov	r16, r28
    2d18:	20 e0       	ldi	r18, 0x00	; 0
    2d1a:	30 e0       	ldi	r19, 0x00	; 0
    2d1c:	45 e5       	ldi	r20, 0x55	; 85
    2d1e:	50 e0       	ldi	r21, 0x00	; 0
    2d20:	69 e4       	ldi	r22, 0x49	; 73
    2d22:	71 e0       	ldi	r23, 0x01	; 1
    2d24:	8c e0       	ldi	r24, 0x0C	; 12
    2d26:	96 e1       	ldi	r25, 0x16	; 22
    2d28:	0e 94 d4 03 	call	0x7a8	; 0x7a8 <xTaskCreate>
}
    2d2c:	cf 91       	pop	r28
    2d2e:	0f 91       	pop	r16
    2d30:	ff 90       	pop	r15
    2d32:	ef 90       	pop	r14
    2d34:	08 95       	ret

00002d36 <xAreComTestTasksStillRunning>:
    2d36:	90 91 dc 07 	lds	r25, 0x07DC
    2d3a:	10 92 dc 07 	sts	0x07DC, r1
    2d3e:	81 e0       	ldi	r24, 0x01	; 1
    2d40:	91 11       	cpse	r25, r1
    2d42:	01 c0       	rjmp	.+2      	; 0x2d46 <xAreComTestTasksStillRunning+0x10>
    2d44:	80 e0       	ldi	r24, 0x00	; 0
    2d46:	08 95       	ret

00002d48 <main>:
void vApplicationIdleHook( void );

/*-----------------------------------------------------------*/

short main( void )
{
    2d48:	ef 92       	push	r14
    2d4a:	ff 92       	push	r15
    2d4c:	0f 93       	push	r16
    2d4e:	cf 93       	push	r28
    2d50:	df 93       	push	r29
    2d52:	1f 92       	push	r1
    2d54:	cd b7       	in	r28, 0x3d	; 61
    2d56:	de b7       	in	r29, 0x3e	; 62

static void prvIncrementResetCount( void )
{
unsigned char ucCount;

	eeprom_read_block( &ucCount, mainRESET_COUNT_ADDRESS, sizeof( ucCount ) );
    2d58:	41 e0       	ldi	r20, 0x01	; 1
    2d5a:	50 e0       	ldi	r21, 0x00	; 0
    2d5c:	60 e5       	ldi	r22, 0x50	; 80
    2d5e:	70 e0       	ldi	r23, 0x00	; 0
    2d60:	ce 01       	movw	r24, r28
    2d62:	01 96       	adiw	r24, 0x01	; 1
    2d64:	0e 94 68 17 	call	0x2ed0	; 0x2ed0 <eeprom_read_block>
	ucCount++;
    2d68:	69 81       	ldd	r22, Y+1	; 0x01
    2d6a:	6f 5f       	subi	r22, 0xFF	; 255
    2d6c:	69 83       	std	Y+1, r22	; 0x01
	eeprom_write_byte( mainRESET_COUNT_ADDRESS, ucCount );
    2d6e:	80 e5       	ldi	r24, 0x50	; 80
    2d70:	90 e0       	ldi	r25, 0x00	; 0
    2d72:	0e 94 78 17 	call	0x2ef0	; 0x2ef0 <eeprom_write_byte>
short main( void )
{
	prvIncrementResetCount();

	/* Setup the LED's for output. */
	vParTestInitialise();
    2d76:	0e 94 8e 00 	call	0x11c	; 0x11c <vParTestInitialise>

	/* Create the standard demo tasks. */
	vStartIntegerMathTasks( tskIDLE_PRIORITY );
    2d7a:	80 e0       	ldi	r24, 0x00	; 0
    2d7c:	0e 94 49 15 	call	0x2a92	; 0x2a92 <vStartIntegerMathTasks>
	vAltStartComTestTasks( mainCOM_TEST_PRIORITY, mainCOM_TEST_BAUD_RATE, mainCOM_TEST_LED );
    2d80:	25 e0       	ldi	r18, 0x05	; 5
    2d82:	40 e0       	ldi	r20, 0x00	; 0
    2d84:	56 e9       	ldi	r21, 0x96	; 150
    2d86:	60 e0       	ldi	r22, 0x00	; 0
    2d88:	70 e0       	ldi	r23, 0x00	; 0
    2d8a:	82 e0       	ldi	r24, 0x02	; 2
    2d8c:	0e 94 71 16 	call	0x2ce2	; 0x2ce2 <vAltStartComTestTasks>
	vStartPolledQueueTasks( mainQUEUE_POLL_PRIORITY );
    2d90:	82 e0       	ldi	r24, 0x02	; 2
    2d92:	0e 94 d1 15 	call	0x2ba2	; 0x2ba2 <vStartPolledQueueTasks>
	vStartRegTestTasks();
    2d96:	0e 94 24 03 	call	0x648	; 0x648 <vStartRegTestTasks>

	/* Create the tasks defined within this file. */
	xTaskCreate( vErrorChecks, "Check", configMINIMAL_STACK_SIZE, NULL, mainCHECK_TASK_PRIORITY, NULL );
    2d9a:	e1 2c       	mov	r14, r1
    2d9c:	f1 2c       	mov	r15, r1
    2d9e:	03 e0       	ldi	r16, 0x03	; 3
    2da0:	20 e0       	ldi	r18, 0x00	; 0
    2da2:	30 e0       	ldi	r19, 0x00	; 0
    2da4:	45 e5       	ldi	r20, 0x55	; 85
    2da6:	50 e0       	ldi	r21, 0x00	; 0
    2da8:	66 e1       	ldi	r22, 0x16	; 22
    2daa:	71 e0       	ldi	r23, 0x01	; 1
    2dac:	83 e5       	ldi	r24, 0x53	; 83
    2dae:	90 e0       	ldi	r25, 0x00	; 0
    2db0:	0e 94 d4 03 	call	0x7a8	; 0x7a8 <xTaskCreate>

	/* Create the co-routines that flash the LED's. */
	vStartFlashCoRoutines( mainNUM_FLASH_COROUTINES );
    2db4:	83 e0       	ldi	r24, 0x03	; 3
    2db6:	0e 94 cb 14 	call	0x2996	; 0x2996 <vStartFlashCoRoutines>

	/* In this port, to use preemptive scheduler define configUSE_PREEMPTION
	as 1 in portmacro.h.  To use the cooperative scheduler define
	configUSE_PREEMPTION as 0. */
	vTaskStartScheduler();
    2dba:	0e 94 23 05 	call	0xa46	; 0xa46 <vTaskStartScheduler>

	return 0;
}
    2dbe:	80 e0       	ldi	r24, 0x00	; 0
    2dc0:	90 e0       	ldi	r25, 0x00	; 0
    2dc2:	0f 90       	pop	r0
    2dc4:	df 91       	pop	r29
    2dc6:	cf 91       	pop	r28
    2dc8:	0f 91       	pop	r16
    2dca:	ff 90       	pop	r15
    2dcc:	ef 90       	pop	r14
    2dce:	08 95       	ret

00002dd0 <__udivmodhi4>:
    2dd0:	aa 1b       	sub	r26, r26
    2dd2:	bb 1b       	sub	r27, r27
    2dd4:	51 e1       	ldi	r21, 0x11	; 17
    2dd6:	07 c0       	rjmp	.+14     	; 0x2de6 <__udivmodhi4_ep>

00002dd8 <__udivmodhi4_loop>:
    2dd8:	aa 1f       	adc	r26, r26
    2dda:	bb 1f       	adc	r27, r27
    2ddc:	a6 17       	cp	r26, r22
    2dde:	b7 07       	cpc	r27, r23
    2de0:	10 f0       	brcs	.+4      	; 0x2de6 <__udivmodhi4_ep>
    2de2:	a6 1b       	sub	r26, r22
    2de4:	b7 0b       	sbc	r27, r23

00002de6 <__udivmodhi4_ep>:
    2de6:	88 1f       	adc	r24, r24
    2de8:	99 1f       	adc	r25, r25
    2dea:	5a 95       	dec	r21
    2dec:	a9 f7       	brne	.-22     	; 0x2dd8 <__udivmodhi4_loop>
    2dee:	80 95       	com	r24
    2df0:	90 95       	com	r25
    2df2:	bc 01       	movw	r22, r24
    2df4:	cd 01       	movw	r24, r26
    2df6:	08 95       	ret

00002df8 <__udivmodsi4>:
    2df8:	a1 e2       	ldi	r26, 0x21	; 33
    2dfa:	1a 2e       	mov	r1, r26
    2dfc:	aa 1b       	sub	r26, r26
    2dfe:	bb 1b       	sub	r27, r27
    2e00:	fd 01       	movw	r30, r26
    2e02:	0d c0       	rjmp	.+26     	; 0x2e1e <__udivmodsi4_ep>

00002e04 <__udivmodsi4_loop>:
    2e04:	aa 1f       	adc	r26, r26
    2e06:	bb 1f       	adc	r27, r27
    2e08:	ee 1f       	adc	r30, r30
    2e0a:	ff 1f       	adc	r31, r31
    2e0c:	a2 17       	cp	r26, r18
    2e0e:	b3 07       	cpc	r27, r19
    2e10:	e4 07       	cpc	r30, r20
    2e12:	f5 07       	cpc	r31, r21
    2e14:	20 f0       	brcs	.+8      	; 0x2e1e <__udivmodsi4_ep>
    2e16:	a2 1b       	sub	r26, r18
    2e18:	b3 0b       	sbc	r27, r19
    2e1a:	e4 0b       	sbc	r30, r20
    2e1c:	f5 0b       	sbc	r31, r21

00002e1e <__udivmodsi4_ep>:
    2e1e:	66 1f       	adc	r22, r22
    2e20:	77 1f       	adc	r23, r23
    2e22:	88 1f       	adc	r24, r24
    2e24:	99 1f       	adc	r25, r25
    2e26:	1a 94       	dec	r1
    2e28:	69 f7       	brne	.-38     	; 0x2e04 <__udivmodsi4_loop>
    2e2a:	60 95       	com	r22
    2e2c:	70 95       	com	r23
    2e2e:	80 95       	com	r24
    2e30:	90 95       	com	r25
    2e32:	9b 01       	movw	r18, r22
    2e34:	ac 01       	movw	r20, r24
    2e36:	bd 01       	movw	r22, r26
    2e38:	cf 01       	movw	r24, r30
    2e3a:	08 95       	ret

00002e3c <__divmodsi4>:
    2e3c:	05 2e       	mov	r0, r21
    2e3e:	97 fb       	bst	r25, 7
    2e40:	1e f4       	brtc	.+6      	; 0x2e48 <__divmodsi4+0xc>
    2e42:	00 94       	com	r0
    2e44:	0e 94 35 17 	call	0x2e6a	; 0x2e6a <__negsi2>
    2e48:	57 fd       	sbrc	r21, 7
    2e4a:	07 d0       	rcall	.+14     	; 0x2e5a <__divmodsi4_neg2>
    2e4c:	0e 94 fc 16 	call	0x2df8	; 0x2df8 <__udivmodsi4>
    2e50:	07 fc       	sbrc	r0, 7
    2e52:	03 d0       	rcall	.+6      	; 0x2e5a <__divmodsi4_neg2>
    2e54:	4e f4       	brtc	.+18     	; 0x2e68 <__divmodsi4_exit>
    2e56:	0c 94 35 17 	jmp	0x2e6a	; 0x2e6a <__negsi2>

00002e5a <__divmodsi4_neg2>:
    2e5a:	50 95       	com	r21
    2e5c:	40 95       	com	r20
    2e5e:	30 95       	com	r19
    2e60:	21 95       	neg	r18
    2e62:	3f 4f       	sbci	r19, 0xFF	; 255
    2e64:	4f 4f       	sbci	r20, 0xFF	; 255
    2e66:	5f 4f       	sbci	r21, 0xFF	; 255

00002e68 <__divmodsi4_exit>:
    2e68:	08 95       	ret

00002e6a <__negsi2>:
    2e6a:	90 95       	com	r25
    2e6c:	80 95       	com	r24
    2e6e:	70 95       	com	r23
    2e70:	61 95       	neg	r22
    2e72:	7f 4f       	sbci	r23, 0xFF	; 255
    2e74:	8f 4f       	sbci	r24, 0xFF	; 255
    2e76:	9f 4f       	sbci	r25, 0xFF	; 255
    2e78:	08 95       	ret

00002e7a <__muluhisi3>:
    2e7a:	0e 94 50 17 	call	0x2ea0	; 0x2ea0 <__umulhisi3>
    2e7e:	a5 9f       	mul	r26, r21
    2e80:	90 0d       	add	r25, r0
    2e82:	b4 9f       	mul	r27, r20
    2e84:	90 0d       	add	r25, r0
    2e86:	a4 9f       	mul	r26, r20
    2e88:	80 0d       	add	r24, r0
    2e8a:	91 1d       	adc	r25, r1
    2e8c:	11 24       	eor	r1, r1
    2e8e:	08 95       	ret

00002e90 <__mulshisi3>:
    2e90:	b7 ff       	sbrs	r27, 7
    2e92:	0c 94 3d 17 	jmp	0x2e7a	; 0x2e7a <__muluhisi3>

00002e96 <__mulohisi3>:
    2e96:	0e 94 3d 17 	call	0x2e7a	; 0x2e7a <__muluhisi3>
    2e9a:	82 1b       	sub	r24, r18
    2e9c:	93 0b       	sbc	r25, r19
    2e9e:	08 95       	ret

00002ea0 <__umulhisi3>:
    2ea0:	a2 9f       	mul	r26, r18
    2ea2:	b0 01       	movw	r22, r0
    2ea4:	b3 9f       	mul	r27, r19
    2ea6:	c0 01       	movw	r24, r0
    2ea8:	a3 9f       	mul	r26, r19
    2eaa:	70 0d       	add	r23, r0
    2eac:	81 1d       	adc	r24, r1
    2eae:	11 24       	eor	r1, r1
    2eb0:	91 1d       	adc	r25, r1
    2eb2:	b2 9f       	mul	r27, r18
    2eb4:	70 0d       	add	r23, r0
    2eb6:	81 1d       	adc	r24, r1
    2eb8:	11 24       	eor	r1, r1
    2eba:	91 1d       	adc	r25, r1
    2ebc:	08 95       	ret

00002ebe <memcpy>:
    2ebe:	fb 01       	movw	r30, r22
    2ec0:	dc 01       	movw	r26, r24
    2ec2:	02 c0       	rjmp	.+4      	; 0x2ec8 <memcpy+0xa>
    2ec4:	01 90       	ld	r0, Z+
    2ec6:	0d 92       	st	X+, r0
    2ec8:	41 50       	subi	r20, 0x01	; 1
    2eca:	50 40       	sbci	r21, 0x00	; 0
    2ecc:	d8 f7       	brcc	.-10     	; 0x2ec4 <memcpy+0x6>
    2ece:	08 95       	ret

00002ed0 <eeprom_read_block>:
    2ed0:	dc 01       	movw	r26, r24
    2ed2:	cb 01       	movw	r24, r22

00002ed4 <eeprom_read_blraw>:
    2ed4:	fc 01       	movw	r30, r24
    2ed6:	f9 99       	sbic	0x1f, 1	; 31
    2ed8:	fe cf       	rjmp	.-4      	; 0x2ed6 <eeprom_read_blraw+0x2>
    2eda:	06 c0       	rjmp	.+12     	; 0x2ee8 <eeprom_read_blraw+0x14>
    2edc:	f2 bd       	out	0x22, r31	; 34
    2ede:	e1 bd       	out	0x21, r30	; 33
    2ee0:	f8 9a       	sbi	0x1f, 0	; 31
    2ee2:	31 96       	adiw	r30, 0x01	; 1
    2ee4:	00 b4       	in	r0, 0x20	; 32
    2ee6:	0d 92       	st	X+, r0
    2ee8:	41 50       	subi	r20, 0x01	; 1
    2eea:	50 40       	sbci	r21, 0x00	; 0
    2eec:	b8 f7       	brcc	.-18     	; 0x2edc <eeprom_read_blraw+0x8>
    2eee:	08 95       	ret

00002ef0 <eeprom_write_byte>:
    2ef0:	26 2f       	mov	r18, r22

00002ef2 <eeprom_write_r18>:
    2ef2:	f9 99       	sbic	0x1f, 1	; 31
    2ef4:	fe cf       	rjmp	.-4      	; 0x2ef2 <eeprom_write_r18>
    2ef6:	1f ba       	out	0x1f, r1	; 31
    2ef8:	92 bd       	out	0x22, r25	; 34
    2efa:	81 bd       	out	0x21, r24	; 33
    2efc:	20 bd       	out	0x20, r18	; 32
    2efe:	0f b6       	in	r0, 0x3f	; 63
    2f00:	f8 94       	cli
    2f02:	fa 9a       	sbi	0x1f, 2	; 31
    2f04:	f9 9a       	sbi	0x1f, 1	; 31
    2f06:	0f be       	out	0x3f, r0	; 63
    2f08:	01 96       	adiw	r24, 0x01	; 1
    2f0a:	08 95       	ret

00002f0c <_exit>:
    2f0c:	f8 94       	cli

00002f0e <__stop_program>:
    2f0e:	ff cf       	rjmp	.-2      	; 0x2f0e <__stop_program>
