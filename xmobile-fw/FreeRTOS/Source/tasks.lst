   1               		.file	"tasks.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   9               		.text
  10               	.Ltext0:
 187               	prvResetNextTaskUnblockTime:
 188               		.stabd	46,0,0
   1:FreeRTOS/Source/tasks.c **** /*
   2:FreeRTOS/Source/tasks.c ****  * FreeRTOS Kernel V10.0.0
   3:FreeRTOS/Source/tasks.c ****  * Copyright (C) 2017 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
   4:FreeRTOS/Source/tasks.c ****  *
   5:FreeRTOS/Source/tasks.c ****  * Permission is hereby granted, free of charge, to any person obtaining a copy of
   6:FreeRTOS/Source/tasks.c ****  * this software and associated documentation files (the "Software"), to deal in
   7:FreeRTOS/Source/tasks.c ****  * the Software without restriction, including without limitation the rights to
   8:FreeRTOS/Source/tasks.c ****  * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
   9:FreeRTOS/Source/tasks.c ****  * the Software, and to permit persons to whom the Software is furnished to do so,
  10:FreeRTOS/Source/tasks.c ****  * subject to the following conditions:
  11:FreeRTOS/Source/tasks.c ****  *
  12:FreeRTOS/Source/tasks.c ****  * The above copyright notice and this permission notice shall be included in all
  13:FreeRTOS/Source/tasks.c ****  * copies or substantial portions of the Software. If you wish to use our Amazon
  14:FreeRTOS/Source/tasks.c ****  * FreeRTOS name, please do so in a fair use way that does not cause confusion.
  15:FreeRTOS/Source/tasks.c ****  *
  16:FreeRTOS/Source/tasks.c ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  17:FreeRTOS/Source/tasks.c ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
  18:FreeRTOS/Source/tasks.c ****  * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
  19:FreeRTOS/Source/tasks.c ****  * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
  20:FreeRTOS/Source/tasks.c ****  * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  21:FreeRTOS/Source/tasks.c ****  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  22:FreeRTOS/Source/tasks.c ****  *
  23:FreeRTOS/Source/tasks.c ****  * http://www.FreeRTOS.org
  24:FreeRTOS/Source/tasks.c ****  * http://aws.amazon.com/freertos
  25:FreeRTOS/Source/tasks.c ****  *
  26:FreeRTOS/Source/tasks.c ****  * 1 tab == 4 spaces!
  27:FreeRTOS/Source/tasks.c ****  */
  28:FreeRTOS/Source/tasks.c **** 
  29:FreeRTOS/Source/tasks.c **** /* Standard includes. */
  30:FreeRTOS/Source/tasks.c **** #include <stdlib.h>
  31:FreeRTOS/Source/tasks.c **** #include <string.h>
  32:FreeRTOS/Source/tasks.c **** 
  33:FreeRTOS/Source/tasks.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  34:FreeRTOS/Source/tasks.c **** all the API functions to use the MPU wrappers.  That should only be done when
  35:FreeRTOS/Source/tasks.c **** task.h is included from an application file. */
  36:FreeRTOS/Source/tasks.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  37:FreeRTOS/Source/tasks.c **** 
  38:FreeRTOS/Source/tasks.c **** /* FreeRTOS includes. */
  39:FreeRTOS/Source/tasks.c **** #include "FreeRTOS.h"
  40:FreeRTOS/Source/tasks.c **** #include "task.h"
  41:FreeRTOS/Source/tasks.c **** #include "timers.h"
  42:FreeRTOS/Source/tasks.c **** #include "stack_macros.h"
  43:FreeRTOS/Source/tasks.c **** 
  44:FreeRTOS/Source/tasks.c **** /* Lint e961 and e750 are suppressed as a MISRA exception justified because the
  45:FreeRTOS/Source/tasks.c **** MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined for the
  46:FreeRTOS/Source/tasks.c **** header files above, but not in this file, in order to generate the correct
  47:FreeRTOS/Source/tasks.c **** privileged Vs unprivileged linkage and placement. */
  48:FreeRTOS/Source/tasks.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750. */
  49:FreeRTOS/Source/tasks.c **** 
  50:FreeRTOS/Source/tasks.c **** /* Set configUSE_STATS_FORMATTING_FUNCTIONS to 2 to include the stats formatting
  51:FreeRTOS/Source/tasks.c **** functions but without including stdio.h here. */
  52:FreeRTOS/Source/tasks.c **** #if ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 )
  53:FreeRTOS/Source/tasks.c **** 	/* At the bottom of this file are two optional functions that can be used
  54:FreeRTOS/Source/tasks.c **** 	to generate human readable text from the raw data generated by the
  55:FreeRTOS/Source/tasks.c **** 	uxTaskGetSystemState() function.  Note the formatting functions are provided
  56:FreeRTOS/Source/tasks.c **** 	for convenience only, and are NOT considered part of the kernel. */
  57:FreeRTOS/Source/tasks.c **** 	#include <stdio.h>
  58:FreeRTOS/Source/tasks.c **** #endif /* configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) */
  59:FreeRTOS/Source/tasks.c **** 
  60:FreeRTOS/Source/tasks.c **** #if( configUSE_PREEMPTION == 0 )
  61:FreeRTOS/Source/tasks.c **** 	/* If the cooperative scheduler is being used then a yield should not be
  62:FreeRTOS/Source/tasks.c **** 	performed just because a higher priority task has been woken. */
  63:FreeRTOS/Source/tasks.c **** 	#define taskYIELD_IF_USING_PREEMPTION()
  64:FreeRTOS/Source/tasks.c **** #else
  65:FreeRTOS/Source/tasks.c **** 	#define taskYIELD_IF_USING_PREEMPTION() portYIELD_WITHIN_API()
  66:FreeRTOS/Source/tasks.c **** #endif
  67:FreeRTOS/Source/tasks.c **** 
  68:FreeRTOS/Source/tasks.c **** /* Values that can be assigned to the ucNotifyState member of the TCB. */
  69:FreeRTOS/Source/tasks.c **** #define taskNOT_WAITING_NOTIFICATION	( ( uint8_t ) 0 )
  70:FreeRTOS/Source/tasks.c **** #define taskWAITING_NOTIFICATION		( ( uint8_t ) 1 )
  71:FreeRTOS/Source/tasks.c **** #define taskNOTIFICATION_RECEIVED		( ( uint8_t ) 2 )
  72:FreeRTOS/Source/tasks.c **** 
  73:FreeRTOS/Source/tasks.c **** /*
  74:FreeRTOS/Source/tasks.c ****  * The value used to fill the stack of a task when the task is created.  This
  75:FreeRTOS/Source/tasks.c ****  * is used purely for checking the high water mark for tasks.
  76:FreeRTOS/Source/tasks.c ****  */
  77:FreeRTOS/Source/tasks.c **** #define tskSTACK_FILL_BYTE	( 0xa5U )
  78:FreeRTOS/Source/tasks.c **** 
  79:FreeRTOS/Source/tasks.c **** /* Sometimes the FreeRTOSConfig.h settings only allow a task to be created using
  80:FreeRTOS/Source/tasks.c **** dynamically allocated RAM, in which case when any task is deleted it is known
  81:FreeRTOS/Source/tasks.c **** that both the task's stack and TCB need to be freed.  Sometimes the
  82:FreeRTOS/Source/tasks.c **** FreeRTOSConfig.h settings only allow a task to be created using statically
  83:FreeRTOS/Source/tasks.c **** allocated RAM, in which case when any task is deleted it is known that neither
  84:FreeRTOS/Source/tasks.c **** the task's stack or TCB should be freed.  Sometimes the FreeRTOSConfig.h
  85:FreeRTOS/Source/tasks.c **** settings allow a task to be created using either statically or dynamically
  86:FreeRTOS/Source/tasks.c **** allocated RAM, in which case a member of the TCB is used to record whether the
  87:FreeRTOS/Source/tasks.c **** stack and/or TCB were allocated statically or dynamically, so when a task is
  88:FreeRTOS/Source/tasks.c **** deleted the RAM that was allocated dynamically is freed again and no attempt is
  89:FreeRTOS/Source/tasks.c **** made to free the RAM that was allocated statically.
  90:FreeRTOS/Source/tasks.c **** tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE is only true if it is possible for a
  91:FreeRTOS/Source/tasks.c **** task to be created using either statically or dynamically allocated RAM.  Note
  92:FreeRTOS/Source/tasks.c **** that if portUSING_MPU_WRAPPERS is 1 then a protected task can be created with
  93:FreeRTOS/Source/tasks.c **** a statically allocated stack and a dynamically allocated TCB.
  94:FreeRTOS/Source/tasks.c **** !!!NOTE!!! If the definition of tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE is
  95:FreeRTOS/Source/tasks.c **** changed then the definition of StaticTask_t must also be updated. */
  96:FreeRTOS/Source/tasks.c **** #define tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE	( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( c
  97:FreeRTOS/Source/tasks.c **** #define tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB 		( ( uint8_t ) 0 )
  98:FreeRTOS/Source/tasks.c **** #define tskSTATICALLY_ALLOCATED_STACK_ONLY 			( ( uint8_t ) 1 )
  99:FreeRTOS/Source/tasks.c **** #define tskSTATICALLY_ALLOCATED_STACK_AND_TCB		( ( uint8_t ) 2 )
 100:FreeRTOS/Source/tasks.c **** 
 101:FreeRTOS/Source/tasks.c **** /* If any of the following are set then task stacks are filled with a known
 102:FreeRTOS/Source/tasks.c **** value so the high water mark can be determined.  If none of the following are
 103:FreeRTOS/Source/tasks.c **** set then don't fill the stack so there is no unnecessary dependency on memset. */
 104:FreeRTOS/Source/tasks.c **** #if( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTas
 105:FreeRTOS/Source/tasks.c **** 	#define tskSET_NEW_STACKS_TO_KNOWN_VALUE	1
 106:FreeRTOS/Source/tasks.c **** #else
 107:FreeRTOS/Source/tasks.c **** 	#define tskSET_NEW_STACKS_TO_KNOWN_VALUE	0
 108:FreeRTOS/Source/tasks.c **** #endif
 109:FreeRTOS/Source/tasks.c **** 
 110:FreeRTOS/Source/tasks.c **** /*
 111:FreeRTOS/Source/tasks.c ****  * Macros used by vListTask to indicate which state a task is in.
 112:FreeRTOS/Source/tasks.c ****  */
 113:FreeRTOS/Source/tasks.c **** #define tskBLOCKED_CHAR		( 'B' )
 114:FreeRTOS/Source/tasks.c **** #define tskREADY_CHAR		( 'R' )
 115:FreeRTOS/Source/tasks.c **** #define tskDELETED_CHAR		( 'D' )
 116:FreeRTOS/Source/tasks.c **** #define tskSUSPENDED_CHAR	( 'S' )
 117:FreeRTOS/Source/tasks.c **** 
 118:FreeRTOS/Source/tasks.c **** /*
 119:FreeRTOS/Source/tasks.c ****  * Some kernel aware debuggers require the data the debugger needs access to be
 120:FreeRTOS/Source/tasks.c ****  * global, rather than file scope.
 121:FreeRTOS/Source/tasks.c ****  */
 122:FreeRTOS/Source/tasks.c **** #ifdef portREMOVE_STATIC_QUALIFIER
 123:FreeRTOS/Source/tasks.c **** 	#define static
 124:FreeRTOS/Source/tasks.c **** #endif
 125:FreeRTOS/Source/tasks.c **** 
 126:FreeRTOS/Source/tasks.c **** /* The name allocated to the Idle task.  This can be overridden by defining
 127:FreeRTOS/Source/tasks.c **** configIDLE_TASK_NAME in FreeRTOSConfig.h. */
 128:FreeRTOS/Source/tasks.c **** #ifndef configIDLE_TASK_NAME
 129:FreeRTOS/Source/tasks.c **** 	#define configIDLE_TASK_NAME "IDLE"
 130:FreeRTOS/Source/tasks.c **** #endif
 131:FreeRTOS/Source/tasks.c **** 
 132:FreeRTOS/Source/tasks.c **** #if ( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 )
 133:FreeRTOS/Source/tasks.c **** 
 134:FreeRTOS/Source/tasks.c **** 	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 0 then task selection is
 135:FreeRTOS/Source/tasks.c **** 	performed in a generic way that is not optimised to any particular
 136:FreeRTOS/Source/tasks.c **** 	microcontroller architecture. */
 137:FreeRTOS/Source/tasks.c **** 
 138:FreeRTOS/Source/tasks.c **** 	/* uxTopReadyPriority holds the priority of the highest priority ready
 139:FreeRTOS/Source/tasks.c **** 	state task. */
 140:FreeRTOS/Source/tasks.c **** 	#define taskRECORD_READY_PRIORITY( uxPriority )														\
 141:FreeRTOS/Source/tasks.c **** 	{																									\
 142:FreeRTOS/Source/tasks.c **** 		if( ( uxPriority ) > uxTopReadyPriority )														\
 143:FreeRTOS/Source/tasks.c **** 		{																								\
 144:FreeRTOS/Source/tasks.c **** 			uxTopReadyPriority = ( uxPriority );														\
 145:FreeRTOS/Source/tasks.c **** 		}																								\
 146:FreeRTOS/Source/tasks.c **** 	} /* taskRECORD_READY_PRIORITY */
 147:FreeRTOS/Source/tasks.c **** 
 148:FreeRTOS/Source/tasks.c **** 	/*-----------------------------------------------------------*/
 149:FreeRTOS/Source/tasks.c **** 
 150:FreeRTOS/Source/tasks.c **** 	#define taskSELECT_HIGHEST_PRIORITY_TASK()															\
 151:FreeRTOS/Source/tasks.c **** 	{																									\
 152:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxTopPriority = uxTopReadyPriority;														\
 153:FreeRTOS/Source/tasks.c **** 																										\
 154:FreeRTOS/Source/tasks.c **** 		/* Find the highest priority queue that contains ready tasks. */								\
 155:FreeRTOS/Source/tasks.c **** 		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopPriority ] ) ) )							\
 156:FreeRTOS/Source/tasks.c **** 		{																								\
 157:FreeRTOS/Source/tasks.c **** 			configASSERT( uxTopPriority );																\
 158:FreeRTOS/Source/tasks.c **** 			--uxTopPriority;																			\
 159:FreeRTOS/Source/tasks.c **** 		}																								\
 160:FreeRTOS/Source/tasks.c **** 																										\
 161:FreeRTOS/Source/tasks.c **** 		/* listGET_OWNER_OF_NEXT_ENTRY indexes through the list, so the tasks of						\
 162:FreeRTOS/Source/tasks.c **** 		the	same priority get an equal share of the processor time. */									\
 163:FreeRTOS/Source/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) );			\
 164:FreeRTOS/Source/tasks.c **** 		uxTopReadyPriority = uxTopPriority;																\
 165:FreeRTOS/Source/tasks.c **** 	} /* taskSELECT_HIGHEST_PRIORITY_TASK */
 166:FreeRTOS/Source/tasks.c **** 
 167:FreeRTOS/Source/tasks.c **** 	/*-----------------------------------------------------------*/
 168:FreeRTOS/Source/tasks.c **** 
 169:FreeRTOS/Source/tasks.c **** 	/* Define away taskRESET_READY_PRIORITY() and portRESET_READY_PRIORITY() as
 170:FreeRTOS/Source/tasks.c **** 	they are only required when a port optimised method of task selection is
 171:FreeRTOS/Source/tasks.c **** 	being used. */
 172:FreeRTOS/Source/tasks.c **** 	#define taskRESET_READY_PRIORITY( uxPriority )
 173:FreeRTOS/Source/tasks.c **** 	#define portRESET_READY_PRIORITY( uxPriority, uxTopReadyPriority )
 174:FreeRTOS/Source/tasks.c **** 
 175:FreeRTOS/Source/tasks.c **** #else /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
 176:FreeRTOS/Source/tasks.c **** 
 177:FreeRTOS/Source/tasks.c **** 	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 1 then task selection is
 178:FreeRTOS/Source/tasks.c **** 	performed in a way that is tailored to the particular microcontroller
 179:FreeRTOS/Source/tasks.c **** 	architecture being used. */
 180:FreeRTOS/Source/tasks.c **** 
 181:FreeRTOS/Source/tasks.c **** 	/* A port optimised version is provided.  Call the port defined macros. */
 182:FreeRTOS/Source/tasks.c **** 	#define taskRECORD_READY_PRIORITY( uxPriority )	portRECORD_READY_PRIORITY( uxPriority, uxTopReadyP
 183:FreeRTOS/Source/tasks.c **** 
 184:FreeRTOS/Source/tasks.c **** 	/*-----------------------------------------------------------*/
 185:FreeRTOS/Source/tasks.c **** 
 186:FreeRTOS/Source/tasks.c **** 	#define taskSELECT_HIGHEST_PRIORITY_TASK()														\
 187:FreeRTOS/Source/tasks.c **** 	{																								\
 188:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxTopPriority;																		\
 189:FreeRTOS/Source/tasks.c **** 																									\
 190:FreeRTOS/Source/tasks.c **** 		/* Find the highest priority list that contains ready tasks. */								\
 191:FreeRTOS/Source/tasks.c **** 		portGET_HIGHEST_PRIORITY( uxTopPriority, uxTopReadyPriority );								\
 192:FreeRTOS/Source/tasks.c **** 		configASSERT( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ uxTopPriority ] ) ) > 0 );		\
 193:FreeRTOS/Source/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) );		\
 194:FreeRTOS/Source/tasks.c **** 	} /* taskSELECT_HIGHEST_PRIORITY_TASK() */
 195:FreeRTOS/Source/tasks.c **** 
 196:FreeRTOS/Source/tasks.c **** 	/*-----------------------------------------------------------*/
 197:FreeRTOS/Source/tasks.c **** 
 198:FreeRTOS/Source/tasks.c **** 	/* A port optimised version is provided, call it only if the TCB being reset
 199:FreeRTOS/Source/tasks.c **** 	is being referenced from a ready list.  If it is referenced from a delayed
 200:FreeRTOS/Source/tasks.c **** 	or suspended list then it won't be in a ready list. */
 201:FreeRTOS/Source/tasks.c **** 	#define taskRESET_READY_PRIORITY( uxPriority )														\
 202:FreeRTOS/Source/tasks.c **** 	{																									\
 203:FreeRTOS/Source/tasks.c **** 		if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ ( uxPriority ) ] ) ) == ( UBaseType_t ) 0 )	\
 204:FreeRTOS/Source/tasks.c **** 		{																								\
 205:FreeRTOS/Source/tasks.c **** 			portRESET_READY_PRIORITY( ( uxPriority ), ( uxTopReadyPriority ) );							\
 206:FreeRTOS/Source/tasks.c **** 		}																								\
 207:FreeRTOS/Source/tasks.c **** 	}
 208:FreeRTOS/Source/tasks.c **** 
 209:FreeRTOS/Source/tasks.c **** #endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
 210:FreeRTOS/Source/tasks.c **** 
 211:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 212:FreeRTOS/Source/tasks.c **** 
 213:FreeRTOS/Source/tasks.c **** /* pxDelayedTaskList and pxOverflowDelayedTaskList are switched when the tick
 214:FreeRTOS/Source/tasks.c **** count overflows. */
 215:FreeRTOS/Source/tasks.c **** #define taskSWITCH_DELAYED_LISTS()																	\
 216:FreeRTOS/Source/tasks.c **** {																									\
 217:FreeRTOS/Source/tasks.c **** 	List_t *pxTemp;																					\
 218:FreeRTOS/Source/tasks.c **** 																									\
 219:FreeRTOS/Source/tasks.c **** 	/* The delayed tasks list should be empty when the lists are switched. */						\
 220:FreeRTOS/Source/tasks.c **** 	configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );										\
 221:FreeRTOS/Source/tasks.c **** 																									\
 222:FreeRTOS/Source/tasks.c **** 	pxTemp = pxDelayedTaskList;																		\
 223:FreeRTOS/Source/tasks.c **** 	pxDelayedTaskList = pxOverflowDelayedTaskList;													\
 224:FreeRTOS/Source/tasks.c **** 	pxOverflowDelayedTaskList = pxTemp;																\
 225:FreeRTOS/Source/tasks.c **** 	xNumOfOverflows++;																				\
 226:FreeRTOS/Source/tasks.c **** 	prvResetNextTaskUnblockTime();																	\
 227:FreeRTOS/Source/tasks.c **** }
 228:FreeRTOS/Source/tasks.c **** 
 229:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 230:FreeRTOS/Source/tasks.c **** 
 231:FreeRTOS/Source/tasks.c **** /*
 232:FreeRTOS/Source/tasks.c ****  * Place the task represented by pxTCB into the appropriate ready list for
 233:FreeRTOS/Source/tasks.c ****  * the task.  It is inserted at the end of the list.
 234:FreeRTOS/Source/tasks.c ****  */
 235:FreeRTOS/Source/tasks.c **** #define prvAddTaskToReadyList( pxTCB )																\
 236:FreeRTOS/Source/tasks.c **** 	traceMOVED_TASK_TO_READY_STATE( pxTCB );														\
 237:FreeRTOS/Source/tasks.c **** 	taskRECORD_READY_PRIORITY( ( pxTCB )->uxPriority );												\
 238:FreeRTOS/Source/tasks.c **** 	vListInsertEnd( &( pxReadyTasksLists[ ( pxTCB )->uxPriority ] ), &( ( pxTCB )->xStateListItem ) );
 239:FreeRTOS/Source/tasks.c **** 	tracePOST_MOVED_TASK_TO_READY_STATE( pxTCB )
 240:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 241:FreeRTOS/Source/tasks.c **** 
 242:FreeRTOS/Source/tasks.c **** /*
 243:FreeRTOS/Source/tasks.c ****  * Several functions take an TaskHandle_t parameter that can optionally be NULL,
 244:FreeRTOS/Source/tasks.c ****  * where NULL is used to indicate that the handle of the currently executing
 245:FreeRTOS/Source/tasks.c ****  * task should be used in place of the parameter.  This macro simply checks to
 246:FreeRTOS/Source/tasks.c ****  * see if the parameter is NULL and returns a pointer to the appropriate TCB.
 247:FreeRTOS/Source/tasks.c ****  */
 248:FreeRTOS/Source/tasks.c **** #define prvGetTCBFromHandle( pxHandle ) ( ( ( pxHandle ) == NULL ) ? ( TCB_t * ) pxCurrentTCB : ( T
 249:FreeRTOS/Source/tasks.c **** 
 250:FreeRTOS/Source/tasks.c **** /* The item value of the event list item is normally used to hold the priority
 251:FreeRTOS/Source/tasks.c **** of the task to which it belongs (coded to allow it to be held in reverse
 252:FreeRTOS/Source/tasks.c **** priority order).  However, it is occasionally borrowed for other purposes.  It
 253:FreeRTOS/Source/tasks.c **** is important its value is not updated due to a task priority change while it is
 254:FreeRTOS/Source/tasks.c **** being used for another purpose.  The following bit definition is used to inform
 255:FreeRTOS/Source/tasks.c **** the scheduler that the value should not be changed - in which case it is the
 256:FreeRTOS/Source/tasks.c **** responsibility of whichever module is using the value to ensure it gets set back
 257:FreeRTOS/Source/tasks.c **** to its original value when it is released. */
 258:FreeRTOS/Source/tasks.c **** #if( configUSE_16_BIT_TICKS == 1 )
 259:FreeRTOS/Source/tasks.c **** 	#define taskEVENT_LIST_ITEM_VALUE_IN_USE	0x8000U
 260:FreeRTOS/Source/tasks.c **** #else
 261:FreeRTOS/Source/tasks.c **** 	#define taskEVENT_LIST_ITEM_VALUE_IN_USE	0x80000000UL
 262:FreeRTOS/Source/tasks.c **** #endif
 263:FreeRTOS/Source/tasks.c **** 
 264:FreeRTOS/Source/tasks.c **** /*
 265:FreeRTOS/Source/tasks.c ****  * Task control block.  A task control block (TCB) is allocated for each task,
 266:FreeRTOS/Source/tasks.c ****  * and stores task state information, including a pointer to the task's context
 267:FreeRTOS/Source/tasks.c ****  * (the task's run time environment, including register values)
 268:FreeRTOS/Source/tasks.c ****  */
 269:FreeRTOS/Source/tasks.c **** typedef struct tskTaskControlBlock
 270:FreeRTOS/Source/tasks.c **** {
 271:FreeRTOS/Source/tasks.c **** 	volatile StackType_t	*pxTopOfStack;	/*< Points to the location of the last item placed on the task
 272:FreeRTOS/Source/tasks.c **** 
 273:FreeRTOS/Source/tasks.c **** 	#if ( portUSING_MPU_WRAPPERS == 1 )
 274:FreeRTOS/Source/tasks.c **** 		xMPU_SETTINGS	xMPUSettings;		/*< The MPU settings are defined as part of the port layer.  THIS MU
 275:FreeRTOS/Source/tasks.c **** 	#endif
 276:FreeRTOS/Source/tasks.c **** 
 277:FreeRTOS/Source/tasks.c **** 	ListItem_t			xStateListItem;	/*< The list that the state list item of a task is reference from den
 278:FreeRTOS/Source/tasks.c **** 	ListItem_t			xEventListItem;		/*< Used to reference a task from an event list. */
 279:FreeRTOS/Source/tasks.c **** 	UBaseType_t			uxPriority;			/*< The priority of the task.  0 is the lowest priority. */
 280:FreeRTOS/Source/tasks.c **** 	StackType_t			*pxStack;			/*< Points to the start of the stack. */
 281:FreeRTOS/Source/tasks.c **** 	char				pcTaskName[ configMAX_TASK_NAME_LEN ];/*< Descriptive name given to the task when created.
 282:FreeRTOS/Source/tasks.c **** 
 283:FreeRTOS/Source/tasks.c **** 	#if ( ( portSTACK_GROWTH > 0 ) || ( configRECORD_STACK_HIGH_ADDRESS == 1 ) )
 284:FreeRTOS/Source/tasks.c **** 		StackType_t		*pxEndOfStack;		/*< Points to the highest valid address for the stack. */
 285:FreeRTOS/Source/tasks.c **** 	#endif
 286:FreeRTOS/Source/tasks.c **** 
 287:FreeRTOS/Source/tasks.c **** 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
 288:FreeRTOS/Source/tasks.c **** 		UBaseType_t		uxCriticalNesting;	/*< Holds the critical section nesting depth for ports that do no
 289:FreeRTOS/Source/tasks.c **** 	#endif
 290:FreeRTOS/Source/tasks.c **** 
 291:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_TRACE_FACILITY == 1 )
 292:FreeRTOS/Source/tasks.c **** 		UBaseType_t		uxTCBNumber;		/*< Stores a number that increments each time a TCB is created.  It al
 293:FreeRTOS/Source/tasks.c **** 		UBaseType_t		uxTaskNumber;		/*< Stores a number specifically for use by third party trace code. *
 294:FreeRTOS/Source/tasks.c **** 	#endif
 295:FreeRTOS/Source/tasks.c **** 
 296:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
 297:FreeRTOS/Source/tasks.c **** 		UBaseType_t		uxBasePriority;		/*< The priority last assigned to the task - used by the priority i
 298:FreeRTOS/Source/tasks.c **** 		UBaseType_t		uxMutexesHeld;
 299:FreeRTOS/Source/tasks.c **** 	#endif
 300:FreeRTOS/Source/tasks.c **** 
 301:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
 302:FreeRTOS/Source/tasks.c **** 		TaskHookFunction_t pxTaskTag;
 303:FreeRTOS/Source/tasks.c **** 	#endif
 304:FreeRTOS/Source/tasks.c **** 
 305:FreeRTOS/Source/tasks.c **** 	#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS > 0 )
 306:FreeRTOS/Source/tasks.c **** 		void			*pvThreadLocalStoragePointers[ configNUM_THREAD_LOCAL_STORAGE_POINTERS ];
 307:FreeRTOS/Source/tasks.c **** 	#endif
 308:FreeRTOS/Source/tasks.c **** 
 309:FreeRTOS/Source/tasks.c **** 	#if( configGENERATE_RUN_TIME_STATS == 1 )
 310:FreeRTOS/Source/tasks.c **** 		uint32_t		ulRunTimeCounter;	/*< Stores the amount of time the task has spent in the Running state
 311:FreeRTOS/Source/tasks.c **** 	#endif
 312:FreeRTOS/Source/tasks.c **** 
 313:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_NEWLIB_REENTRANT == 1 )
 314:FreeRTOS/Source/tasks.c **** 		/* Allocate a Newlib reent structure that is specific to this task.
 315:FreeRTOS/Source/tasks.c **** 		Note Newlib support has been included by popular demand, but is not
 316:FreeRTOS/Source/tasks.c **** 		used by the FreeRTOS maintainers themselves.  FreeRTOS is not
 317:FreeRTOS/Source/tasks.c **** 		responsible for resulting newlib operation.  User must be familiar with
 318:FreeRTOS/Source/tasks.c **** 		newlib and must provide system-wide implementations of the necessary
 319:FreeRTOS/Source/tasks.c **** 		stubs. Be warned that (at the time of writing) the current newlib design
 320:FreeRTOS/Source/tasks.c **** 		implements a system-wide malloc() that must be provided with locks. */
 321:FreeRTOS/Source/tasks.c **** 		struct	_reent xNewLib_reent;
 322:FreeRTOS/Source/tasks.c **** 	#endif
 323:FreeRTOS/Source/tasks.c **** 
 324:FreeRTOS/Source/tasks.c **** 	#if( configUSE_TASK_NOTIFICATIONS == 1 )
 325:FreeRTOS/Source/tasks.c **** 		volatile uint32_t ulNotifiedValue;
 326:FreeRTOS/Source/tasks.c **** 		volatile uint8_t ucNotifyState;
 327:FreeRTOS/Source/tasks.c **** 	#endif
 328:FreeRTOS/Source/tasks.c **** 
 329:FreeRTOS/Source/tasks.c **** 	/* See the comments above the definition of
 330:FreeRTOS/Source/tasks.c **** 	tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE. */
 331:FreeRTOS/Source/tasks.c **** 	#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 Macro has been consolidated for
 332:FreeRTOS/Source/tasks.c **** 		uint8_t	ucStaticallyAllocated; 		/*< Set to pdTRUE if the task is a statically allocated to ensur
 333:FreeRTOS/Source/tasks.c **** 	#endif
 334:FreeRTOS/Source/tasks.c **** 
 335:FreeRTOS/Source/tasks.c **** 	#if( INCLUDE_xTaskAbortDelay == 1 )
 336:FreeRTOS/Source/tasks.c **** 		uint8_t ucDelayAborted;
 337:FreeRTOS/Source/tasks.c **** 	#endif
 338:FreeRTOS/Source/tasks.c **** 
 339:FreeRTOS/Source/tasks.c **** } tskTCB;
 340:FreeRTOS/Source/tasks.c **** 
 341:FreeRTOS/Source/tasks.c **** /* The old tskTCB name is maintained above then typedefed to the new TCB_t name
 342:FreeRTOS/Source/tasks.c **** below to enable the use of older kernel aware debuggers. */
 343:FreeRTOS/Source/tasks.c **** typedef tskTCB TCB_t;
 344:FreeRTOS/Source/tasks.c **** 
 345:FreeRTOS/Source/tasks.c **** /*lint -save -e956 A manual analysis and inspection has been used to determine
 346:FreeRTOS/Source/tasks.c **** which static variables must be declared volatile. */
 347:FreeRTOS/Source/tasks.c **** 
 348:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA TCB_t * volatile pxCurrentTCB = NULL;
 349:FreeRTOS/Source/tasks.c **** 
 350:FreeRTOS/Source/tasks.c **** /* Lists for ready and blocked tasks. --------------------*/
 351:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static List_t pxReadyTasksLists[ configMAX_PRIORITIES ];/*< Prioritised ready tasks
 352:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static List_t xDelayedTaskList1;						/*< Delayed tasks. */
 353:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static List_t xDelayedTaskList2;						/*< Delayed tasks (two lists are used - one f
 354:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static List_t * volatile pxDelayedTaskList;				/*< Points to the delayed task list 
 355:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static List_t * volatile pxOverflowDelayedTaskList;		/*< Points to the delayed task
 356:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static List_t xPendingReadyList;						/*< Tasks that have been readied while the sc
 357:FreeRTOS/Source/tasks.c **** 
 358:FreeRTOS/Source/tasks.c **** #if( INCLUDE_vTaskDelete == 1 )
 359:FreeRTOS/Source/tasks.c **** 
 360:FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static List_t xTasksWaitingTermination;				/*< Tasks that have been deleted - but 
 361:FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static volatile UBaseType_t uxDeletedTasksWaitingCleanUp = ( UBaseType_t ) 0U;
 362:FreeRTOS/Source/tasks.c **** 
 363:FreeRTOS/Source/tasks.c **** #endif
 364:FreeRTOS/Source/tasks.c **** 
 365:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 366:FreeRTOS/Source/tasks.c **** 
 367:FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static List_t xSuspendedTaskList;					/*< Tasks that are currently suspended. */
 368:FreeRTOS/Source/tasks.c **** 
 369:FreeRTOS/Source/tasks.c **** #endif
 370:FreeRTOS/Source/tasks.c **** 
 371:FreeRTOS/Source/tasks.c **** /* Other file private variables. --------------------------------*/
 372:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile UBaseType_t uxCurrentNumberOfTasks 	= ( UBaseType_t ) 0U;
 373:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile TickType_t xTickCount 				= ( TickType_t ) configINITIAL_TICK_COUNT
 374:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile UBaseType_t uxTopReadyPriority 		= tskIDLE_PRIORITY;
 375:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile BaseType_t xSchedulerRunning 		= pdFALSE;
 376:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile UBaseType_t uxPendedTicks 			= ( UBaseType_t ) 0U;
 377:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile BaseType_t xYieldPending 			= pdFALSE;
 378:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile BaseType_t xNumOfOverflows 			= ( BaseType_t ) 0;
 379:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static UBaseType_t uxTaskNumber 					= ( UBaseType_t ) 0U;
 380:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile TickType_t xNextTaskUnblockTime		= ( TickType_t ) 0U; /* Initialise
 381:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static TaskHandle_t xIdleTaskHandle					= NULL;			/*< Holds the handle of the idle 
 382:FreeRTOS/Source/tasks.c **** 
 383:FreeRTOS/Source/tasks.c **** /* Context switches are held pending while the scheduler is suspended.  Also,
 384:FreeRTOS/Source/tasks.c **** interrupts must not manipulate the xStateListItem of a TCB, or any of the
 385:FreeRTOS/Source/tasks.c **** lists the xStateListItem can be referenced from, if the scheduler is suspended.
 386:FreeRTOS/Source/tasks.c **** If an interrupt needs to unblock a task while the scheduler is suspended then it
 387:FreeRTOS/Source/tasks.c **** moves the task's event list item into the xPendingReadyList, ready for the
 388:FreeRTOS/Source/tasks.c **** kernel to move the task from the pending ready list into the real ready list
 389:FreeRTOS/Source/tasks.c **** when the scheduler is unsuspended.  The pending ready list itself can only be
 390:FreeRTOS/Source/tasks.c **** accessed from a critical section. */
 391:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile UBaseType_t uxSchedulerSuspended	= ( UBaseType_t ) pdFALSE;
 392:FreeRTOS/Source/tasks.c **** 
 393:FreeRTOS/Source/tasks.c **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
 394:FreeRTOS/Source/tasks.c **** 
 395:FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static uint32_t ulTaskSwitchedInTime = 0UL;	/*< Holds the value of a timer/counter
 396:FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static uint32_t ulTotalRunTime = 0UL;		/*< Holds the total amount of execution tim
 397:FreeRTOS/Source/tasks.c **** 
 398:FreeRTOS/Source/tasks.c **** #endif
 399:FreeRTOS/Source/tasks.c **** 
 400:FreeRTOS/Source/tasks.c **** /*lint -restore */
 401:FreeRTOS/Source/tasks.c **** 
 402:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 403:FreeRTOS/Source/tasks.c **** 
 404:FreeRTOS/Source/tasks.c **** /* Callback function prototypes. --------------------------*/
 405:FreeRTOS/Source/tasks.c **** #if(  configCHECK_FOR_STACK_OVERFLOW > 0 )
 406:FreeRTOS/Source/tasks.c **** 
 407:FreeRTOS/Source/tasks.c **** 	extern void vApplicationStackOverflowHook( TaskHandle_t xTask, char *pcTaskName );
 408:FreeRTOS/Source/tasks.c **** 
 409:FreeRTOS/Source/tasks.c **** #endif
 410:FreeRTOS/Source/tasks.c **** 
 411:FreeRTOS/Source/tasks.c **** #if( configUSE_TICK_HOOK > 0 )
 412:FreeRTOS/Source/tasks.c **** 
 413:FreeRTOS/Source/tasks.c **** 	extern void vApplicationTickHook( void );
 414:FreeRTOS/Source/tasks.c **** 
 415:FreeRTOS/Source/tasks.c **** #endif
 416:FreeRTOS/Source/tasks.c **** 
 417:FreeRTOS/Source/tasks.c **** #if( configSUPPORT_STATIC_ALLOCATION == 1 )
 418:FreeRTOS/Source/tasks.c **** 
 419:FreeRTOS/Source/tasks.c **** 	extern void vApplicationGetIdleTaskMemory( StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxI
 420:FreeRTOS/Source/tasks.c **** 
 421:FreeRTOS/Source/tasks.c **** #endif
 422:FreeRTOS/Source/tasks.c **** 
 423:FreeRTOS/Source/tasks.c **** /* File private functions. --------------------------------*/
 424:FreeRTOS/Source/tasks.c **** 
 425:FreeRTOS/Source/tasks.c **** /**
 426:FreeRTOS/Source/tasks.c ****  * Utility task that simply returns pdTRUE if the task referenced by xTask is
 427:FreeRTOS/Source/tasks.c ****  * currently in the Suspended state, or pdFALSE if the task referenced by xTask
 428:FreeRTOS/Source/tasks.c ****  * is in any other state.
 429:FreeRTOS/Source/tasks.c ****  */
 430:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 431:FreeRTOS/Source/tasks.c **** 
 432:FreeRTOS/Source/tasks.c **** 	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
 433:FreeRTOS/Source/tasks.c **** 
 434:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
 435:FreeRTOS/Source/tasks.c **** 
 436:FreeRTOS/Source/tasks.c **** /*
 437:FreeRTOS/Source/tasks.c ****  * Utility to ready all the lists used by the scheduler.  This is called
 438:FreeRTOS/Source/tasks.c ****  * automatically upon the creation of the first task.
 439:FreeRTOS/Source/tasks.c ****  */
 440:FreeRTOS/Source/tasks.c **** static void prvInitialiseTaskLists( void ) PRIVILEGED_FUNCTION;
 441:FreeRTOS/Source/tasks.c **** 
 442:FreeRTOS/Source/tasks.c **** /*
 443:FreeRTOS/Source/tasks.c ****  * The idle task, which as all tasks is implemented as a never ending loop.
 444:FreeRTOS/Source/tasks.c ****  * The idle task is automatically created and added to the ready lists upon
 445:FreeRTOS/Source/tasks.c ****  * creation of the first user task.
 446:FreeRTOS/Source/tasks.c ****  *
 447:FreeRTOS/Source/tasks.c ****  * The portTASK_FUNCTION_PROTO() macro is used to allow port/compiler specific
 448:FreeRTOS/Source/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
 449:FreeRTOS/Source/tasks.c ****  *
 450:FreeRTOS/Source/tasks.c ****  * void prvIdleTask( void *pvParameters );
 451:FreeRTOS/Source/tasks.c ****  *
 452:FreeRTOS/Source/tasks.c ****  */
 453:FreeRTOS/Source/tasks.c **** static portTASK_FUNCTION_PROTO( prvIdleTask, pvParameters );
 454:FreeRTOS/Source/tasks.c **** 
 455:FreeRTOS/Source/tasks.c **** /*
 456:FreeRTOS/Source/tasks.c ****  * Utility to free all memory allocated by the scheduler to hold a TCB,
 457:FreeRTOS/Source/tasks.c ****  * including the stack pointed to by the TCB.
 458:FreeRTOS/Source/tasks.c ****  *
 459:FreeRTOS/Source/tasks.c ****  * This does not free memory allocated by the task itself (i.e. memory
 460:FreeRTOS/Source/tasks.c ****  * allocated by calls to pvPortMalloc from within the tasks application code).
 461:FreeRTOS/Source/tasks.c ****  */
 462:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 463:FreeRTOS/Source/tasks.c **** 
 464:FreeRTOS/Source/tasks.c **** 	static void prvDeleteTCB( TCB_t *pxTCB ) PRIVILEGED_FUNCTION;
 465:FreeRTOS/Source/tasks.c **** 
 466:FreeRTOS/Source/tasks.c **** #endif
 467:FreeRTOS/Source/tasks.c **** 
 468:FreeRTOS/Source/tasks.c **** /*
 469:FreeRTOS/Source/tasks.c ****  * Used only by the idle task.  This checks to see if anything has been placed
 470:FreeRTOS/Source/tasks.c ****  * in the list of tasks waiting to be deleted.  If so the task is cleaned up
 471:FreeRTOS/Source/tasks.c ****  * and its TCB deleted.
 472:FreeRTOS/Source/tasks.c ****  */
 473:FreeRTOS/Source/tasks.c **** static void prvCheckTasksWaitingTermination( void ) PRIVILEGED_FUNCTION;
 474:FreeRTOS/Source/tasks.c **** 
 475:FreeRTOS/Source/tasks.c **** /*
 476:FreeRTOS/Source/tasks.c ****  * The currently executing task is entering the Blocked state.  Add the task to
 477:FreeRTOS/Source/tasks.c ****  * either the current or the overflow delayed task list.
 478:FreeRTOS/Source/tasks.c ****  */
 479:FreeRTOS/Source/tasks.c **** static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockInde
 480:FreeRTOS/Source/tasks.c **** 
 481:FreeRTOS/Source/tasks.c **** /*
 482:FreeRTOS/Source/tasks.c ****  * Fills an TaskStatus_t structure with information on each task that is
 483:FreeRTOS/Source/tasks.c ****  * referenced from the pxList list (which may be a ready list, a delayed list,
 484:FreeRTOS/Source/tasks.c ****  * a suspended list, etc.).
 485:FreeRTOS/Source/tasks.c ****  *
 486:FreeRTOS/Source/tasks.c ****  * THIS FUNCTION IS INTENDED FOR DEBUGGING ONLY, AND SHOULD NOT BE CALLED FROM
 487:FreeRTOS/Source/tasks.c ****  * NORMAL APPLICATION CODE.
 488:FreeRTOS/Source/tasks.c ****  */
 489:FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
 490:FreeRTOS/Source/tasks.c **** 
 491:FreeRTOS/Source/tasks.c **** 	static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, 
 492:FreeRTOS/Source/tasks.c **** 
 493:FreeRTOS/Source/tasks.c **** #endif
 494:FreeRTOS/Source/tasks.c **** 
 495:FreeRTOS/Source/tasks.c **** /*
 496:FreeRTOS/Source/tasks.c ****  * Searches pxList for a task with name pcNameToQuery - returning a handle to
 497:FreeRTOS/Source/tasks.c ****  * the task if it is found, or NULL if the task is not found.
 498:FreeRTOS/Source/tasks.c ****  */
 499:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_xTaskGetHandle == 1 )
 500:FreeRTOS/Source/tasks.c **** 
 501:FreeRTOS/Source/tasks.c **** 	static TCB_t *prvSearchForNameWithinSingleList( List_t *pxList, const char pcNameToQuery[] ) PRIVI
 502:FreeRTOS/Source/tasks.c **** 
 503:FreeRTOS/Source/tasks.c **** #endif
 504:FreeRTOS/Source/tasks.c **** 
 505:FreeRTOS/Source/tasks.c **** /*
 506:FreeRTOS/Source/tasks.c ****  * When a task is created, the stack of the task is filled with a known value.
 507:FreeRTOS/Source/tasks.c ****  * This function determines the 'high water mark' of the task stack by
 508:FreeRTOS/Source/tasks.c ****  * determining how much of the stack remains at the original preset value.
 509:FreeRTOS/Source/tasks.c ****  */
 510:FreeRTOS/Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
 511:FreeRTOS/Source/tasks.c **** 
 512:FreeRTOS/Source/tasks.c **** 	static uint16_t prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte ) PRIVILEGED_FUNCTION;
 513:FreeRTOS/Source/tasks.c **** 
 514:FreeRTOS/Source/tasks.c **** #endif
 515:FreeRTOS/Source/tasks.c **** 
 516:FreeRTOS/Source/tasks.c **** /*
 517:FreeRTOS/Source/tasks.c ****  * Return the amount of time, in ticks, that will pass before the kernel will
 518:FreeRTOS/Source/tasks.c ****  * next move a task from the Blocked state to the Running state.
 519:FreeRTOS/Source/tasks.c ****  *
 520:FreeRTOS/Source/tasks.c ****  * This conditional compilation should use inequality to 0, not equality to 1.
 521:FreeRTOS/Source/tasks.c ****  * This is to ensure portSUPPRESS_TICKS_AND_SLEEP() can be called when user
 522:FreeRTOS/Source/tasks.c ****  * defined low power mode implementations require configUSE_TICKLESS_IDLE to be
 523:FreeRTOS/Source/tasks.c ****  * set to a value other than 1.
 524:FreeRTOS/Source/tasks.c ****  */
 525:FreeRTOS/Source/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
 526:FreeRTOS/Source/tasks.c **** 
 527:FreeRTOS/Source/tasks.c **** 	static TickType_t prvGetExpectedIdleTime( void ) PRIVILEGED_FUNCTION;
 528:FreeRTOS/Source/tasks.c **** 
 529:FreeRTOS/Source/tasks.c **** #endif
 530:FreeRTOS/Source/tasks.c **** 
 531:FreeRTOS/Source/tasks.c **** /*
 532:FreeRTOS/Source/tasks.c ****  * Set xNextTaskUnblockTime to the time at which the next Blocked state task
 533:FreeRTOS/Source/tasks.c ****  * will exit the Blocked state.
 534:FreeRTOS/Source/tasks.c ****  */
 535:FreeRTOS/Source/tasks.c **** static void prvResetNextTaskUnblockTime( void );
 536:FreeRTOS/Source/tasks.c **** 
 537:FreeRTOS/Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
 538:FreeRTOS/Source/tasks.c **** 
 539:FreeRTOS/Source/tasks.c **** 	/*
 540:FreeRTOS/Source/tasks.c **** 	 * Helper function used to pad task names with spaces when printing out
 541:FreeRTOS/Source/tasks.c **** 	 * human readable tables of task information.
 542:FreeRTOS/Source/tasks.c **** 	 */
 543:FreeRTOS/Source/tasks.c **** 	static char *prvWriteNameToBuffer( char *pcBuffer, const char *pcTaskName ) PRIVILEGED_FUNCTION;
 544:FreeRTOS/Source/tasks.c **** 
 545:FreeRTOS/Source/tasks.c **** #endif
 546:FreeRTOS/Source/tasks.c **** 
 547:FreeRTOS/Source/tasks.c **** /*
 548:FreeRTOS/Source/tasks.c ****  * Called after a Task_t structure has been allocated either statically or
 549:FreeRTOS/Source/tasks.c ****  * dynamically to fill in the structure's members.
 550:FreeRTOS/Source/tasks.c ****  */
 551:FreeRTOS/Source/tasks.c **** static void prvInitialiseNewTask( 	TaskFunction_t pxTaskCode,
 552:FreeRTOS/Source/tasks.c **** 									const char * const pcName, 		/*lint !e971 Unqualified char types are allowed for strings a
 553:FreeRTOS/Source/tasks.c **** 									const uint32_t ulStackDepth,
 554:FreeRTOS/Source/tasks.c **** 									void * const pvParameters,
 555:FreeRTOS/Source/tasks.c **** 									UBaseType_t uxPriority,
 556:FreeRTOS/Source/tasks.c **** 									TaskHandle_t * const pxCreatedTask,
 557:FreeRTOS/Source/tasks.c **** 									TCB_t *pxNewTCB,
 558:FreeRTOS/Source/tasks.c **** 									const MemoryRegion_t * const xRegions ) PRIVILEGED_FUNCTION;
 559:FreeRTOS/Source/tasks.c **** 
 560:FreeRTOS/Source/tasks.c **** /*
 561:FreeRTOS/Source/tasks.c ****  * Called after a new task has been created and initialised to place the task
 562:FreeRTOS/Source/tasks.c ****  * under the control of the scheduler.
 563:FreeRTOS/Source/tasks.c ****  */
 564:FreeRTOS/Source/tasks.c **** static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB ) PRIVILEGED_FUNCTION;
 565:FreeRTOS/Source/tasks.c **** 
 566:FreeRTOS/Source/tasks.c **** /*
 567:FreeRTOS/Source/tasks.c ****  * freertos_tasks_c_additions_init() should only be called if the user definable
 568:FreeRTOS/Source/tasks.c ****  * macro FREERTOS_TASKS_C_ADDITIONS_INIT() is defined, as that is the only macro
 569:FreeRTOS/Source/tasks.c ****  * called by the function.
 570:FreeRTOS/Source/tasks.c ****  */
 571:FreeRTOS/Source/tasks.c **** #ifdef FREERTOS_TASKS_C_ADDITIONS_INIT
 572:FreeRTOS/Source/tasks.c **** 
 573:FreeRTOS/Source/tasks.c **** 	static void freertos_tasks_c_additions_init( void ) PRIVILEGED_FUNCTION;
 574:FreeRTOS/Source/tasks.c **** 
 575:FreeRTOS/Source/tasks.c **** #endif
 576:FreeRTOS/Source/tasks.c **** 
 577:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 578:FreeRTOS/Source/tasks.c **** 
 579:FreeRTOS/Source/tasks.c **** #if( configSUPPORT_STATIC_ALLOCATION == 1 )
 580:FreeRTOS/Source/tasks.c **** 
 581:FreeRTOS/Source/tasks.c **** 	TaskHandle_t xTaskCreateStatic(	TaskFunction_t pxTaskCode,
 582:FreeRTOS/Source/tasks.c **** 									const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings an
 583:FreeRTOS/Source/tasks.c **** 									const uint32_t ulStackDepth,
 584:FreeRTOS/Source/tasks.c **** 									void * const pvParameters,
 585:FreeRTOS/Source/tasks.c **** 									UBaseType_t uxPriority,
 586:FreeRTOS/Source/tasks.c **** 									StackType_t * const puxStackBuffer,
 587:FreeRTOS/Source/tasks.c **** 									StaticTask_t * const pxTaskBuffer )
 588:FreeRTOS/Source/tasks.c **** 	{
 589:FreeRTOS/Source/tasks.c **** 	TCB_t *pxNewTCB;
 590:FreeRTOS/Source/tasks.c **** 	TaskHandle_t xReturn;
 591:FreeRTOS/Source/tasks.c **** 
 592:FreeRTOS/Source/tasks.c **** 		configASSERT( puxStackBuffer != NULL );
 593:FreeRTOS/Source/tasks.c **** 		configASSERT( pxTaskBuffer != NULL );
 594:FreeRTOS/Source/tasks.c **** 
 595:FreeRTOS/Source/tasks.c **** 		#if( configASSERT_DEFINED == 1 )
 596:FreeRTOS/Source/tasks.c **** 		{
 597:FreeRTOS/Source/tasks.c **** 			/* Sanity check that the size of the structure used to declare a
 598:FreeRTOS/Source/tasks.c **** 			variable of type StaticTask_t equals the size of the real task
 599:FreeRTOS/Source/tasks.c **** 			structure. */
 600:FreeRTOS/Source/tasks.c **** 			volatile size_t xSize = sizeof( StaticTask_t );
 601:FreeRTOS/Source/tasks.c **** 			configASSERT( xSize == sizeof( TCB_t ) );
 602:FreeRTOS/Source/tasks.c **** 		}
 603:FreeRTOS/Source/tasks.c **** 		#endif /* configASSERT_DEFINED */
 604:FreeRTOS/Source/tasks.c **** 
 605:FreeRTOS/Source/tasks.c **** 
 606:FreeRTOS/Source/tasks.c **** 		if( ( pxTaskBuffer != NULL ) && ( puxStackBuffer != NULL ) )
 607:FreeRTOS/Source/tasks.c **** 		{
 608:FreeRTOS/Source/tasks.c **** 			/* The memory used for the task's TCB and stack are passed into this
 609:FreeRTOS/Source/tasks.c **** 			function - use them. */
 610:FreeRTOS/Source/tasks.c **** 			pxNewTCB = ( TCB_t * ) pxTaskBuffer; /*lint !e740 Unusual cast is ok as the structures are desig
 611:FreeRTOS/Source/tasks.c **** 			pxNewTCB->pxStack = ( StackType_t * ) puxStackBuffer;
 612:FreeRTOS/Source/tasks.c **** 
 613:FreeRTOS/Source/tasks.c **** 			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 Macro has been consolidated f
 614:FreeRTOS/Source/tasks.c **** 			{
 615:FreeRTOS/Source/tasks.c **** 				/* Tasks can be created statically or dynamically, so note this
 616:FreeRTOS/Source/tasks.c **** 				task was created statically in case the task is later deleted. */
 617:FreeRTOS/Source/tasks.c **** 				pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
 618:FreeRTOS/Source/tasks.c **** 			}
 619:FreeRTOS/Source/tasks.c **** 			#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
 620:FreeRTOS/Source/tasks.c **** 
 621:FreeRTOS/Source/tasks.c **** 			prvInitialiseNewTask( pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, &xReturn, pxNe
 622:FreeRTOS/Source/tasks.c **** 			prvAddNewTaskToReadyList( pxNewTCB );
 623:FreeRTOS/Source/tasks.c **** 		}
 624:FreeRTOS/Source/tasks.c **** 		else
 625:FreeRTOS/Source/tasks.c **** 		{
 626:FreeRTOS/Source/tasks.c **** 			xReturn = NULL;
 627:FreeRTOS/Source/tasks.c **** 		}
 628:FreeRTOS/Source/tasks.c **** 
 629:FreeRTOS/Source/tasks.c **** 		return xReturn;
 630:FreeRTOS/Source/tasks.c **** 	}
 631:FreeRTOS/Source/tasks.c **** 
 632:FreeRTOS/Source/tasks.c **** #endif /* SUPPORT_STATIC_ALLOCATION */
 633:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 634:FreeRTOS/Source/tasks.c **** 
 635:FreeRTOS/Source/tasks.c **** #if( ( portUSING_MPU_WRAPPERS == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
 636:FreeRTOS/Source/tasks.c **** 
 637:FreeRTOS/Source/tasks.c **** 	BaseType_t xTaskCreateRestrictedStatic( const TaskParameters_t * const pxTaskDefinition, TaskHandl
 638:FreeRTOS/Source/tasks.c **** 	{
 639:FreeRTOS/Source/tasks.c **** 	TCB_t *pxNewTCB;
 640:FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 641:FreeRTOS/Source/tasks.c **** 
 642:FreeRTOS/Source/tasks.c **** 		configASSERT( pxTaskDefinition->puxStackBuffer != NULL );
 643:FreeRTOS/Source/tasks.c **** 		configASSERT( pxTaskDefinition->pxTaskBuffer != NULL );
 644:FreeRTOS/Source/tasks.c **** 
 645:FreeRTOS/Source/tasks.c **** 		if( ( pxTaskDefinition->puxStackBuffer != NULL ) && ( pxTaskDefinition->pxTaskBuffer != NULL ) )
 646:FreeRTOS/Source/tasks.c **** 		{
 647:FreeRTOS/Source/tasks.c **** 			/* Allocate space for the TCB.  Where the memory comes from depends
 648:FreeRTOS/Source/tasks.c **** 			on the implementation of the port malloc function and whether or
 649:FreeRTOS/Source/tasks.c **** 			not static allocation is being used. */
 650:FreeRTOS/Source/tasks.c **** 			pxNewTCB = ( TCB_t * ) pxTaskDefinition->pxTaskBuffer;
 651:FreeRTOS/Source/tasks.c **** 
 652:FreeRTOS/Source/tasks.c **** 			/* Store the stack location in the TCB. */
 653:FreeRTOS/Source/tasks.c **** 			pxNewTCB->pxStack = pxTaskDefinition->puxStackBuffer;
 654:FreeRTOS/Source/tasks.c **** 
 655:FreeRTOS/Source/tasks.c **** 			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 )
 656:FreeRTOS/Source/tasks.c **** 			{
 657:FreeRTOS/Source/tasks.c **** 				/* Tasks can be created statically or dynamically, so note this
 658:FreeRTOS/Source/tasks.c **** 				task was created statically in case the task is later deleted. */
 659:FreeRTOS/Source/tasks.c **** 				pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
 660:FreeRTOS/Source/tasks.c **** 			}
 661:FreeRTOS/Source/tasks.c **** 			#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
 662:FreeRTOS/Source/tasks.c **** 
 663:FreeRTOS/Source/tasks.c **** 			prvInitialiseNewTask(	pxTaskDefinition->pvTaskCode,
 664:FreeRTOS/Source/tasks.c **** 									pxTaskDefinition->pcName,
 665:FreeRTOS/Source/tasks.c **** 									( uint32_t ) pxTaskDefinition->usStackDepth,
 666:FreeRTOS/Source/tasks.c **** 									pxTaskDefinition->pvParameters,
 667:FreeRTOS/Source/tasks.c **** 									pxTaskDefinition->uxPriority,
 668:FreeRTOS/Source/tasks.c **** 									pxCreatedTask, pxNewTCB,
 669:FreeRTOS/Source/tasks.c **** 									pxTaskDefinition->xRegions );
 670:FreeRTOS/Source/tasks.c **** 
 671:FreeRTOS/Source/tasks.c **** 			prvAddNewTaskToReadyList( pxNewTCB );
 672:FreeRTOS/Source/tasks.c **** 			xReturn = pdPASS;
 673:FreeRTOS/Source/tasks.c **** 		}
 674:FreeRTOS/Source/tasks.c **** 
 675:FreeRTOS/Source/tasks.c **** 		return xReturn;
 676:FreeRTOS/Source/tasks.c **** 	}
 677:FreeRTOS/Source/tasks.c **** 
 678:FreeRTOS/Source/tasks.c **** #endif /* ( portUSING_MPU_WRAPPERS == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
 679:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 680:FreeRTOS/Source/tasks.c **** 
 681:FreeRTOS/Source/tasks.c **** #if( ( portUSING_MPU_WRAPPERS == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
 682:FreeRTOS/Source/tasks.c **** 
 683:FreeRTOS/Source/tasks.c **** 	BaseType_t xTaskCreateRestricted( const TaskParameters_t * const pxTaskDefinition, TaskHandle_t *p
 684:FreeRTOS/Source/tasks.c **** 	{
 685:FreeRTOS/Source/tasks.c **** 	TCB_t *pxNewTCB;
 686:FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 687:FreeRTOS/Source/tasks.c **** 
 688:FreeRTOS/Source/tasks.c **** 		configASSERT( pxTaskDefinition->puxStackBuffer );
 689:FreeRTOS/Source/tasks.c **** 
 690:FreeRTOS/Source/tasks.c **** 		if( pxTaskDefinition->puxStackBuffer != NULL )
 691:FreeRTOS/Source/tasks.c **** 		{
 692:FreeRTOS/Source/tasks.c **** 			/* Allocate space for the TCB.  Where the memory comes from depends
 693:FreeRTOS/Source/tasks.c **** 			on the implementation of the port malloc function and whether or
 694:FreeRTOS/Source/tasks.c **** 			not static allocation is being used. */
 695:FreeRTOS/Source/tasks.c **** 			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
 696:FreeRTOS/Source/tasks.c **** 
 697:FreeRTOS/Source/tasks.c **** 			if( pxNewTCB != NULL )
 698:FreeRTOS/Source/tasks.c **** 			{
 699:FreeRTOS/Source/tasks.c **** 				/* Store the stack location in the TCB. */
 700:FreeRTOS/Source/tasks.c **** 				pxNewTCB->pxStack = pxTaskDefinition->puxStackBuffer;
 701:FreeRTOS/Source/tasks.c **** 
 702:FreeRTOS/Source/tasks.c **** 				#if( configSUPPORT_STATIC_ALLOCATION == 1 )
 703:FreeRTOS/Source/tasks.c **** 				{
 704:FreeRTOS/Source/tasks.c **** 					/* Tasks can be created statically or dynamically, so note
 705:FreeRTOS/Source/tasks.c **** 					this task had a statically allocated stack in case it is
 706:FreeRTOS/Source/tasks.c **** 					later deleted.  The TCB was allocated dynamically. */
 707:FreeRTOS/Source/tasks.c **** 					pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_ONLY;
 708:FreeRTOS/Source/tasks.c **** 				}
 709:FreeRTOS/Source/tasks.c **** 				#endif
 710:FreeRTOS/Source/tasks.c **** 
 711:FreeRTOS/Source/tasks.c **** 				prvInitialiseNewTask(	pxTaskDefinition->pvTaskCode,
 712:FreeRTOS/Source/tasks.c **** 										pxTaskDefinition->pcName,
 713:FreeRTOS/Source/tasks.c **** 										( uint32_t ) pxTaskDefinition->usStackDepth,
 714:FreeRTOS/Source/tasks.c **** 										pxTaskDefinition->pvParameters,
 715:FreeRTOS/Source/tasks.c **** 										pxTaskDefinition->uxPriority,
 716:FreeRTOS/Source/tasks.c **** 										pxCreatedTask, pxNewTCB,
 717:FreeRTOS/Source/tasks.c **** 										pxTaskDefinition->xRegions );
 718:FreeRTOS/Source/tasks.c **** 
 719:FreeRTOS/Source/tasks.c **** 				prvAddNewTaskToReadyList( pxNewTCB );
 720:FreeRTOS/Source/tasks.c **** 				xReturn = pdPASS;
 721:FreeRTOS/Source/tasks.c **** 			}
 722:FreeRTOS/Source/tasks.c **** 		}
 723:FreeRTOS/Source/tasks.c **** 
 724:FreeRTOS/Source/tasks.c **** 		return xReturn;
 725:FreeRTOS/Source/tasks.c **** 	}
 726:FreeRTOS/Source/tasks.c **** 
 727:FreeRTOS/Source/tasks.c **** #endif /* portUSING_MPU_WRAPPERS */
 728:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 729:FreeRTOS/Source/tasks.c **** 
 730:FreeRTOS/Source/tasks.c **** #if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
 731:FreeRTOS/Source/tasks.c **** 
 732:FreeRTOS/Source/tasks.c **** 	BaseType_t xTaskCreate(	TaskFunction_t pxTaskCode,
 733:FreeRTOS/Source/tasks.c **** 							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and 
 734:FreeRTOS/Source/tasks.c **** 							const configSTACK_DEPTH_TYPE usStackDepth,
 735:FreeRTOS/Source/tasks.c **** 							void * const pvParameters,
 736:FreeRTOS/Source/tasks.c **** 							UBaseType_t uxPriority,
 737:FreeRTOS/Source/tasks.c **** 							TaskHandle_t * const pxCreatedTask )
 738:FreeRTOS/Source/tasks.c **** 	{
 739:FreeRTOS/Source/tasks.c **** 	TCB_t *pxNewTCB;
 740:FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn;
 741:FreeRTOS/Source/tasks.c **** 
 742:FreeRTOS/Source/tasks.c **** 		/* If the stack grows down then allocate the stack then the TCB so the stack
 743:FreeRTOS/Source/tasks.c **** 		does not grow into the TCB.  Likewise if the stack grows up then allocate
 744:FreeRTOS/Source/tasks.c **** 		the TCB then the stack. */
 745:FreeRTOS/Source/tasks.c **** 		#if( portSTACK_GROWTH > 0 )
 746:FreeRTOS/Source/tasks.c **** 		{
 747:FreeRTOS/Source/tasks.c **** 			/* Allocate space for the TCB.  Where the memory comes from depends on
 748:FreeRTOS/Source/tasks.c **** 			the implementation of the port malloc function and whether or not static
 749:FreeRTOS/Source/tasks.c **** 			allocation is being used. */
 750:FreeRTOS/Source/tasks.c **** 			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
 751:FreeRTOS/Source/tasks.c **** 
 752:FreeRTOS/Source/tasks.c **** 			if( pxNewTCB != NULL )
 753:FreeRTOS/Source/tasks.c **** 			{
 754:FreeRTOS/Source/tasks.c **** 				/* Allocate space for the stack used by the task being created.
 755:FreeRTOS/Source/tasks.c **** 				The base of the stack memory stored in the TCB so the task can
 756:FreeRTOS/Source/tasks.c **** 				be deleted later if required. */
 757:FreeRTOS/Source/tasks.c **** 				pxNewTCB->pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( Sta
 758:FreeRTOS/Source/tasks.c **** 
 759:FreeRTOS/Source/tasks.c **** 				if( pxNewTCB->pxStack == NULL )
 760:FreeRTOS/Source/tasks.c **** 				{
 761:FreeRTOS/Source/tasks.c **** 					/* Could not allocate the stack.  Delete the allocated TCB. */
 762:FreeRTOS/Source/tasks.c **** 					vPortFree( pxNewTCB );
 763:FreeRTOS/Source/tasks.c **** 					pxNewTCB = NULL;
 764:FreeRTOS/Source/tasks.c **** 				}
 765:FreeRTOS/Source/tasks.c **** 			}
 766:FreeRTOS/Source/tasks.c **** 		}
 767:FreeRTOS/Source/tasks.c **** 		#else /* portSTACK_GROWTH */
 768:FreeRTOS/Source/tasks.c **** 		{
 769:FreeRTOS/Source/tasks.c **** 		StackType_t *pxStack;
 770:FreeRTOS/Source/tasks.c **** 
 771:FreeRTOS/Source/tasks.c **** 			/* Allocate space for the stack used by the task being created. */
 772:FreeRTOS/Source/tasks.c **** 			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) 
 773:FreeRTOS/Source/tasks.c **** 
 774:FreeRTOS/Source/tasks.c **** 			if( pxStack != NULL )
 775:FreeRTOS/Source/tasks.c **** 			{
 776:FreeRTOS/Source/tasks.c **** 				/* Allocate space for the TCB. */
 777:FreeRTOS/Source/tasks.c **** 				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the cas
 778:FreeRTOS/Source/tasks.c **** 
 779:FreeRTOS/Source/tasks.c **** 				if( pxNewTCB != NULL )
 780:FreeRTOS/Source/tasks.c **** 				{
 781:FreeRTOS/Source/tasks.c **** 					/* Store the stack location in the TCB. */
 782:FreeRTOS/Source/tasks.c **** 					pxNewTCB->pxStack = pxStack;
 783:FreeRTOS/Source/tasks.c **** 				}
 784:FreeRTOS/Source/tasks.c **** 				else
 785:FreeRTOS/Source/tasks.c **** 				{
 786:FreeRTOS/Source/tasks.c **** 					/* The stack cannot be used as the TCB was not created.  Free
 787:FreeRTOS/Source/tasks.c **** 					it again. */
 788:FreeRTOS/Source/tasks.c **** 					vPortFree( pxStack );
 789:FreeRTOS/Source/tasks.c **** 				}
 790:FreeRTOS/Source/tasks.c **** 			}
 791:FreeRTOS/Source/tasks.c **** 			else
 792:FreeRTOS/Source/tasks.c **** 			{
 793:FreeRTOS/Source/tasks.c **** 				pxNewTCB = NULL;
 794:FreeRTOS/Source/tasks.c **** 			}
 795:FreeRTOS/Source/tasks.c **** 		}
 796:FreeRTOS/Source/tasks.c **** 		#endif /* portSTACK_GROWTH */
 797:FreeRTOS/Source/tasks.c **** 
 798:FreeRTOS/Source/tasks.c **** 		if( pxNewTCB != NULL )
 799:FreeRTOS/Source/tasks.c **** 		{
 800:FreeRTOS/Source/tasks.c **** 			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 Macro has been consolidated f
 801:FreeRTOS/Source/tasks.c **** 			{
 802:FreeRTOS/Source/tasks.c **** 				/* Tasks can be created statically or dynamically, so note this
 803:FreeRTOS/Source/tasks.c **** 				task was created dynamically in case it is later deleted. */
 804:FreeRTOS/Source/tasks.c **** 				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
 805:FreeRTOS/Source/tasks.c **** 			}
 806:FreeRTOS/Source/tasks.c **** 			#endif /* configSUPPORT_STATIC_ALLOCATION */
 807:FreeRTOS/Source/tasks.c **** 
 808:FreeRTOS/Source/tasks.c **** 			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, p
 809:FreeRTOS/Source/tasks.c **** 			prvAddNewTaskToReadyList( pxNewTCB );
 810:FreeRTOS/Source/tasks.c **** 			xReturn = pdPASS;
 811:FreeRTOS/Source/tasks.c **** 		}
 812:FreeRTOS/Source/tasks.c **** 		else
 813:FreeRTOS/Source/tasks.c **** 		{
 814:FreeRTOS/Source/tasks.c **** 			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 815:FreeRTOS/Source/tasks.c **** 		}
 816:FreeRTOS/Source/tasks.c **** 
 817:FreeRTOS/Source/tasks.c **** 		return xReturn;
 818:FreeRTOS/Source/tasks.c **** 	}
 819:FreeRTOS/Source/tasks.c **** 
 820:FreeRTOS/Source/tasks.c **** #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
 821:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 822:FreeRTOS/Source/tasks.c **** 
 823:FreeRTOS/Source/tasks.c **** static void prvInitialiseNewTask( 	TaskFunction_t pxTaskCode,
 824:FreeRTOS/Source/tasks.c **** 									const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings an
 825:FreeRTOS/Source/tasks.c **** 									const uint32_t ulStackDepth,
 826:FreeRTOS/Source/tasks.c **** 									void * const pvParameters,
 827:FreeRTOS/Source/tasks.c **** 									UBaseType_t uxPriority,
 828:FreeRTOS/Source/tasks.c **** 									TaskHandle_t * const pxCreatedTask,
 829:FreeRTOS/Source/tasks.c **** 									TCB_t *pxNewTCB,
 830:FreeRTOS/Source/tasks.c **** 									const MemoryRegion_t * const xRegions )
 831:FreeRTOS/Source/tasks.c **** {
 832:FreeRTOS/Source/tasks.c **** StackType_t *pxTopOfStack;
 833:FreeRTOS/Source/tasks.c **** UBaseType_t x;
 834:FreeRTOS/Source/tasks.c **** 
 835:FreeRTOS/Source/tasks.c **** 	#if( portUSING_MPU_WRAPPERS == 1 )
 836:FreeRTOS/Source/tasks.c **** 		/* Should the task be created in privileged mode? */
 837:FreeRTOS/Source/tasks.c **** 		BaseType_t xRunPrivileged;
 838:FreeRTOS/Source/tasks.c **** 		if( ( uxPriority & portPRIVILEGE_BIT ) != 0U )
 839:FreeRTOS/Source/tasks.c **** 		{
 840:FreeRTOS/Source/tasks.c **** 			xRunPrivileged = pdTRUE;
 841:FreeRTOS/Source/tasks.c **** 		}
 842:FreeRTOS/Source/tasks.c **** 		else
 843:FreeRTOS/Source/tasks.c **** 		{
 844:FreeRTOS/Source/tasks.c **** 			xRunPrivileged = pdFALSE;
 845:FreeRTOS/Source/tasks.c **** 		}
 846:FreeRTOS/Source/tasks.c **** 		uxPriority &= ~portPRIVILEGE_BIT;
 847:FreeRTOS/Source/tasks.c **** 	#endif /* portUSING_MPU_WRAPPERS == 1 */
 848:FreeRTOS/Source/tasks.c **** 
 849:FreeRTOS/Source/tasks.c **** 	/* Avoid dependency on memset() if it is not required. */
 850:FreeRTOS/Source/tasks.c **** 	#if( tskSET_NEW_STACKS_TO_KNOWN_VALUE == 1 )
 851:FreeRTOS/Source/tasks.c **** 	{
 852:FreeRTOS/Source/tasks.c **** 		/* Fill the stack with a known value to assist debugging. */
 853:FreeRTOS/Source/tasks.c **** 		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof(
 854:FreeRTOS/Source/tasks.c **** 	}
 855:FreeRTOS/Source/tasks.c **** 	#endif /* tskSET_NEW_STACKS_TO_KNOWN_VALUE */
 856:FreeRTOS/Source/tasks.c **** 
 857:FreeRTOS/Source/tasks.c **** 	/* Calculate the top of stack address.  This depends on whether the stack
 858:FreeRTOS/Source/tasks.c **** 	grows from high memory to low (as per the 80x86) or vice versa.
 859:FreeRTOS/Source/tasks.c **** 	portSTACK_GROWTH is used to make the result positive or negative as required
 860:FreeRTOS/Source/tasks.c **** 	by the port. */
 861:FreeRTOS/Source/tasks.c **** 	#if( portSTACK_GROWTH < 0 )
 862:FreeRTOS/Source/tasks.c **** 	{
 863:FreeRTOS/Source/tasks.c **** 		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
 864:FreeRTOS/Source/tasks.c **** 		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTE
 865:FreeRTOS/Source/tasks.c **** 
 866:FreeRTOS/Source/tasks.c **** 		/* Check the alignment of the calculated top of stack is correct. */
 867:FreeRTOS/Source/tasks.c **** 		configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALI
 868:FreeRTOS/Source/tasks.c **** 
 869:FreeRTOS/Source/tasks.c **** 		#if( configRECORD_STACK_HIGH_ADDRESS == 1 )
 870:FreeRTOS/Source/tasks.c **** 		{
 871:FreeRTOS/Source/tasks.c **** 			/* Also record the stack's high address, which may assist
 872:FreeRTOS/Source/tasks.c **** 			debugging. */
 873:FreeRTOS/Source/tasks.c **** 			pxNewTCB->pxEndOfStack = pxTopOfStack;
 874:FreeRTOS/Source/tasks.c **** 		}
 875:FreeRTOS/Source/tasks.c **** 		#endif /* configRECORD_STACK_HIGH_ADDRESS */
 876:FreeRTOS/Source/tasks.c **** 	}
 877:FreeRTOS/Source/tasks.c **** 	#else /* portSTACK_GROWTH */
 878:FreeRTOS/Source/tasks.c **** 	{
 879:FreeRTOS/Source/tasks.c **** 		pxTopOfStack = pxNewTCB->pxStack;
 880:FreeRTOS/Source/tasks.c **** 
 881:FreeRTOS/Source/tasks.c **** 		/* Check the alignment of the stack buffer is correct. */
 882:FreeRTOS/Source/tasks.c **** 		configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxNewTCB->pxStack & ( portPOINTER_SIZE_TYPE ) portBYT
 883:FreeRTOS/Source/tasks.c **** 
 884:FreeRTOS/Source/tasks.c **** 		/* The other extreme of the stack space is required if stack checking is
 885:FreeRTOS/Source/tasks.c **** 		performed. */
 886:FreeRTOS/Source/tasks.c **** 		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
 887:FreeRTOS/Source/tasks.c **** 	}
 888:FreeRTOS/Source/tasks.c **** 	#endif /* portSTACK_GROWTH */
 889:FreeRTOS/Source/tasks.c **** 
 890:FreeRTOS/Source/tasks.c **** 	/* Store the task name in the TCB. */
 891:FreeRTOS/Source/tasks.c **** 	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 892:FreeRTOS/Source/tasks.c **** 	{
 893:FreeRTOS/Source/tasks.c **** 		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 894:FreeRTOS/Source/tasks.c **** 
 895:FreeRTOS/Source/tasks.c **** 		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
 896:FreeRTOS/Source/tasks.c **** 		configMAX_TASK_NAME_LEN characters just in case the memory after the
 897:FreeRTOS/Source/tasks.c **** 		string is not accessible (extremely unlikely). */
 898:FreeRTOS/Source/tasks.c **** 		if( pcName[ x ] == 0x00 )
 899:FreeRTOS/Source/tasks.c **** 		{
 900:FreeRTOS/Source/tasks.c **** 			break;
 901:FreeRTOS/Source/tasks.c **** 		}
 902:FreeRTOS/Source/tasks.c **** 		else
 903:FreeRTOS/Source/tasks.c **** 		{
 904:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
 905:FreeRTOS/Source/tasks.c **** 		}
 906:FreeRTOS/Source/tasks.c **** 	}
 907:FreeRTOS/Source/tasks.c **** 
 908:FreeRTOS/Source/tasks.c **** 	/* Ensure the name string is terminated in the case that the string length
 909:FreeRTOS/Source/tasks.c **** 	was greater or equal to configMAX_TASK_NAME_LEN. */
 910:FreeRTOS/Source/tasks.c **** 	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 911:FreeRTOS/Source/tasks.c **** 
 912:FreeRTOS/Source/tasks.c **** 	/* This is used as an array index so must ensure it's not too large.  First
 913:FreeRTOS/Source/tasks.c **** 	remove the privilege bit if one is present. */
 914:FreeRTOS/Source/tasks.c **** 	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
 915:FreeRTOS/Source/tasks.c **** 	{
 916:FreeRTOS/Source/tasks.c **** 		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
 917:FreeRTOS/Source/tasks.c **** 	}
 918:FreeRTOS/Source/tasks.c **** 	else
 919:FreeRTOS/Source/tasks.c **** 	{
 920:FreeRTOS/Source/tasks.c **** 		mtCOVERAGE_TEST_MARKER();
 921:FreeRTOS/Source/tasks.c **** 	}
 922:FreeRTOS/Source/tasks.c **** 
 923:FreeRTOS/Source/tasks.c **** 	pxNewTCB->uxPriority = uxPriority;
 924:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
 925:FreeRTOS/Source/tasks.c **** 	{
 926:FreeRTOS/Source/tasks.c **** 		pxNewTCB->uxBasePriority = uxPriority;
 927:FreeRTOS/Source/tasks.c **** 		pxNewTCB->uxMutexesHeld = 0;
 928:FreeRTOS/Source/tasks.c **** 	}
 929:FreeRTOS/Source/tasks.c **** 	#endif /* configUSE_MUTEXES */
 930:FreeRTOS/Source/tasks.c **** 
 931:FreeRTOS/Source/tasks.c **** 	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 932:FreeRTOS/Source/tasks.c **** 	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 933:FreeRTOS/Source/tasks.c **** 
 934:FreeRTOS/Source/tasks.c **** 	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
 935:FreeRTOS/Source/tasks.c **** 	back to	the containing TCB from a generic item in a list. */
 936:FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
 937:FreeRTOS/Source/tasks.c **** 
 938:FreeRTOS/Source/tasks.c **** 	/* Event lists are always in priority order. */
 939:FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( Ti
 940:FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 941:FreeRTOS/Source/tasks.c **** 
 942:FreeRTOS/Source/tasks.c **** 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
 943:FreeRTOS/Source/tasks.c **** 	{
 944:FreeRTOS/Source/tasks.c **** 		pxNewTCB->uxCriticalNesting = ( UBaseType_t ) 0U;
 945:FreeRTOS/Source/tasks.c **** 	}
 946:FreeRTOS/Source/tasks.c **** 	#endif /* portCRITICAL_NESTING_IN_TCB */
 947:FreeRTOS/Source/tasks.c **** 
 948:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
 949:FreeRTOS/Source/tasks.c **** 	{
 950:FreeRTOS/Source/tasks.c **** 		pxNewTCB->pxTaskTag = NULL;
 951:FreeRTOS/Source/tasks.c **** 	}
 952:FreeRTOS/Source/tasks.c **** 	#endif /* configUSE_APPLICATION_TASK_TAG */
 953:FreeRTOS/Source/tasks.c **** 
 954:FreeRTOS/Source/tasks.c **** 	#if ( configGENERATE_RUN_TIME_STATS == 1 )
 955:FreeRTOS/Source/tasks.c **** 	{
 956:FreeRTOS/Source/tasks.c **** 		pxNewTCB->ulRunTimeCounter = 0UL;
 957:FreeRTOS/Source/tasks.c **** 	}
 958:FreeRTOS/Source/tasks.c **** 	#endif /* configGENERATE_RUN_TIME_STATS */
 959:FreeRTOS/Source/tasks.c **** 
 960:FreeRTOS/Source/tasks.c **** 	#if ( portUSING_MPU_WRAPPERS == 1 )
 961:FreeRTOS/Source/tasks.c **** 	{
 962:FreeRTOS/Source/tasks.c **** 		vPortStoreTaskMPUSettings( &( pxNewTCB->xMPUSettings ), xRegions, pxNewTCB->pxStack, ulStackDepth
 963:FreeRTOS/Source/tasks.c **** 	}
 964:FreeRTOS/Source/tasks.c **** 	#else
 965:FreeRTOS/Source/tasks.c **** 	{
 966:FreeRTOS/Source/tasks.c **** 		/* Avoid compiler warning about unreferenced parameter. */
 967:FreeRTOS/Source/tasks.c **** 		( void ) xRegions;
 968:FreeRTOS/Source/tasks.c **** 	}
 969:FreeRTOS/Source/tasks.c **** 	#endif
 970:FreeRTOS/Source/tasks.c **** 
 971:FreeRTOS/Source/tasks.c **** 	#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
 972:FreeRTOS/Source/tasks.c **** 	{
 973:FreeRTOS/Source/tasks.c **** 		for( x = 0; x < ( UBaseType_t ) configNUM_THREAD_LOCAL_STORAGE_POINTERS; x++ )
 974:FreeRTOS/Source/tasks.c **** 		{
 975:FreeRTOS/Source/tasks.c **** 			pxNewTCB->pvThreadLocalStoragePointers[ x ] = NULL;
 976:FreeRTOS/Source/tasks.c **** 		}
 977:FreeRTOS/Source/tasks.c **** 	}
 978:FreeRTOS/Source/tasks.c **** 	#endif
 979:FreeRTOS/Source/tasks.c **** 
 980:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
 981:FreeRTOS/Source/tasks.c **** 	{
 982:FreeRTOS/Source/tasks.c **** 		pxNewTCB->ulNotifiedValue = 0;
 983:FreeRTOS/Source/tasks.c **** 		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 984:FreeRTOS/Source/tasks.c **** 	}
 985:FreeRTOS/Source/tasks.c **** 	#endif
 986:FreeRTOS/Source/tasks.c **** 
 987:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_NEWLIB_REENTRANT == 1 )
 988:FreeRTOS/Source/tasks.c **** 	{
 989:FreeRTOS/Source/tasks.c **** 		/* Initialise this task's Newlib reent structure. */
 990:FreeRTOS/Source/tasks.c **** 		_REENT_INIT_PTR( ( &( pxNewTCB->xNewLib_reent ) ) );
 991:FreeRTOS/Source/tasks.c **** 	}
 992:FreeRTOS/Source/tasks.c **** 	#endif
 993:FreeRTOS/Source/tasks.c **** 
 994:FreeRTOS/Source/tasks.c **** 	#if( INCLUDE_xTaskAbortDelay == 1 )
 995:FreeRTOS/Source/tasks.c **** 	{
 996:FreeRTOS/Source/tasks.c **** 		pxNewTCB->ucDelayAborted = pdFALSE;
 997:FreeRTOS/Source/tasks.c **** 	}
 998:FreeRTOS/Source/tasks.c **** 	#endif
 999:FreeRTOS/Source/tasks.c **** 
1000:FreeRTOS/Source/tasks.c **** 	/* Initialize the TCB stack to look as if the task was already running,
1001:FreeRTOS/Source/tasks.c **** 	but had been interrupted by the scheduler.  The return address is set
1002:FreeRTOS/Source/tasks.c **** 	to the start of the task function. Once the stack has been initialised
1003:FreeRTOS/Source/tasks.c **** 	the top of stack variable is updated. */
1004:FreeRTOS/Source/tasks.c **** 	#if( portUSING_MPU_WRAPPERS == 1 )
1005:FreeRTOS/Source/tasks.c **** 	{
1006:FreeRTOS/Source/tasks.c **** 		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivi
1007:FreeRTOS/Source/tasks.c **** 	}
1008:FreeRTOS/Source/tasks.c **** 	#else /* portUSING_MPU_WRAPPERS */
1009:FreeRTOS/Source/tasks.c **** 	{
1010:FreeRTOS/Source/tasks.c **** 		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
1011:FreeRTOS/Source/tasks.c **** 	}
1012:FreeRTOS/Source/tasks.c **** 	#endif /* portUSING_MPU_WRAPPERS */
1013:FreeRTOS/Source/tasks.c **** 
1014:FreeRTOS/Source/tasks.c **** 	if( ( void * ) pxCreatedTask != NULL )
1015:FreeRTOS/Source/tasks.c **** 	{
1016:FreeRTOS/Source/tasks.c **** 		/* Pass the handle out in an anonymous way.  The handle can be used to
1017:FreeRTOS/Source/tasks.c **** 		change the created task's priority, delete the created task, etc.*/
1018:FreeRTOS/Source/tasks.c **** 		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
1019:FreeRTOS/Source/tasks.c **** 	}
1020:FreeRTOS/Source/tasks.c **** 	else
1021:FreeRTOS/Source/tasks.c **** 	{
1022:FreeRTOS/Source/tasks.c **** 		mtCOVERAGE_TEST_MARKER();
1023:FreeRTOS/Source/tasks.c **** 	}
1024:FreeRTOS/Source/tasks.c **** }
1025:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1026:FreeRTOS/Source/tasks.c **** 
1027:FreeRTOS/Source/tasks.c **** static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
1028:FreeRTOS/Source/tasks.c **** {
1029:FreeRTOS/Source/tasks.c **** 	/* Ensure interrupts don't access the task lists while the lists are being
1030:FreeRTOS/Source/tasks.c **** 	updated. */
1031:FreeRTOS/Source/tasks.c **** 	taskENTER_CRITICAL();
1032:FreeRTOS/Source/tasks.c **** 	{
1033:FreeRTOS/Source/tasks.c **** 		uxCurrentNumberOfTasks++;
1034:FreeRTOS/Source/tasks.c **** 		if( pxCurrentTCB == NULL )
1035:FreeRTOS/Source/tasks.c **** 		{
1036:FreeRTOS/Source/tasks.c **** 			/* There are no other tasks, or all the other tasks are in
1037:FreeRTOS/Source/tasks.c **** 			the suspended state - make this the current task. */
1038:FreeRTOS/Source/tasks.c **** 			pxCurrentTCB = pxNewTCB;
1039:FreeRTOS/Source/tasks.c **** 
1040:FreeRTOS/Source/tasks.c **** 			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
1041:FreeRTOS/Source/tasks.c **** 			{
1042:FreeRTOS/Source/tasks.c **** 				/* This is the first task to be created so do the preliminary
1043:FreeRTOS/Source/tasks.c **** 				initialisation required.  We will not recover if this call
1044:FreeRTOS/Source/tasks.c **** 				fails, but we will report the failure. */
1045:FreeRTOS/Source/tasks.c **** 				prvInitialiseTaskLists();
1046:FreeRTOS/Source/tasks.c **** 			}
1047:FreeRTOS/Source/tasks.c **** 			else
1048:FreeRTOS/Source/tasks.c **** 			{
1049:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1050:FreeRTOS/Source/tasks.c **** 			}
1051:FreeRTOS/Source/tasks.c **** 		}
1052:FreeRTOS/Source/tasks.c **** 		else
1053:FreeRTOS/Source/tasks.c **** 		{
1054:FreeRTOS/Source/tasks.c **** 			/* If the scheduler is not already running, make this task the
1055:FreeRTOS/Source/tasks.c **** 			current task if it is the highest priority task to be created
1056:FreeRTOS/Source/tasks.c **** 			so far. */
1057:FreeRTOS/Source/tasks.c **** 			if( xSchedulerRunning == pdFALSE )
1058:FreeRTOS/Source/tasks.c **** 			{
1059:FreeRTOS/Source/tasks.c **** 				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
1060:FreeRTOS/Source/tasks.c **** 				{
1061:FreeRTOS/Source/tasks.c **** 					pxCurrentTCB = pxNewTCB;
1062:FreeRTOS/Source/tasks.c **** 				}
1063:FreeRTOS/Source/tasks.c **** 				else
1064:FreeRTOS/Source/tasks.c **** 				{
1065:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1066:FreeRTOS/Source/tasks.c **** 				}
1067:FreeRTOS/Source/tasks.c **** 			}
1068:FreeRTOS/Source/tasks.c **** 			else
1069:FreeRTOS/Source/tasks.c **** 			{
1070:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1071:FreeRTOS/Source/tasks.c **** 			}
1072:FreeRTOS/Source/tasks.c **** 		}
1073:FreeRTOS/Source/tasks.c **** 
1074:FreeRTOS/Source/tasks.c **** 		uxTaskNumber++;
1075:FreeRTOS/Source/tasks.c **** 
1076:FreeRTOS/Source/tasks.c **** 		#if ( configUSE_TRACE_FACILITY == 1 )
1077:FreeRTOS/Source/tasks.c **** 		{
1078:FreeRTOS/Source/tasks.c **** 			/* Add a counter into the TCB for tracing only. */
1079:FreeRTOS/Source/tasks.c **** 			pxNewTCB->uxTCBNumber = uxTaskNumber;
1080:FreeRTOS/Source/tasks.c **** 		}
1081:FreeRTOS/Source/tasks.c **** 		#endif /* configUSE_TRACE_FACILITY */
1082:FreeRTOS/Source/tasks.c **** 		traceTASK_CREATE( pxNewTCB );
1083:FreeRTOS/Source/tasks.c **** 
1084:FreeRTOS/Source/tasks.c **** 		prvAddTaskToReadyList( pxNewTCB );
1085:FreeRTOS/Source/tasks.c **** 
1086:FreeRTOS/Source/tasks.c **** 		portSETUP_TCB( pxNewTCB );
1087:FreeRTOS/Source/tasks.c **** 	}
1088:FreeRTOS/Source/tasks.c **** 	taskEXIT_CRITICAL();
1089:FreeRTOS/Source/tasks.c **** 
1090:FreeRTOS/Source/tasks.c **** 	if( xSchedulerRunning != pdFALSE )
1091:FreeRTOS/Source/tasks.c **** 	{
1092:FreeRTOS/Source/tasks.c **** 		/* If the created task is of a higher priority than the current task
1093:FreeRTOS/Source/tasks.c **** 		then it should run now. */
1094:FreeRTOS/Source/tasks.c **** 		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
1095:FreeRTOS/Source/tasks.c **** 		{
1096:FreeRTOS/Source/tasks.c **** 			taskYIELD_IF_USING_PREEMPTION();
1097:FreeRTOS/Source/tasks.c **** 		}
1098:FreeRTOS/Source/tasks.c **** 		else
1099:FreeRTOS/Source/tasks.c **** 		{
1100:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1101:FreeRTOS/Source/tasks.c **** 		}
1102:FreeRTOS/Source/tasks.c **** 	}
1103:FreeRTOS/Source/tasks.c **** 	else
1104:FreeRTOS/Source/tasks.c **** 	{
1105:FreeRTOS/Source/tasks.c **** 		mtCOVERAGE_TEST_MARKER();
1106:FreeRTOS/Source/tasks.c **** 	}
1107:FreeRTOS/Source/tasks.c **** }
1108:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1109:FreeRTOS/Source/tasks.c **** 
1110:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
1111:FreeRTOS/Source/tasks.c **** 
1112:FreeRTOS/Source/tasks.c **** 	void vTaskDelete( TaskHandle_t xTaskToDelete )
1113:FreeRTOS/Source/tasks.c **** 	{
1114:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
1115:FreeRTOS/Source/tasks.c **** 
1116:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
1117:FreeRTOS/Source/tasks.c **** 		{
1118:FreeRTOS/Source/tasks.c **** 			/* If null is passed in here then it is the calling task that is
1119:FreeRTOS/Source/tasks.c **** 			being deleted. */
1120:FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
1121:FreeRTOS/Source/tasks.c **** 
1122:FreeRTOS/Source/tasks.c **** 			/* Remove task from the ready list. */
1123:FreeRTOS/Source/tasks.c **** 			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
1124:FreeRTOS/Source/tasks.c **** 			{
1125:FreeRTOS/Source/tasks.c **** 				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
1126:FreeRTOS/Source/tasks.c **** 			}
1127:FreeRTOS/Source/tasks.c **** 			else
1128:FreeRTOS/Source/tasks.c **** 			{
1129:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1130:FreeRTOS/Source/tasks.c **** 			}
1131:FreeRTOS/Source/tasks.c **** 
1132:FreeRTOS/Source/tasks.c **** 			/* Is the task waiting on an event also? */
1133:FreeRTOS/Source/tasks.c **** 			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
1134:FreeRTOS/Source/tasks.c **** 			{
1135:FreeRTOS/Source/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
1136:FreeRTOS/Source/tasks.c **** 			}
1137:FreeRTOS/Source/tasks.c **** 			else
1138:FreeRTOS/Source/tasks.c **** 			{
1139:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1140:FreeRTOS/Source/tasks.c **** 			}
1141:FreeRTOS/Source/tasks.c **** 
1142:FreeRTOS/Source/tasks.c **** 			/* Increment the uxTaskNumber also so kernel aware debuggers can
1143:FreeRTOS/Source/tasks.c **** 			detect that the task lists need re-generating.  This is done before
1144:FreeRTOS/Source/tasks.c **** 			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
1145:FreeRTOS/Source/tasks.c **** 			not return. */
1146:FreeRTOS/Source/tasks.c **** 			uxTaskNumber++;
1147:FreeRTOS/Source/tasks.c **** 
1148:FreeRTOS/Source/tasks.c **** 			if( pxTCB == pxCurrentTCB )
1149:FreeRTOS/Source/tasks.c **** 			{
1150:FreeRTOS/Source/tasks.c **** 				/* A task is deleting itself.  This cannot complete within the
1151:FreeRTOS/Source/tasks.c **** 				task itself, as a context switch to another task is required.
1152:FreeRTOS/Source/tasks.c **** 				Place the task in the termination list.  The idle task will
1153:FreeRTOS/Source/tasks.c **** 				check the termination list and free up any memory allocated by
1154:FreeRTOS/Source/tasks.c **** 				the scheduler for the TCB and stack of the deleted task. */
1155:FreeRTOS/Source/tasks.c **** 				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
1156:FreeRTOS/Source/tasks.c **** 
1157:FreeRTOS/Source/tasks.c **** 				/* Increment the ucTasksDeleted variable so the idle task knows
1158:FreeRTOS/Source/tasks.c **** 				there is a task that has been deleted and that it should therefore
1159:FreeRTOS/Source/tasks.c **** 				check the xTasksWaitingTermination list. */
1160:FreeRTOS/Source/tasks.c **** 				++uxDeletedTasksWaitingCleanUp;
1161:FreeRTOS/Source/tasks.c **** 
1162:FreeRTOS/Source/tasks.c **** 				/* The pre-delete hook is primarily for the Windows simulator,
1163:FreeRTOS/Source/tasks.c **** 				in which Windows specific clean up operations are performed,
1164:FreeRTOS/Source/tasks.c **** 				after which it is not possible to yield away from this task -
1165:FreeRTOS/Source/tasks.c **** 				hence xYieldPending is used to latch that a context switch is
1166:FreeRTOS/Source/tasks.c **** 				required. */
1167:FreeRTOS/Source/tasks.c **** 				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
1168:FreeRTOS/Source/tasks.c **** 			}
1169:FreeRTOS/Source/tasks.c **** 			else
1170:FreeRTOS/Source/tasks.c **** 			{
1171:FreeRTOS/Source/tasks.c **** 				--uxCurrentNumberOfTasks;
1172:FreeRTOS/Source/tasks.c **** 				prvDeleteTCB( pxTCB );
1173:FreeRTOS/Source/tasks.c **** 
1174:FreeRTOS/Source/tasks.c **** 				/* Reset the next expected unblock time in case it referred to
1175:FreeRTOS/Source/tasks.c **** 				the task that has just been deleted. */
1176:FreeRTOS/Source/tasks.c **** 				prvResetNextTaskUnblockTime();
1177:FreeRTOS/Source/tasks.c **** 			}
1178:FreeRTOS/Source/tasks.c **** 
1179:FreeRTOS/Source/tasks.c **** 			traceTASK_DELETE( pxTCB );
1180:FreeRTOS/Source/tasks.c **** 		}
1181:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
1182:FreeRTOS/Source/tasks.c **** 
1183:FreeRTOS/Source/tasks.c **** 		/* Force a reschedule if it is the currently running task that has just
1184:FreeRTOS/Source/tasks.c **** 		been deleted. */
1185:FreeRTOS/Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
1186:FreeRTOS/Source/tasks.c **** 		{
1187:FreeRTOS/Source/tasks.c **** 			if( pxTCB == pxCurrentTCB )
1188:FreeRTOS/Source/tasks.c **** 			{
1189:FreeRTOS/Source/tasks.c **** 				configASSERT( uxSchedulerSuspended == 0 );
1190:FreeRTOS/Source/tasks.c **** 				portYIELD_WITHIN_API();
1191:FreeRTOS/Source/tasks.c **** 			}
1192:FreeRTOS/Source/tasks.c **** 			else
1193:FreeRTOS/Source/tasks.c **** 			{
1194:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1195:FreeRTOS/Source/tasks.c **** 			}
1196:FreeRTOS/Source/tasks.c **** 		}
1197:FreeRTOS/Source/tasks.c **** 	}
1198:FreeRTOS/Source/tasks.c **** 
1199:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskDelete */
1200:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1201:FreeRTOS/Source/tasks.c **** 
1202:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelayUntil == 1 )
1203:FreeRTOS/Source/tasks.c **** 
1204:FreeRTOS/Source/tasks.c **** 	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
1205:FreeRTOS/Source/tasks.c **** 	{
1206:FreeRTOS/Source/tasks.c **** 	TickType_t xTimeToWake;
1207:FreeRTOS/Source/tasks.c **** 	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
1208:FreeRTOS/Source/tasks.c **** 
1209:FreeRTOS/Source/tasks.c **** 		configASSERT( pxPreviousWakeTime );
1210:FreeRTOS/Source/tasks.c **** 		configASSERT( ( xTimeIncrement > 0U ) );
1211:FreeRTOS/Source/tasks.c **** 		configASSERT( uxSchedulerSuspended == 0 );
1212:FreeRTOS/Source/tasks.c **** 
1213:FreeRTOS/Source/tasks.c **** 		vTaskSuspendAll();
1214:FreeRTOS/Source/tasks.c **** 		{
1215:FreeRTOS/Source/tasks.c **** 			/* Minor optimisation.  The tick count cannot change in this
1216:FreeRTOS/Source/tasks.c **** 			block. */
1217:FreeRTOS/Source/tasks.c **** 			const TickType_t xConstTickCount = xTickCount;
1218:FreeRTOS/Source/tasks.c **** 
1219:FreeRTOS/Source/tasks.c **** 			/* Generate the tick time at which the task wants to wake. */
1220:FreeRTOS/Source/tasks.c **** 			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
1221:FreeRTOS/Source/tasks.c **** 
1222:FreeRTOS/Source/tasks.c **** 			if( xConstTickCount < *pxPreviousWakeTime )
1223:FreeRTOS/Source/tasks.c **** 			{
1224:FreeRTOS/Source/tasks.c **** 				/* The tick count has overflowed since this function was
1225:FreeRTOS/Source/tasks.c **** 				lasted called.  In this case the only time we should ever
1226:FreeRTOS/Source/tasks.c **** 				actually delay is if the wake time has also	overflowed,
1227:FreeRTOS/Source/tasks.c **** 				and the wake time is greater than the tick time.  When this
1228:FreeRTOS/Source/tasks.c **** 				is the case it is as if neither time had overflowed. */
1229:FreeRTOS/Source/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
1230:FreeRTOS/Source/tasks.c **** 				{
1231:FreeRTOS/Source/tasks.c **** 					xShouldDelay = pdTRUE;
1232:FreeRTOS/Source/tasks.c **** 				}
1233:FreeRTOS/Source/tasks.c **** 				else
1234:FreeRTOS/Source/tasks.c **** 				{
1235:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1236:FreeRTOS/Source/tasks.c **** 				}
1237:FreeRTOS/Source/tasks.c **** 			}
1238:FreeRTOS/Source/tasks.c **** 			else
1239:FreeRTOS/Source/tasks.c **** 			{
1240:FreeRTOS/Source/tasks.c **** 				/* The tick time has not overflowed.  In this case we will
1241:FreeRTOS/Source/tasks.c **** 				delay if either the wake time has overflowed, and/or the
1242:FreeRTOS/Source/tasks.c **** 				tick time is less than the wake time. */
1243:FreeRTOS/Source/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
1244:FreeRTOS/Source/tasks.c **** 				{
1245:FreeRTOS/Source/tasks.c **** 					xShouldDelay = pdTRUE;
1246:FreeRTOS/Source/tasks.c **** 				}
1247:FreeRTOS/Source/tasks.c **** 				else
1248:FreeRTOS/Source/tasks.c **** 				{
1249:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1250:FreeRTOS/Source/tasks.c **** 				}
1251:FreeRTOS/Source/tasks.c **** 			}
1252:FreeRTOS/Source/tasks.c **** 
1253:FreeRTOS/Source/tasks.c **** 			/* Update the wake time ready for the next call. */
1254:FreeRTOS/Source/tasks.c **** 			*pxPreviousWakeTime = xTimeToWake;
1255:FreeRTOS/Source/tasks.c **** 
1256:FreeRTOS/Source/tasks.c **** 			if( xShouldDelay != pdFALSE )
1257:FreeRTOS/Source/tasks.c **** 			{
1258:FreeRTOS/Source/tasks.c **** 				traceTASK_DELAY_UNTIL( xTimeToWake );
1259:FreeRTOS/Source/tasks.c **** 
1260:FreeRTOS/Source/tasks.c **** 				/* prvAddCurrentTaskToDelayedList() needs the block time, not
1261:FreeRTOS/Source/tasks.c **** 				the time to wake, so subtract the current tick count. */
1262:FreeRTOS/Source/tasks.c **** 				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
1263:FreeRTOS/Source/tasks.c **** 			}
1264:FreeRTOS/Source/tasks.c **** 			else
1265:FreeRTOS/Source/tasks.c **** 			{
1266:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1267:FreeRTOS/Source/tasks.c **** 			}
1268:FreeRTOS/Source/tasks.c **** 		}
1269:FreeRTOS/Source/tasks.c **** 		xAlreadyYielded = xTaskResumeAll();
1270:FreeRTOS/Source/tasks.c **** 
1271:FreeRTOS/Source/tasks.c **** 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
1272:FreeRTOS/Source/tasks.c **** 		have put ourselves to sleep. */
1273:FreeRTOS/Source/tasks.c **** 		if( xAlreadyYielded == pdFALSE )
1274:FreeRTOS/Source/tasks.c **** 		{
1275:FreeRTOS/Source/tasks.c **** 			portYIELD_WITHIN_API();
1276:FreeRTOS/Source/tasks.c **** 		}
1277:FreeRTOS/Source/tasks.c **** 		else
1278:FreeRTOS/Source/tasks.c **** 		{
1279:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1280:FreeRTOS/Source/tasks.c **** 		}
1281:FreeRTOS/Source/tasks.c **** 	}
1282:FreeRTOS/Source/tasks.c **** 
1283:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskDelayUntil */
1284:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1285:FreeRTOS/Source/tasks.c **** 
1286:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelay == 1 )
1287:FreeRTOS/Source/tasks.c **** 
1288:FreeRTOS/Source/tasks.c **** 	void vTaskDelay( const TickType_t xTicksToDelay )
1289:FreeRTOS/Source/tasks.c **** 	{
1290:FreeRTOS/Source/tasks.c **** 	BaseType_t xAlreadyYielded = pdFALSE;
1291:FreeRTOS/Source/tasks.c **** 
1292:FreeRTOS/Source/tasks.c **** 		/* A delay time of zero just forces a reschedule. */
1293:FreeRTOS/Source/tasks.c **** 		if( xTicksToDelay > ( TickType_t ) 0U )
1294:FreeRTOS/Source/tasks.c **** 		{
1295:FreeRTOS/Source/tasks.c **** 			configASSERT( uxSchedulerSuspended == 0 );
1296:FreeRTOS/Source/tasks.c **** 			vTaskSuspendAll();
1297:FreeRTOS/Source/tasks.c **** 			{
1298:FreeRTOS/Source/tasks.c **** 				traceTASK_DELAY();
1299:FreeRTOS/Source/tasks.c **** 
1300:FreeRTOS/Source/tasks.c **** 				/* A task that is removed from the event list while the
1301:FreeRTOS/Source/tasks.c **** 				scheduler is suspended will not get placed in the ready
1302:FreeRTOS/Source/tasks.c **** 				list or removed from the blocked list until the scheduler
1303:FreeRTOS/Source/tasks.c **** 				is resumed.
1304:FreeRTOS/Source/tasks.c **** 
1305:FreeRTOS/Source/tasks.c **** 				This task cannot be in an event list as it is the currently
1306:FreeRTOS/Source/tasks.c **** 				executing task. */
1307:FreeRTOS/Source/tasks.c **** 				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
1308:FreeRTOS/Source/tasks.c **** 			}
1309:FreeRTOS/Source/tasks.c **** 			xAlreadyYielded = xTaskResumeAll();
1310:FreeRTOS/Source/tasks.c **** 		}
1311:FreeRTOS/Source/tasks.c **** 		else
1312:FreeRTOS/Source/tasks.c **** 		{
1313:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1314:FreeRTOS/Source/tasks.c **** 		}
1315:FreeRTOS/Source/tasks.c **** 
1316:FreeRTOS/Source/tasks.c **** 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
1317:FreeRTOS/Source/tasks.c **** 		have put ourselves to sleep. */
1318:FreeRTOS/Source/tasks.c **** 		if( xAlreadyYielded == pdFALSE )
1319:FreeRTOS/Source/tasks.c **** 		{
1320:FreeRTOS/Source/tasks.c **** 			portYIELD_WITHIN_API();
1321:FreeRTOS/Source/tasks.c **** 		}
1322:FreeRTOS/Source/tasks.c **** 		else
1323:FreeRTOS/Source/tasks.c **** 		{
1324:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1325:FreeRTOS/Source/tasks.c **** 		}
1326:FreeRTOS/Source/tasks.c **** 	}
1327:FreeRTOS/Source/tasks.c **** 
1328:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskDelay */
1329:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1330:FreeRTOS/Source/tasks.c **** 
1331:FreeRTOS/Source/tasks.c **** #if( ( INCLUDE_eTaskGetState == 1 ) || ( configUSE_TRACE_FACILITY == 1 ) )
1332:FreeRTOS/Source/tasks.c **** 
1333:FreeRTOS/Source/tasks.c **** 	eTaskState eTaskGetState( TaskHandle_t xTask )
1334:FreeRTOS/Source/tasks.c **** 	{
1335:FreeRTOS/Source/tasks.c **** 	eTaskState eReturn;
1336:FreeRTOS/Source/tasks.c **** 	List_t *pxStateList;
1337:FreeRTOS/Source/tasks.c **** 	const TCB_t * const pxTCB = ( TCB_t * ) xTask;
1338:FreeRTOS/Source/tasks.c **** 
1339:FreeRTOS/Source/tasks.c **** 		configASSERT( pxTCB );
1340:FreeRTOS/Source/tasks.c **** 
1341:FreeRTOS/Source/tasks.c **** 		if( pxTCB == pxCurrentTCB )
1342:FreeRTOS/Source/tasks.c **** 		{
1343:FreeRTOS/Source/tasks.c **** 			/* The task calling this function is querying its own state. */
1344:FreeRTOS/Source/tasks.c **** 			eReturn = eRunning;
1345:FreeRTOS/Source/tasks.c **** 		}
1346:FreeRTOS/Source/tasks.c **** 		else
1347:FreeRTOS/Source/tasks.c **** 		{
1348:FreeRTOS/Source/tasks.c **** 			taskENTER_CRITICAL();
1349:FreeRTOS/Source/tasks.c **** 			{
1350:FreeRTOS/Source/tasks.c **** 				pxStateList = ( List_t * ) listLIST_ITEM_CONTAINER( &( pxTCB->xStateListItem ) );
1351:FreeRTOS/Source/tasks.c **** 			}
1352:FreeRTOS/Source/tasks.c **** 			taskEXIT_CRITICAL();
1353:FreeRTOS/Source/tasks.c **** 
1354:FreeRTOS/Source/tasks.c **** 			if( ( pxStateList == pxDelayedTaskList ) || ( pxStateList == pxOverflowDelayedTaskList ) )
1355:FreeRTOS/Source/tasks.c **** 			{
1356:FreeRTOS/Source/tasks.c **** 				/* The task being queried is referenced from one of the Blocked
1357:FreeRTOS/Source/tasks.c **** 				lists. */
1358:FreeRTOS/Source/tasks.c **** 				eReturn = eBlocked;
1359:FreeRTOS/Source/tasks.c **** 			}
1360:FreeRTOS/Source/tasks.c **** 
1361:FreeRTOS/Source/tasks.c **** 			#if ( INCLUDE_vTaskSuspend == 1 )
1362:FreeRTOS/Source/tasks.c **** 				else if( pxStateList == &xSuspendedTaskList )
1363:FreeRTOS/Source/tasks.c **** 				{
1364:FreeRTOS/Source/tasks.c **** 					/* The task being queried is referenced from the suspended
1365:FreeRTOS/Source/tasks.c **** 					list.  Is it genuinely suspended or is it block
1366:FreeRTOS/Source/tasks.c **** 					indefinitely? */
1367:FreeRTOS/Source/tasks.c **** 					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL )
1368:FreeRTOS/Source/tasks.c **** 					{
1369:FreeRTOS/Source/tasks.c **** 						eReturn = eSuspended;
1370:FreeRTOS/Source/tasks.c **** 					}
1371:FreeRTOS/Source/tasks.c **** 					else
1372:FreeRTOS/Source/tasks.c **** 					{
1373:FreeRTOS/Source/tasks.c **** 						eReturn = eBlocked;
1374:FreeRTOS/Source/tasks.c **** 					}
1375:FreeRTOS/Source/tasks.c **** 				}
1376:FreeRTOS/Source/tasks.c **** 			#endif
1377:FreeRTOS/Source/tasks.c **** 
1378:FreeRTOS/Source/tasks.c **** 			#if ( INCLUDE_vTaskDelete == 1 )
1379:FreeRTOS/Source/tasks.c **** 				else if( ( pxStateList == &xTasksWaitingTermination ) || ( pxStateList == NULL ) )
1380:FreeRTOS/Source/tasks.c **** 				{
1381:FreeRTOS/Source/tasks.c **** 					/* The task being queried is referenced from the deleted
1382:FreeRTOS/Source/tasks.c **** 					tasks list, or it is not referenced from any lists at
1383:FreeRTOS/Source/tasks.c **** 					all. */
1384:FreeRTOS/Source/tasks.c **** 					eReturn = eDeleted;
1385:FreeRTOS/Source/tasks.c **** 				}
1386:FreeRTOS/Source/tasks.c **** 			#endif
1387:FreeRTOS/Source/tasks.c **** 
1388:FreeRTOS/Source/tasks.c **** 			else /*lint !e525 Negative indentation is intended to make use of pre-processor clearer. */
1389:FreeRTOS/Source/tasks.c **** 			{
1390:FreeRTOS/Source/tasks.c **** 				/* If the task is not in any other state, it must be in the
1391:FreeRTOS/Source/tasks.c **** 				Ready (including pending ready) state. */
1392:FreeRTOS/Source/tasks.c **** 				eReturn = eReady;
1393:FreeRTOS/Source/tasks.c **** 			}
1394:FreeRTOS/Source/tasks.c **** 		}
1395:FreeRTOS/Source/tasks.c **** 
1396:FreeRTOS/Source/tasks.c **** 		return eReturn;
1397:FreeRTOS/Source/tasks.c **** 	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
1398:FreeRTOS/Source/tasks.c **** 
1399:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_eTaskGetState */
1400:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1401:FreeRTOS/Source/tasks.c **** 
1402:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_uxTaskPriorityGet == 1 )
1403:FreeRTOS/Source/tasks.c **** 
1404:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask )
1405:FreeRTOS/Source/tasks.c **** 	{
1406:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
1407:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxReturn;
1408:FreeRTOS/Source/tasks.c **** 
1409:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
1410:FreeRTOS/Source/tasks.c **** 		{
1411:FreeRTOS/Source/tasks.c **** 			/* If null is passed in here then it is the priority of the that
1412:FreeRTOS/Source/tasks.c **** 			called uxTaskPriorityGet() that is being queried. */
1413:FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTask );
1414:FreeRTOS/Source/tasks.c **** 			uxReturn = pxTCB->uxPriority;
1415:FreeRTOS/Source/tasks.c **** 		}
1416:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
1417:FreeRTOS/Source/tasks.c **** 
1418:FreeRTOS/Source/tasks.c **** 		return uxReturn;
1419:FreeRTOS/Source/tasks.c **** 	}
1420:FreeRTOS/Source/tasks.c **** 
1421:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_uxTaskPriorityGet */
1422:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1423:FreeRTOS/Source/tasks.c **** 
1424:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_uxTaskPriorityGet == 1 )
1425:FreeRTOS/Source/tasks.c **** 
1426:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxTaskPriorityGetFromISR( TaskHandle_t xTask )
1427:FreeRTOS/Source/tasks.c **** 	{
1428:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
1429:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxReturn, uxSavedInterruptState;
1430:FreeRTOS/Source/tasks.c **** 
1431:FreeRTOS/Source/tasks.c **** 		/* RTOS ports that support interrupt nesting have the concept of a
1432:FreeRTOS/Source/tasks.c **** 		maximum	system call (or maximum API call) interrupt priority.
1433:FreeRTOS/Source/tasks.c **** 		Interrupts that are	above the maximum system call priority are keep
1434:FreeRTOS/Source/tasks.c **** 		permanently enabled, even when the RTOS kernel is in a critical section,
1435:FreeRTOS/Source/tasks.c **** 		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
1436:FreeRTOS/Source/tasks.c **** 		is defined in FreeRTOSConfig.h then
1437:FreeRTOS/Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1438:FreeRTOS/Source/tasks.c **** 		failure if a FreeRTOS API function is called from an interrupt that has
1439:FreeRTOS/Source/tasks.c **** 		been assigned a priority above the configured maximum system call
1440:FreeRTOS/Source/tasks.c **** 		priority.  Only FreeRTOS functions that end in FromISR can be called
1441:FreeRTOS/Source/tasks.c **** 		from interrupts	that have been assigned a priority at or (logically)
1442:FreeRTOS/Source/tasks.c **** 		below the maximum system call interrupt priority.  FreeRTOS maintains a
1443:FreeRTOS/Source/tasks.c **** 		separate interrupt safe API to ensure interrupt entry is as fast and as
1444:FreeRTOS/Source/tasks.c **** 		simple as possible.  More information (albeit Cortex-M specific) is
1445:FreeRTOS/Source/tasks.c **** 		provided on the following link:
1446:FreeRTOS/Source/tasks.c **** 		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1447:FreeRTOS/Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1448:FreeRTOS/Source/tasks.c **** 
1449:FreeRTOS/Source/tasks.c **** 		uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
1450:FreeRTOS/Source/tasks.c **** 		{
1451:FreeRTOS/Source/tasks.c **** 			/* If null is passed in here then it is the priority of the calling
1452:FreeRTOS/Source/tasks.c **** 			task that is being queried. */
1453:FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTask );
1454:FreeRTOS/Source/tasks.c **** 			uxReturn = pxTCB->uxPriority;
1455:FreeRTOS/Source/tasks.c **** 		}
1456:FreeRTOS/Source/tasks.c **** 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptState );
1457:FreeRTOS/Source/tasks.c **** 
1458:FreeRTOS/Source/tasks.c **** 		return uxReturn;
1459:FreeRTOS/Source/tasks.c **** 	}
1460:FreeRTOS/Source/tasks.c **** 
1461:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_uxTaskPriorityGet */
1462:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1463:FreeRTOS/Source/tasks.c **** 
1464:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskPrioritySet == 1 )
1465:FreeRTOS/Source/tasks.c **** 
1466:FreeRTOS/Source/tasks.c **** 	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
1467:FreeRTOS/Source/tasks.c **** 	{
1468:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
1469:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
1470:FreeRTOS/Source/tasks.c **** 	BaseType_t xYieldRequired = pdFALSE;
1471:FreeRTOS/Source/tasks.c **** 
1472:FreeRTOS/Source/tasks.c **** 		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
1473:FreeRTOS/Source/tasks.c **** 
1474:FreeRTOS/Source/tasks.c **** 		/* Ensure the new priority is valid. */
1475:FreeRTOS/Source/tasks.c **** 		if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
1476:FreeRTOS/Source/tasks.c **** 		{
1477:FreeRTOS/Source/tasks.c **** 			uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
1478:FreeRTOS/Source/tasks.c **** 		}
1479:FreeRTOS/Source/tasks.c **** 		else
1480:FreeRTOS/Source/tasks.c **** 		{
1481:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1482:FreeRTOS/Source/tasks.c **** 		}
1483:FreeRTOS/Source/tasks.c **** 
1484:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
1485:FreeRTOS/Source/tasks.c **** 		{
1486:FreeRTOS/Source/tasks.c **** 			/* If null is passed in here then it is the priority of the calling
1487:FreeRTOS/Source/tasks.c **** 			task that is being changed. */
1488:FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTask );
1489:FreeRTOS/Source/tasks.c **** 
1490:FreeRTOS/Source/tasks.c **** 			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );
1491:FreeRTOS/Source/tasks.c **** 
1492:FreeRTOS/Source/tasks.c **** 			#if ( configUSE_MUTEXES == 1 )
1493:FreeRTOS/Source/tasks.c **** 			{
1494:FreeRTOS/Source/tasks.c **** 				uxCurrentBasePriority = pxTCB->uxBasePriority;
1495:FreeRTOS/Source/tasks.c **** 			}
1496:FreeRTOS/Source/tasks.c **** 			#else
1497:FreeRTOS/Source/tasks.c **** 			{
1498:FreeRTOS/Source/tasks.c **** 				uxCurrentBasePriority = pxTCB->uxPriority;
1499:FreeRTOS/Source/tasks.c **** 			}
1500:FreeRTOS/Source/tasks.c **** 			#endif
1501:FreeRTOS/Source/tasks.c **** 
1502:FreeRTOS/Source/tasks.c **** 			if( uxCurrentBasePriority != uxNewPriority )
1503:FreeRTOS/Source/tasks.c **** 			{
1504:FreeRTOS/Source/tasks.c **** 				/* The priority change may have readied a task of higher
1505:FreeRTOS/Source/tasks.c **** 				priority than the calling task. */
1506:FreeRTOS/Source/tasks.c **** 				if( uxNewPriority > uxCurrentBasePriority )
1507:FreeRTOS/Source/tasks.c **** 				{
1508:FreeRTOS/Source/tasks.c **** 					if( pxTCB != pxCurrentTCB )
1509:FreeRTOS/Source/tasks.c **** 					{
1510:FreeRTOS/Source/tasks.c **** 						/* The priority of a task other than the currently
1511:FreeRTOS/Source/tasks.c **** 						running task is being raised.  Is the priority being
1512:FreeRTOS/Source/tasks.c **** 						raised above that of the running task? */
1513:FreeRTOS/Source/tasks.c **** 						if( uxNewPriority >= pxCurrentTCB->uxPriority )
1514:FreeRTOS/Source/tasks.c **** 						{
1515:FreeRTOS/Source/tasks.c **** 							xYieldRequired = pdTRUE;
1516:FreeRTOS/Source/tasks.c **** 						}
1517:FreeRTOS/Source/tasks.c **** 						else
1518:FreeRTOS/Source/tasks.c **** 						{
1519:FreeRTOS/Source/tasks.c **** 							mtCOVERAGE_TEST_MARKER();
1520:FreeRTOS/Source/tasks.c **** 						}
1521:FreeRTOS/Source/tasks.c **** 					}
1522:FreeRTOS/Source/tasks.c **** 					else
1523:FreeRTOS/Source/tasks.c **** 					{
1524:FreeRTOS/Source/tasks.c **** 						/* The priority of the running task is being raised,
1525:FreeRTOS/Source/tasks.c **** 						but the running task must already be the highest
1526:FreeRTOS/Source/tasks.c **** 						priority task able to run so no yield is required. */
1527:FreeRTOS/Source/tasks.c **** 					}
1528:FreeRTOS/Source/tasks.c **** 				}
1529:FreeRTOS/Source/tasks.c **** 				else if( pxTCB == pxCurrentTCB )
1530:FreeRTOS/Source/tasks.c **** 				{
1531:FreeRTOS/Source/tasks.c **** 					/* Setting the priority of the running task down means
1532:FreeRTOS/Source/tasks.c **** 					there may now be another task of higher priority that
1533:FreeRTOS/Source/tasks.c **** 					is ready to execute. */
1534:FreeRTOS/Source/tasks.c **** 					xYieldRequired = pdTRUE;
1535:FreeRTOS/Source/tasks.c **** 				}
1536:FreeRTOS/Source/tasks.c **** 				else
1537:FreeRTOS/Source/tasks.c **** 				{
1538:FreeRTOS/Source/tasks.c **** 					/* Setting the priority of any other task down does not
1539:FreeRTOS/Source/tasks.c **** 					require a yield as the running task must be above the
1540:FreeRTOS/Source/tasks.c **** 					new priority of the task being modified. */
1541:FreeRTOS/Source/tasks.c **** 				}
1542:FreeRTOS/Source/tasks.c **** 
1543:FreeRTOS/Source/tasks.c **** 				/* Remember the ready list the task might be referenced from
1544:FreeRTOS/Source/tasks.c **** 				before its uxPriority member is changed so the
1545:FreeRTOS/Source/tasks.c **** 				taskRESET_READY_PRIORITY() macro can function correctly. */
1546:FreeRTOS/Source/tasks.c **** 				uxPriorityUsedOnEntry = pxTCB->uxPriority;
1547:FreeRTOS/Source/tasks.c **** 
1548:FreeRTOS/Source/tasks.c **** 				#if ( configUSE_MUTEXES == 1 )
1549:FreeRTOS/Source/tasks.c **** 				{
1550:FreeRTOS/Source/tasks.c **** 					/* Only change the priority being used if the task is not
1551:FreeRTOS/Source/tasks.c **** 					currently using an inherited priority. */
1552:FreeRTOS/Source/tasks.c **** 					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
1553:FreeRTOS/Source/tasks.c **** 					{
1554:FreeRTOS/Source/tasks.c **** 						pxTCB->uxPriority = uxNewPriority;
1555:FreeRTOS/Source/tasks.c **** 					}
1556:FreeRTOS/Source/tasks.c **** 					else
1557:FreeRTOS/Source/tasks.c **** 					{
1558:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
1559:FreeRTOS/Source/tasks.c **** 					}
1560:FreeRTOS/Source/tasks.c **** 
1561:FreeRTOS/Source/tasks.c **** 					/* The base priority gets set whatever. */
1562:FreeRTOS/Source/tasks.c **** 					pxTCB->uxBasePriority = uxNewPriority;
1563:FreeRTOS/Source/tasks.c **** 				}
1564:FreeRTOS/Source/tasks.c **** 				#else
1565:FreeRTOS/Source/tasks.c **** 				{
1566:FreeRTOS/Source/tasks.c **** 					pxTCB->uxPriority = uxNewPriority;
1567:FreeRTOS/Source/tasks.c **** 				}
1568:FreeRTOS/Source/tasks.c **** 				#endif
1569:FreeRTOS/Source/tasks.c **** 
1570:FreeRTOS/Source/tasks.c **** 				/* Only reset the event list item value if the value is not
1571:FreeRTOS/Source/tasks.c **** 				being used for anything else. */
1572:FreeRTOS/Source/tasks.c **** 				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE 
1573:FreeRTOS/Source/tasks.c **** 				{
1574:FreeRTOS/Source/tasks.c **** 					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - (
1575:FreeRTOS/Source/tasks.c **** 				}
1576:FreeRTOS/Source/tasks.c **** 				else
1577:FreeRTOS/Source/tasks.c **** 				{
1578:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1579:FreeRTOS/Source/tasks.c **** 				}
1580:FreeRTOS/Source/tasks.c **** 
1581:FreeRTOS/Source/tasks.c **** 				/* If the task is in the blocked or suspended list we need do
1582:FreeRTOS/Source/tasks.c **** 				nothing more than change its priority variable. However, if
1583:FreeRTOS/Source/tasks.c **** 				the task is in a ready list it needs to be removed and placed
1584:FreeRTOS/Source/tasks.c **** 				in the list appropriate to its new priority. */
1585:FreeRTOS/Source/tasks.c **** 				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateL
1586:FreeRTOS/Source/tasks.c **** 				{
1587:FreeRTOS/Source/tasks.c **** 					/* The task is currently in its ready list - remove before
1588:FreeRTOS/Source/tasks.c **** 					adding it to it's new ready list.  As we are in a critical
1589:FreeRTOS/Source/tasks.c **** 					section we can do this even if the scheduler is suspended. */
1590:FreeRTOS/Source/tasks.c **** 					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
1591:FreeRTOS/Source/tasks.c **** 					{
1592:FreeRTOS/Source/tasks.c **** 						/* It is known that the task is in its ready list so
1593:FreeRTOS/Source/tasks.c **** 						there is no need to check again and the port level
1594:FreeRTOS/Source/tasks.c **** 						reset macro can be called directly. */
1595:FreeRTOS/Source/tasks.c **** 						portRESET_READY_PRIORITY( uxPriorityUsedOnEntry, uxTopReadyPriority );
1596:FreeRTOS/Source/tasks.c **** 					}
1597:FreeRTOS/Source/tasks.c **** 					else
1598:FreeRTOS/Source/tasks.c **** 					{
1599:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
1600:FreeRTOS/Source/tasks.c **** 					}
1601:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
1602:FreeRTOS/Source/tasks.c **** 				}
1603:FreeRTOS/Source/tasks.c **** 				else
1604:FreeRTOS/Source/tasks.c **** 				{
1605:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1606:FreeRTOS/Source/tasks.c **** 				}
1607:FreeRTOS/Source/tasks.c **** 
1608:FreeRTOS/Source/tasks.c **** 				if( xYieldRequired != pdFALSE )
1609:FreeRTOS/Source/tasks.c **** 				{
1610:FreeRTOS/Source/tasks.c **** 					taskYIELD_IF_USING_PREEMPTION();
1611:FreeRTOS/Source/tasks.c **** 				}
1612:FreeRTOS/Source/tasks.c **** 				else
1613:FreeRTOS/Source/tasks.c **** 				{
1614:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1615:FreeRTOS/Source/tasks.c **** 				}
1616:FreeRTOS/Source/tasks.c **** 
1617:FreeRTOS/Source/tasks.c **** 				/* Remove compiler warning about unused variables when the port
1618:FreeRTOS/Source/tasks.c **** 				optimised task selection is not being used. */
1619:FreeRTOS/Source/tasks.c **** 				( void ) uxPriorityUsedOnEntry;
1620:FreeRTOS/Source/tasks.c **** 			}
1621:FreeRTOS/Source/tasks.c **** 		}
1622:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
1623:FreeRTOS/Source/tasks.c **** 	}
1624:FreeRTOS/Source/tasks.c **** 
1625:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskPrioritySet */
1626:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1627:FreeRTOS/Source/tasks.c **** 
1628:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1629:FreeRTOS/Source/tasks.c **** 
1630:FreeRTOS/Source/tasks.c **** 	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
1631:FreeRTOS/Source/tasks.c **** 	{
1632:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
1633:FreeRTOS/Source/tasks.c **** 
1634:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
1635:FreeRTOS/Source/tasks.c **** 		{
1636:FreeRTOS/Source/tasks.c **** 			/* If null is passed in here then it is the running task that is
1637:FreeRTOS/Source/tasks.c **** 			being suspended. */
1638:FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
1639:FreeRTOS/Source/tasks.c **** 
1640:FreeRTOS/Source/tasks.c **** 			traceTASK_SUSPEND( pxTCB );
1641:FreeRTOS/Source/tasks.c **** 
1642:FreeRTOS/Source/tasks.c **** 			/* Remove task from the ready/delayed list and place in the
1643:FreeRTOS/Source/tasks.c **** 			suspended list. */
1644:FreeRTOS/Source/tasks.c **** 			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
1645:FreeRTOS/Source/tasks.c **** 			{
1646:FreeRTOS/Source/tasks.c **** 				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
1647:FreeRTOS/Source/tasks.c **** 			}
1648:FreeRTOS/Source/tasks.c **** 			else
1649:FreeRTOS/Source/tasks.c **** 			{
1650:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1651:FreeRTOS/Source/tasks.c **** 			}
1652:FreeRTOS/Source/tasks.c **** 
1653:FreeRTOS/Source/tasks.c **** 			/* Is the task waiting on an event also? */
1654:FreeRTOS/Source/tasks.c **** 			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
1655:FreeRTOS/Source/tasks.c **** 			{
1656:FreeRTOS/Source/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
1657:FreeRTOS/Source/tasks.c **** 			}
1658:FreeRTOS/Source/tasks.c **** 			else
1659:FreeRTOS/Source/tasks.c **** 			{
1660:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1661:FreeRTOS/Source/tasks.c **** 			}
1662:FreeRTOS/Source/tasks.c **** 
1663:FreeRTOS/Source/tasks.c **** 			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
1664:FreeRTOS/Source/tasks.c **** 
1665:FreeRTOS/Source/tasks.c **** 			#if( configUSE_TASK_NOTIFICATIONS == 1 )
1666:FreeRTOS/Source/tasks.c **** 			{
1667:FreeRTOS/Source/tasks.c **** 				if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
1668:FreeRTOS/Source/tasks.c **** 				{
1669:FreeRTOS/Source/tasks.c **** 					/* The task was blocked to wait for a notification, but is
1670:FreeRTOS/Source/tasks.c **** 					now suspended, so no notification was received. */
1671:FreeRTOS/Source/tasks.c **** 					pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
1672:FreeRTOS/Source/tasks.c **** 				}
1673:FreeRTOS/Source/tasks.c **** 			}
1674:FreeRTOS/Source/tasks.c **** 			#endif
1675:FreeRTOS/Source/tasks.c **** 		}
1676:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
1677:FreeRTOS/Source/tasks.c **** 
1678:FreeRTOS/Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
1679:FreeRTOS/Source/tasks.c **** 		{
1680:FreeRTOS/Source/tasks.c **** 			/* Reset the next expected unblock time in case it referred to the
1681:FreeRTOS/Source/tasks.c **** 			task that is now in the Suspended state. */
1682:FreeRTOS/Source/tasks.c **** 			taskENTER_CRITICAL();
1683:FreeRTOS/Source/tasks.c **** 			{
1684:FreeRTOS/Source/tasks.c **** 				prvResetNextTaskUnblockTime();
1685:FreeRTOS/Source/tasks.c **** 			}
1686:FreeRTOS/Source/tasks.c **** 			taskEXIT_CRITICAL();
1687:FreeRTOS/Source/tasks.c **** 		}
1688:FreeRTOS/Source/tasks.c **** 		else
1689:FreeRTOS/Source/tasks.c **** 		{
1690:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1691:FreeRTOS/Source/tasks.c **** 		}
1692:FreeRTOS/Source/tasks.c **** 
1693:FreeRTOS/Source/tasks.c **** 		if( pxTCB == pxCurrentTCB )
1694:FreeRTOS/Source/tasks.c **** 		{
1695:FreeRTOS/Source/tasks.c **** 			if( xSchedulerRunning != pdFALSE )
1696:FreeRTOS/Source/tasks.c **** 			{
1697:FreeRTOS/Source/tasks.c **** 				/* The current task has just been suspended. */
1698:FreeRTOS/Source/tasks.c **** 				configASSERT( uxSchedulerSuspended == 0 );
1699:FreeRTOS/Source/tasks.c **** 				portYIELD_WITHIN_API();
1700:FreeRTOS/Source/tasks.c **** 			}
1701:FreeRTOS/Source/tasks.c **** 			else
1702:FreeRTOS/Source/tasks.c **** 			{
1703:FreeRTOS/Source/tasks.c **** 				/* The scheduler is not running, but the task that was pointed
1704:FreeRTOS/Source/tasks.c **** 				to by pxCurrentTCB has just been suspended and pxCurrentTCB
1705:FreeRTOS/Source/tasks.c **** 				must be adjusted to point to a different task. */
1706:FreeRTOS/Source/tasks.c **** 				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
1707:FreeRTOS/Source/tasks.c **** 				{
1708:FreeRTOS/Source/tasks.c **** 					/* No other tasks are ready, so set pxCurrentTCB back to
1709:FreeRTOS/Source/tasks.c **** 					NULL so when the next task is created pxCurrentTCB will
1710:FreeRTOS/Source/tasks.c **** 					be set to point to it no matter what its relative priority
1711:FreeRTOS/Source/tasks.c **** 					is. */
1712:FreeRTOS/Source/tasks.c **** 					pxCurrentTCB = NULL;
1713:FreeRTOS/Source/tasks.c **** 				}
1714:FreeRTOS/Source/tasks.c **** 				else
1715:FreeRTOS/Source/tasks.c **** 				{
1716:FreeRTOS/Source/tasks.c **** 					vTaskSwitchContext();
1717:FreeRTOS/Source/tasks.c **** 				}
1718:FreeRTOS/Source/tasks.c **** 			}
1719:FreeRTOS/Source/tasks.c **** 		}
1720:FreeRTOS/Source/tasks.c **** 		else
1721:FreeRTOS/Source/tasks.c **** 		{
1722:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1723:FreeRTOS/Source/tasks.c **** 		}
1724:FreeRTOS/Source/tasks.c **** 	}
1725:FreeRTOS/Source/tasks.c **** 
1726:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
1727:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1728:FreeRTOS/Source/tasks.c **** 
1729:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1730:FreeRTOS/Source/tasks.c **** 
1731:FreeRTOS/Source/tasks.c **** 	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
1732:FreeRTOS/Source/tasks.c **** 	{
1733:FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn = pdFALSE;
1734:FreeRTOS/Source/tasks.c **** 	const TCB_t * const pxTCB = ( TCB_t * ) xTask;
1735:FreeRTOS/Source/tasks.c **** 
1736:FreeRTOS/Source/tasks.c **** 		/* Accesses xPendingReadyList so must be called from a critical
1737:FreeRTOS/Source/tasks.c **** 		section. */
1738:FreeRTOS/Source/tasks.c **** 
1739:FreeRTOS/Source/tasks.c **** 		/* It does not make sense to check if the calling task is suspended. */
1740:FreeRTOS/Source/tasks.c **** 		configASSERT( xTask );
1741:FreeRTOS/Source/tasks.c **** 
1742:FreeRTOS/Source/tasks.c **** 		/* Is the task being resumed actually in the suspended list? */
1743:FreeRTOS/Source/tasks.c **** 		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
1744:FreeRTOS/Source/tasks.c **** 		{
1745:FreeRTOS/Source/tasks.c **** 			/* Has the task already been resumed from within an ISR? */
1746:FreeRTOS/Source/tasks.c **** 			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
1747:FreeRTOS/Source/tasks.c **** 			{
1748:FreeRTOS/Source/tasks.c **** 				/* Is it in the suspended list because it is in the	Suspended
1749:FreeRTOS/Source/tasks.c **** 				state, or because is is blocked with no timeout? */
1750:FreeRTOS/Source/tasks.c **** 				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The
1751:FreeRTOS/Source/tasks.c **** 				{
1752:FreeRTOS/Source/tasks.c **** 					xReturn = pdTRUE;
1753:FreeRTOS/Source/tasks.c **** 				}
1754:FreeRTOS/Source/tasks.c **** 				else
1755:FreeRTOS/Source/tasks.c **** 				{
1756:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1757:FreeRTOS/Source/tasks.c **** 				}
1758:FreeRTOS/Source/tasks.c **** 			}
1759:FreeRTOS/Source/tasks.c **** 			else
1760:FreeRTOS/Source/tasks.c **** 			{
1761:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1762:FreeRTOS/Source/tasks.c **** 			}
1763:FreeRTOS/Source/tasks.c **** 		}
1764:FreeRTOS/Source/tasks.c **** 		else
1765:FreeRTOS/Source/tasks.c **** 		{
1766:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1767:FreeRTOS/Source/tasks.c **** 		}
1768:FreeRTOS/Source/tasks.c **** 
1769:FreeRTOS/Source/tasks.c **** 		return xReturn;
1770:FreeRTOS/Source/tasks.c **** 	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
1771:FreeRTOS/Source/tasks.c **** 
1772:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
1773:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1774:FreeRTOS/Source/tasks.c **** 
1775:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1776:FreeRTOS/Source/tasks.c **** 
1777:FreeRTOS/Source/tasks.c **** 	void vTaskResume( TaskHandle_t xTaskToResume )
1778:FreeRTOS/Source/tasks.c **** 	{
1779:FreeRTOS/Source/tasks.c **** 	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
1780:FreeRTOS/Source/tasks.c **** 
1781:FreeRTOS/Source/tasks.c **** 		/* It does not make sense to resume the calling task. */
1782:FreeRTOS/Source/tasks.c **** 		configASSERT( xTaskToResume );
1783:FreeRTOS/Source/tasks.c **** 
1784:FreeRTOS/Source/tasks.c **** 		/* The parameter cannot be NULL as it is impossible to resume the
1785:FreeRTOS/Source/tasks.c **** 		currently executing task. */
1786:FreeRTOS/Source/tasks.c **** 		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
1787:FreeRTOS/Source/tasks.c **** 		{
1788:FreeRTOS/Source/tasks.c **** 			taskENTER_CRITICAL();
1789:FreeRTOS/Source/tasks.c **** 			{
1790:FreeRTOS/Source/tasks.c **** 				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
1791:FreeRTOS/Source/tasks.c **** 				{
1792:FreeRTOS/Source/tasks.c **** 					traceTASK_RESUME( pxTCB );
1793:FreeRTOS/Source/tasks.c **** 
1794:FreeRTOS/Source/tasks.c **** 					/* The ready list can be accessed even if the scheduler is
1795:FreeRTOS/Source/tasks.c **** 					suspended because this is inside a critical section. */
1796:FreeRTOS/Source/tasks.c **** 					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
1797:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
1798:FreeRTOS/Source/tasks.c **** 
1799:FreeRTOS/Source/tasks.c **** 					/* A higher priority task may have just been resumed. */
1800:FreeRTOS/Source/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
1801:FreeRTOS/Source/tasks.c **** 					{
1802:FreeRTOS/Source/tasks.c **** 						/* This yield may not cause the task just resumed to run,
1803:FreeRTOS/Source/tasks.c **** 						but will leave the lists in the correct state for the
1804:FreeRTOS/Source/tasks.c **** 						next yield. */
1805:FreeRTOS/Source/tasks.c **** 						taskYIELD_IF_USING_PREEMPTION();
1806:FreeRTOS/Source/tasks.c **** 					}
1807:FreeRTOS/Source/tasks.c **** 					else
1808:FreeRTOS/Source/tasks.c **** 					{
1809:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
1810:FreeRTOS/Source/tasks.c **** 					}
1811:FreeRTOS/Source/tasks.c **** 				}
1812:FreeRTOS/Source/tasks.c **** 				else
1813:FreeRTOS/Source/tasks.c **** 				{
1814:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1815:FreeRTOS/Source/tasks.c **** 				}
1816:FreeRTOS/Source/tasks.c **** 			}
1817:FreeRTOS/Source/tasks.c **** 			taskEXIT_CRITICAL();
1818:FreeRTOS/Source/tasks.c **** 		}
1819:FreeRTOS/Source/tasks.c **** 		else
1820:FreeRTOS/Source/tasks.c **** 		{
1821:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1822:FreeRTOS/Source/tasks.c **** 		}
1823:FreeRTOS/Source/tasks.c **** 	}
1824:FreeRTOS/Source/tasks.c **** 
1825:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
1826:FreeRTOS/Source/tasks.c **** 
1827:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1828:FreeRTOS/Source/tasks.c **** 
1829:FreeRTOS/Source/tasks.c **** #if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )
1830:FreeRTOS/Source/tasks.c **** 
1831:FreeRTOS/Source/tasks.c **** 	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
1832:FreeRTOS/Source/tasks.c **** 	{
1833:FreeRTOS/Source/tasks.c **** 	BaseType_t xYieldRequired = pdFALSE;
1834:FreeRTOS/Source/tasks.c **** 	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
1835:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxSavedInterruptStatus;
1836:FreeRTOS/Source/tasks.c **** 
1837:FreeRTOS/Source/tasks.c **** 		configASSERT( xTaskToResume );
1838:FreeRTOS/Source/tasks.c **** 
1839:FreeRTOS/Source/tasks.c **** 		/* RTOS ports that support interrupt nesting have the concept of a
1840:FreeRTOS/Source/tasks.c **** 		maximum	system call (or maximum API call) interrupt priority.
1841:FreeRTOS/Source/tasks.c **** 		Interrupts that are	above the maximum system call priority are keep
1842:FreeRTOS/Source/tasks.c **** 		permanently enabled, even when the RTOS kernel is in a critical section,
1843:FreeRTOS/Source/tasks.c **** 		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
1844:FreeRTOS/Source/tasks.c **** 		is defined in FreeRTOSConfig.h then
1845:FreeRTOS/Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1846:FreeRTOS/Source/tasks.c **** 		failure if a FreeRTOS API function is called from an interrupt that has
1847:FreeRTOS/Source/tasks.c **** 		been assigned a priority above the configured maximum system call
1848:FreeRTOS/Source/tasks.c **** 		priority.  Only FreeRTOS functions that end in FromISR can be called
1849:FreeRTOS/Source/tasks.c **** 		from interrupts	that have been assigned a priority at or (logically)
1850:FreeRTOS/Source/tasks.c **** 		below the maximum system call interrupt priority.  FreeRTOS maintains a
1851:FreeRTOS/Source/tasks.c **** 		separate interrupt safe API to ensure interrupt entry is as fast and as
1852:FreeRTOS/Source/tasks.c **** 		simple as possible.  More information (albeit Cortex-M specific) is
1853:FreeRTOS/Source/tasks.c **** 		provided on the following link:
1854:FreeRTOS/Source/tasks.c **** 		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1855:FreeRTOS/Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1856:FreeRTOS/Source/tasks.c **** 
1857:FreeRTOS/Source/tasks.c **** 		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
1858:FreeRTOS/Source/tasks.c **** 		{
1859:FreeRTOS/Source/tasks.c **** 			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
1860:FreeRTOS/Source/tasks.c **** 			{
1861:FreeRTOS/Source/tasks.c **** 				traceTASK_RESUME_FROM_ISR( pxTCB );
1862:FreeRTOS/Source/tasks.c **** 
1863:FreeRTOS/Source/tasks.c **** 				/* Check the ready lists can be accessed. */
1864:FreeRTOS/Source/tasks.c **** 				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
1865:FreeRTOS/Source/tasks.c **** 				{
1866:FreeRTOS/Source/tasks.c **** 					/* Ready lists can be accessed so move the task from the
1867:FreeRTOS/Source/tasks.c **** 					suspended list to the ready list directly. */
1868:FreeRTOS/Source/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
1869:FreeRTOS/Source/tasks.c **** 					{
1870:FreeRTOS/Source/tasks.c **** 						xYieldRequired = pdTRUE;
1871:FreeRTOS/Source/tasks.c **** 					}
1872:FreeRTOS/Source/tasks.c **** 					else
1873:FreeRTOS/Source/tasks.c **** 					{
1874:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
1875:FreeRTOS/Source/tasks.c **** 					}
1876:FreeRTOS/Source/tasks.c **** 
1877:FreeRTOS/Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
1878:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
1879:FreeRTOS/Source/tasks.c **** 				}
1880:FreeRTOS/Source/tasks.c **** 				else
1881:FreeRTOS/Source/tasks.c **** 				{
1882:FreeRTOS/Source/tasks.c **** 					/* The delayed or ready lists cannot be accessed so the task
1883:FreeRTOS/Source/tasks.c **** 					is held in the pending ready list until the scheduler is
1884:FreeRTOS/Source/tasks.c **** 					unsuspended. */
1885:FreeRTOS/Source/tasks.c **** 					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
1886:FreeRTOS/Source/tasks.c **** 				}
1887:FreeRTOS/Source/tasks.c **** 			}
1888:FreeRTOS/Source/tasks.c **** 			else
1889:FreeRTOS/Source/tasks.c **** 			{
1890:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1891:FreeRTOS/Source/tasks.c **** 			}
1892:FreeRTOS/Source/tasks.c **** 		}
1893:FreeRTOS/Source/tasks.c **** 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1894:FreeRTOS/Source/tasks.c **** 
1895:FreeRTOS/Source/tasks.c **** 		return xYieldRequired;
1896:FreeRTOS/Source/tasks.c **** 	}
1897:FreeRTOS/Source/tasks.c **** 
1898:FreeRTOS/Source/tasks.c **** #endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
1899:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1900:FreeRTOS/Source/tasks.c **** 
1901:FreeRTOS/Source/tasks.c **** void vTaskStartScheduler( void )
1902:FreeRTOS/Source/tasks.c **** {
1903:FreeRTOS/Source/tasks.c **** BaseType_t xReturn;
1904:FreeRTOS/Source/tasks.c **** 
1905:FreeRTOS/Source/tasks.c **** 	/* Add the idle task at the lowest priority. */
1906:FreeRTOS/Source/tasks.c **** 	#if( configSUPPORT_STATIC_ALLOCATION == 1 )
1907:FreeRTOS/Source/tasks.c **** 	{
1908:FreeRTOS/Source/tasks.c **** 		StaticTask_t *pxIdleTaskTCBBuffer = NULL;
1909:FreeRTOS/Source/tasks.c **** 		StackType_t *pxIdleTaskStackBuffer = NULL;
1910:FreeRTOS/Source/tasks.c **** 		uint32_t ulIdleTaskStackSize;
1911:FreeRTOS/Source/tasks.c **** 
1912:FreeRTOS/Source/tasks.c **** 		/* The Idle task is created using user provided RAM - obtain the
1913:FreeRTOS/Source/tasks.c **** 		address of the RAM then create the idle task. */
1914:FreeRTOS/Source/tasks.c **** 		vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &ulIdleTaskStackSize
1915:FreeRTOS/Source/tasks.c **** 		xIdleTaskHandle = xTaskCreateStatic(	prvIdleTask,
1916:FreeRTOS/Source/tasks.c **** 												configIDLE_TASK_NAME,
1917:FreeRTOS/Source/tasks.c **** 												ulIdleTaskStackSize,
1918:FreeRTOS/Source/tasks.c **** 												( void * ) NULL, /*lint !e961.  The cast is not redundant for all compilers. */
1919:FreeRTOS/Source/tasks.c **** 												( tskIDLE_PRIORITY | portPRIVILEGE_BIT ),
1920:FreeRTOS/Source/tasks.c **** 												pxIdleTaskStackBuffer,
1921:FreeRTOS/Source/tasks.c **** 												pxIdleTaskTCBBuffer ); /*lint !e961 MISRA exception, justified as it is not a redundant
1922:FreeRTOS/Source/tasks.c **** 
1923:FreeRTOS/Source/tasks.c **** 		if( xIdleTaskHandle != NULL )
1924:FreeRTOS/Source/tasks.c **** 		{
1925:FreeRTOS/Source/tasks.c **** 			xReturn = pdPASS;
1926:FreeRTOS/Source/tasks.c **** 		}
1927:FreeRTOS/Source/tasks.c **** 		else
1928:FreeRTOS/Source/tasks.c **** 		{
1929:FreeRTOS/Source/tasks.c **** 			xReturn = pdFAIL;
1930:FreeRTOS/Source/tasks.c **** 		}
1931:FreeRTOS/Source/tasks.c **** 	}
1932:FreeRTOS/Source/tasks.c **** 	#else
1933:FreeRTOS/Source/tasks.c **** 	{
1934:FreeRTOS/Source/tasks.c **** 		/* The Idle task is being created using dynamically allocated RAM. */
1935:FreeRTOS/Source/tasks.c **** 		xReturn = xTaskCreate(	prvIdleTask,
1936:FreeRTOS/Source/tasks.c **** 								configIDLE_TASK_NAME,
1937:FreeRTOS/Source/tasks.c **** 								configMINIMAL_STACK_SIZE,
1938:FreeRTOS/Source/tasks.c **** 								( void * ) NULL,
1939:FreeRTOS/Source/tasks.c **** 								( tskIDLE_PRIORITY | portPRIVILEGE_BIT ),
1940:FreeRTOS/Source/tasks.c **** 								&xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explic
1941:FreeRTOS/Source/tasks.c **** 	}
1942:FreeRTOS/Source/tasks.c **** 	#endif /* configSUPPORT_STATIC_ALLOCATION */
1943:FreeRTOS/Source/tasks.c **** 
1944:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_TIMERS == 1 )
1945:FreeRTOS/Source/tasks.c **** 	{
1946:FreeRTOS/Source/tasks.c **** 		if( xReturn == pdPASS )
1947:FreeRTOS/Source/tasks.c **** 		{
1948:FreeRTOS/Source/tasks.c **** 			xReturn = xTimerCreateTimerTask();
1949:FreeRTOS/Source/tasks.c **** 		}
1950:FreeRTOS/Source/tasks.c **** 		else
1951:FreeRTOS/Source/tasks.c **** 		{
1952:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1953:FreeRTOS/Source/tasks.c **** 		}
1954:FreeRTOS/Source/tasks.c **** 	}
1955:FreeRTOS/Source/tasks.c **** 	#endif /* configUSE_TIMERS */
1956:FreeRTOS/Source/tasks.c **** 
1957:FreeRTOS/Source/tasks.c **** 	if( xReturn == pdPASS )
1958:FreeRTOS/Source/tasks.c **** 	{
1959:FreeRTOS/Source/tasks.c **** 		/* freertos_tasks_c_additions_init() should only be called if the user
1960:FreeRTOS/Source/tasks.c **** 		definable macro FREERTOS_TASKS_C_ADDITIONS_INIT() is defined, as that is
1961:FreeRTOS/Source/tasks.c **** 		the only macro called by the function. */
1962:FreeRTOS/Source/tasks.c **** 		#ifdef FREERTOS_TASKS_C_ADDITIONS_INIT
1963:FreeRTOS/Source/tasks.c **** 		{
1964:FreeRTOS/Source/tasks.c **** 			freertos_tasks_c_additions_init();
1965:FreeRTOS/Source/tasks.c **** 		}
1966:FreeRTOS/Source/tasks.c **** 		#endif
1967:FreeRTOS/Source/tasks.c **** 
1968:FreeRTOS/Source/tasks.c **** 		/* Interrupts are turned off here, to ensure a tick does not occur
1969:FreeRTOS/Source/tasks.c **** 		before or during the call to xPortStartScheduler().  The stacks of
1970:FreeRTOS/Source/tasks.c **** 		the created tasks contain a status word with interrupts switched on
1971:FreeRTOS/Source/tasks.c **** 		so interrupts will automatically get re-enabled when the first task
1972:FreeRTOS/Source/tasks.c **** 		starts to run. */
1973:FreeRTOS/Source/tasks.c **** 		portDISABLE_INTERRUPTS();
1974:FreeRTOS/Source/tasks.c **** 
1975:FreeRTOS/Source/tasks.c **** 		#if ( configUSE_NEWLIB_REENTRANT == 1 )
1976:FreeRTOS/Source/tasks.c **** 		{
1977:FreeRTOS/Source/tasks.c **** 			/* Switch Newlib's _impure_ptr variable to point to the _reent
1978:FreeRTOS/Source/tasks.c **** 			structure specific to the task that will run first. */
1979:FreeRTOS/Source/tasks.c **** 			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
1980:FreeRTOS/Source/tasks.c **** 		}
1981:FreeRTOS/Source/tasks.c **** 		#endif /* configUSE_NEWLIB_REENTRANT */
1982:FreeRTOS/Source/tasks.c **** 
1983:FreeRTOS/Source/tasks.c **** 		xNextTaskUnblockTime = portMAX_DELAY;
1984:FreeRTOS/Source/tasks.c **** 		xSchedulerRunning = pdTRUE;
1985:FreeRTOS/Source/tasks.c **** 		xTickCount = ( TickType_t ) 0U;
1986:FreeRTOS/Source/tasks.c **** 
1987:FreeRTOS/Source/tasks.c **** 		/* If configGENERATE_RUN_TIME_STATS is defined then the following
1988:FreeRTOS/Source/tasks.c **** 		macro must be defined to configure the timer/counter used to generate
1989:FreeRTOS/Source/tasks.c **** 		the run time counter time base.   NOTE:  If configGENERATE_RUN_TIME_STATS
1990:FreeRTOS/Source/tasks.c **** 		is set to 0 and the following line fails to build then ensure you do not
1991:FreeRTOS/Source/tasks.c **** 		have portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() defined in your
1992:FreeRTOS/Source/tasks.c **** 		FreeRTOSConfig.h file. */
1993:FreeRTOS/Source/tasks.c **** 		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
1994:FreeRTOS/Source/tasks.c **** 
1995:FreeRTOS/Source/tasks.c **** 		/* Setting up the timer tick is hardware specific and thus in the
1996:FreeRTOS/Source/tasks.c **** 		portable interface. */
1997:FreeRTOS/Source/tasks.c **** 		if( xPortStartScheduler() != pdFALSE )
1998:FreeRTOS/Source/tasks.c **** 		{
1999:FreeRTOS/Source/tasks.c **** 			/* Should not reach here as if the scheduler is running the
2000:FreeRTOS/Source/tasks.c **** 			function will not return. */
2001:FreeRTOS/Source/tasks.c **** 		}
2002:FreeRTOS/Source/tasks.c **** 		else
2003:FreeRTOS/Source/tasks.c **** 		{
2004:FreeRTOS/Source/tasks.c **** 			/* Should only reach here if a task calls xTaskEndScheduler(). */
2005:FreeRTOS/Source/tasks.c **** 		}
2006:FreeRTOS/Source/tasks.c **** 	}
2007:FreeRTOS/Source/tasks.c **** 	else
2008:FreeRTOS/Source/tasks.c **** 	{
2009:FreeRTOS/Source/tasks.c **** 		/* This line will only be reached if the kernel could not be started,
2010:FreeRTOS/Source/tasks.c **** 		because there was not enough FreeRTOS heap to create the idle task
2011:FreeRTOS/Source/tasks.c **** 		or the timer task. */
2012:FreeRTOS/Source/tasks.c **** 		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
2013:FreeRTOS/Source/tasks.c **** 	}
2014:FreeRTOS/Source/tasks.c **** 
2015:FreeRTOS/Source/tasks.c **** 	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
2016:FreeRTOS/Source/tasks.c **** 	meaning xIdleTaskHandle is not used anywhere else. */
2017:FreeRTOS/Source/tasks.c **** 	( void ) xIdleTaskHandle;
2018:FreeRTOS/Source/tasks.c **** }
2019:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2020:FreeRTOS/Source/tasks.c **** 
2021:FreeRTOS/Source/tasks.c **** void vTaskEndScheduler( void )
2022:FreeRTOS/Source/tasks.c **** {
2023:FreeRTOS/Source/tasks.c **** 	/* Stop the scheduler interrupts and call the portable scheduler end
2024:FreeRTOS/Source/tasks.c **** 	routine so the original ISRs can be restored if necessary.  The port
2025:FreeRTOS/Source/tasks.c **** 	layer must ensure interrupts enable	bit is left in the correct state. */
2026:FreeRTOS/Source/tasks.c **** 	portDISABLE_INTERRUPTS();
2027:FreeRTOS/Source/tasks.c **** 	xSchedulerRunning = pdFALSE;
2028:FreeRTOS/Source/tasks.c **** 	vPortEndScheduler();
2029:FreeRTOS/Source/tasks.c **** }
2030:FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
2031:FreeRTOS/Source/tasks.c **** 
2032:FreeRTOS/Source/tasks.c **** void vTaskSuspendAll( void )
2033:FreeRTOS/Source/tasks.c **** {
2034:FreeRTOS/Source/tasks.c **** 	/* A critical section is not required as the variable is of type
2035:FreeRTOS/Source/tasks.c **** 	BaseType_t.  Please read Richard Barry's reply in the following link to a
2036:FreeRTOS/Source/tasks.c **** 	post in the FreeRTOS support forum before reporting this as a bug! -
2037:FreeRTOS/Source/tasks.c **** 	http://goo.gl/wu4acr */
2038:FreeRTOS/Source/tasks.c **** 	++uxSchedulerSuspended;
2039:FreeRTOS/Source/tasks.c **** }
2040:FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
2041:FreeRTOS/Source/tasks.c **** 
2042:FreeRTOS/Source/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
2043:FreeRTOS/Source/tasks.c **** 
2044:FreeRTOS/Source/tasks.c **** 	static TickType_t prvGetExpectedIdleTime( void )
2045:FreeRTOS/Source/tasks.c **** 	{
2046:FreeRTOS/Source/tasks.c **** 	TickType_t xReturn;
2047:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxHigherPriorityReadyTasks = pdFALSE;
2048:FreeRTOS/Source/tasks.c **** 
2049:FreeRTOS/Source/tasks.c **** 		/* uxHigherPriorityReadyTasks takes care of the case where
2050:FreeRTOS/Source/tasks.c **** 		configUSE_PREEMPTION is 0, so there may be tasks above the idle priority
2051:FreeRTOS/Source/tasks.c **** 		task that are in the Ready state, even though the idle task is
2052:FreeRTOS/Source/tasks.c **** 		running. */
2053:FreeRTOS/Source/tasks.c **** 		#if( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 )
2054:FreeRTOS/Source/tasks.c **** 		{
2055:FreeRTOS/Source/tasks.c **** 			if( uxTopReadyPriority > tskIDLE_PRIORITY )
2056:FreeRTOS/Source/tasks.c **** 			{
2057:FreeRTOS/Source/tasks.c **** 				uxHigherPriorityReadyTasks = pdTRUE;
2058:FreeRTOS/Source/tasks.c **** 			}
2059:FreeRTOS/Source/tasks.c **** 		}
2060:FreeRTOS/Source/tasks.c **** 		#else
2061:FreeRTOS/Source/tasks.c **** 		{
2062:FreeRTOS/Source/tasks.c **** 			const UBaseType_t uxLeastSignificantBit = ( UBaseType_t ) 0x01;
2063:FreeRTOS/Source/tasks.c **** 
2064:FreeRTOS/Source/tasks.c **** 			/* When port optimised task selection is used the uxTopReadyPriority
2065:FreeRTOS/Source/tasks.c **** 			variable is used as a bit map.  If bits other than the least
2066:FreeRTOS/Source/tasks.c **** 			significant bit are set then there are tasks that have a priority
2067:FreeRTOS/Source/tasks.c **** 			above the idle priority that are in the Ready state.  This takes
2068:FreeRTOS/Source/tasks.c **** 			care of the case where the co-operative scheduler is in use. */
2069:FreeRTOS/Source/tasks.c **** 			if( uxTopReadyPriority > uxLeastSignificantBit )
2070:FreeRTOS/Source/tasks.c **** 			{
2071:FreeRTOS/Source/tasks.c **** 				uxHigherPriorityReadyTasks = pdTRUE;
2072:FreeRTOS/Source/tasks.c **** 			}
2073:FreeRTOS/Source/tasks.c **** 		}
2074:FreeRTOS/Source/tasks.c **** 		#endif
2075:FreeRTOS/Source/tasks.c **** 
2076:FreeRTOS/Source/tasks.c **** 		if( pxCurrentTCB->uxPriority > tskIDLE_PRIORITY )
2077:FreeRTOS/Source/tasks.c **** 		{
2078:FreeRTOS/Source/tasks.c **** 			xReturn = 0;
2079:FreeRTOS/Source/tasks.c **** 		}
2080:FreeRTOS/Source/tasks.c **** 		else if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > 1 )
2081:FreeRTOS/Source/tasks.c **** 		{
2082:FreeRTOS/Source/tasks.c **** 			/* There are other idle priority tasks in the ready state.  If
2083:FreeRTOS/Source/tasks.c **** 			time slicing is used then the very next tick interrupt must be
2084:FreeRTOS/Source/tasks.c **** 			processed. */
2085:FreeRTOS/Source/tasks.c **** 			xReturn = 0;
2086:FreeRTOS/Source/tasks.c **** 		}
2087:FreeRTOS/Source/tasks.c **** 		else if( uxHigherPriorityReadyTasks != pdFALSE )
2088:FreeRTOS/Source/tasks.c **** 		{
2089:FreeRTOS/Source/tasks.c **** 			/* There are tasks in the Ready state that have a priority above the
2090:FreeRTOS/Source/tasks.c **** 			idle priority.  This path can only be reached if
2091:FreeRTOS/Source/tasks.c **** 			configUSE_PREEMPTION is 0. */
2092:FreeRTOS/Source/tasks.c **** 			xReturn = 0;
2093:FreeRTOS/Source/tasks.c **** 		}
2094:FreeRTOS/Source/tasks.c **** 		else
2095:FreeRTOS/Source/tasks.c **** 		{
2096:FreeRTOS/Source/tasks.c **** 			xReturn = xNextTaskUnblockTime - xTickCount;
2097:FreeRTOS/Source/tasks.c **** 		}
2098:FreeRTOS/Source/tasks.c **** 
2099:FreeRTOS/Source/tasks.c **** 		return xReturn;
2100:FreeRTOS/Source/tasks.c **** 	}
2101:FreeRTOS/Source/tasks.c **** 
2102:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
2103:FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
2104:FreeRTOS/Source/tasks.c **** 
2105:FreeRTOS/Source/tasks.c **** BaseType_t xTaskResumeAll( void )
2106:FreeRTOS/Source/tasks.c **** {
2107:FreeRTOS/Source/tasks.c **** TCB_t *pxTCB = NULL;
2108:FreeRTOS/Source/tasks.c **** BaseType_t xAlreadyYielded = pdFALSE;
2109:FreeRTOS/Source/tasks.c **** 
2110:FreeRTOS/Source/tasks.c **** 	/* If uxSchedulerSuspended is zero then this function does not match a
2111:FreeRTOS/Source/tasks.c **** 	previous call to vTaskSuspendAll(). */
2112:FreeRTOS/Source/tasks.c **** 	configASSERT( uxSchedulerSuspended );
2113:FreeRTOS/Source/tasks.c **** 
2114:FreeRTOS/Source/tasks.c **** 	/* It is possible that an ISR caused a task to be removed from an event
2115:FreeRTOS/Source/tasks.c **** 	list while the scheduler was suspended.  If this was the case then the
2116:FreeRTOS/Source/tasks.c **** 	removed task will have been added to the xPendingReadyList.  Once the
2117:FreeRTOS/Source/tasks.c **** 	scheduler has been resumed it is safe to move all the pending ready
2118:FreeRTOS/Source/tasks.c **** 	tasks from this list into their appropriate ready list. */
2119:FreeRTOS/Source/tasks.c **** 	taskENTER_CRITICAL();
2120:FreeRTOS/Source/tasks.c **** 	{
2121:FreeRTOS/Source/tasks.c **** 		--uxSchedulerSuspended;
2122:FreeRTOS/Source/tasks.c **** 
2123:FreeRTOS/Source/tasks.c **** 		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
2124:FreeRTOS/Source/tasks.c **** 		{
2125:FreeRTOS/Source/tasks.c **** 			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
2126:FreeRTOS/Source/tasks.c **** 			{
2127:FreeRTOS/Source/tasks.c **** 				/* Move any readied tasks from the pending list into the
2128:FreeRTOS/Source/tasks.c **** 				appropriate ready list. */
2129:FreeRTOS/Source/tasks.c **** 				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
2130:FreeRTOS/Source/tasks.c **** 				{
2131:FreeRTOS/Source/tasks.c **** 					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
2132:FreeRTOS/Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
2133:FreeRTOS/Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
2134:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
2135:FreeRTOS/Source/tasks.c **** 
2136:FreeRTOS/Source/tasks.c **** 					/* If the moved task has a priority higher than the current
2137:FreeRTOS/Source/tasks.c **** 					task then a yield must be performed. */
2138:FreeRTOS/Source/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
2139:FreeRTOS/Source/tasks.c **** 					{
2140:FreeRTOS/Source/tasks.c **** 						xYieldPending = pdTRUE;
2141:FreeRTOS/Source/tasks.c **** 					}
2142:FreeRTOS/Source/tasks.c **** 					else
2143:FreeRTOS/Source/tasks.c **** 					{
2144:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2145:FreeRTOS/Source/tasks.c **** 					}
2146:FreeRTOS/Source/tasks.c **** 				}
2147:FreeRTOS/Source/tasks.c **** 
2148:FreeRTOS/Source/tasks.c **** 				if( pxTCB != NULL )
2149:FreeRTOS/Source/tasks.c **** 				{
2150:FreeRTOS/Source/tasks.c **** 					/* A task was unblocked while the scheduler was suspended,
2151:FreeRTOS/Source/tasks.c **** 					which may have prevented the next unblock time from being
2152:FreeRTOS/Source/tasks.c **** 					re-calculated, in which case re-calculate it now.  Mainly
2153:FreeRTOS/Source/tasks.c **** 					important for low power tickless implementations, where
2154:FreeRTOS/Source/tasks.c **** 					this can prevent an unnecessary exit from low power
2155:FreeRTOS/Source/tasks.c **** 					state. */
2156:FreeRTOS/Source/tasks.c **** 					prvResetNextTaskUnblockTime();
2157:FreeRTOS/Source/tasks.c **** 				}
2158:FreeRTOS/Source/tasks.c **** 
2159:FreeRTOS/Source/tasks.c **** 				/* If any ticks occurred while the scheduler was suspended then
2160:FreeRTOS/Source/tasks.c **** 				they should be processed now.  This ensures the tick count does
2161:FreeRTOS/Source/tasks.c **** 				not	slip, and that any delayed tasks are resumed at the correct
2162:FreeRTOS/Source/tasks.c **** 				time. */
2163:FreeRTOS/Source/tasks.c **** 				{
2164:FreeRTOS/Source/tasks.c **** 					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
2165:FreeRTOS/Source/tasks.c **** 
2166:FreeRTOS/Source/tasks.c **** 					if( uxPendedCounts > ( UBaseType_t ) 0U )
2167:FreeRTOS/Source/tasks.c **** 					{
2168:FreeRTOS/Source/tasks.c **** 						do
2169:FreeRTOS/Source/tasks.c **** 						{
2170:FreeRTOS/Source/tasks.c **** 							if( xTaskIncrementTick() != pdFALSE )
2171:FreeRTOS/Source/tasks.c **** 							{
2172:FreeRTOS/Source/tasks.c **** 								xYieldPending = pdTRUE;
2173:FreeRTOS/Source/tasks.c **** 							}
2174:FreeRTOS/Source/tasks.c **** 							else
2175:FreeRTOS/Source/tasks.c **** 							{
2176:FreeRTOS/Source/tasks.c **** 								mtCOVERAGE_TEST_MARKER();
2177:FreeRTOS/Source/tasks.c **** 							}
2178:FreeRTOS/Source/tasks.c **** 							--uxPendedCounts;
2179:FreeRTOS/Source/tasks.c **** 						} while( uxPendedCounts > ( UBaseType_t ) 0U );
2180:FreeRTOS/Source/tasks.c **** 
2181:FreeRTOS/Source/tasks.c **** 						uxPendedTicks = 0;
2182:FreeRTOS/Source/tasks.c **** 					}
2183:FreeRTOS/Source/tasks.c **** 					else
2184:FreeRTOS/Source/tasks.c **** 					{
2185:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2186:FreeRTOS/Source/tasks.c **** 					}
2187:FreeRTOS/Source/tasks.c **** 				}
2188:FreeRTOS/Source/tasks.c **** 
2189:FreeRTOS/Source/tasks.c **** 				if( xYieldPending != pdFALSE )
2190:FreeRTOS/Source/tasks.c **** 				{
2191:FreeRTOS/Source/tasks.c **** 					#if( configUSE_PREEMPTION != 0 )
2192:FreeRTOS/Source/tasks.c **** 					{
2193:FreeRTOS/Source/tasks.c **** 						xAlreadyYielded = pdTRUE;
2194:FreeRTOS/Source/tasks.c **** 					}
2195:FreeRTOS/Source/tasks.c **** 					#endif
2196:FreeRTOS/Source/tasks.c **** 					taskYIELD_IF_USING_PREEMPTION();
2197:FreeRTOS/Source/tasks.c **** 				}
2198:FreeRTOS/Source/tasks.c **** 				else
2199:FreeRTOS/Source/tasks.c **** 				{
2200:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
2201:FreeRTOS/Source/tasks.c **** 				}
2202:FreeRTOS/Source/tasks.c **** 			}
2203:FreeRTOS/Source/tasks.c **** 		}
2204:FreeRTOS/Source/tasks.c **** 		else
2205:FreeRTOS/Source/tasks.c **** 		{
2206:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
2207:FreeRTOS/Source/tasks.c **** 		}
2208:FreeRTOS/Source/tasks.c **** 	}
2209:FreeRTOS/Source/tasks.c **** 	taskEXIT_CRITICAL();
2210:FreeRTOS/Source/tasks.c **** 
2211:FreeRTOS/Source/tasks.c **** 	return xAlreadyYielded;
2212:FreeRTOS/Source/tasks.c **** }
2213:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2214:FreeRTOS/Source/tasks.c **** 
2215:FreeRTOS/Source/tasks.c **** TickType_t xTaskGetTickCount( void )
2216:FreeRTOS/Source/tasks.c **** {
2217:FreeRTOS/Source/tasks.c **** TickType_t xTicks;
2218:FreeRTOS/Source/tasks.c **** 
2219:FreeRTOS/Source/tasks.c **** 	/* Critical section required if running on a 16 bit processor. */
2220:FreeRTOS/Source/tasks.c **** 	portTICK_TYPE_ENTER_CRITICAL();
2221:FreeRTOS/Source/tasks.c **** 	{
2222:FreeRTOS/Source/tasks.c **** 		xTicks = xTickCount;
2223:FreeRTOS/Source/tasks.c **** 	}
2224:FreeRTOS/Source/tasks.c **** 	portTICK_TYPE_EXIT_CRITICAL();
2225:FreeRTOS/Source/tasks.c **** 
2226:FreeRTOS/Source/tasks.c **** 	return xTicks;
2227:FreeRTOS/Source/tasks.c **** }
2228:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2229:FreeRTOS/Source/tasks.c **** 
2230:FreeRTOS/Source/tasks.c **** TickType_t xTaskGetTickCountFromISR( void )
2231:FreeRTOS/Source/tasks.c **** {
2232:FreeRTOS/Source/tasks.c **** TickType_t xReturn;
2233:FreeRTOS/Source/tasks.c **** UBaseType_t uxSavedInterruptStatus;
2234:FreeRTOS/Source/tasks.c **** 
2235:FreeRTOS/Source/tasks.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
2236:FreeRTOS/Source/tasks.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
2237:FreeRTOS/Source/tasks.c **** 	above the maximum system call priority are kept permanently enabled, even
2238:FreeRTOS/Source/tasks.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
2239:FreeRTOS/Source/tasks.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
2240:FreeRTOS/Source/tasks.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
2241:FreeRTOS/Source/tasks.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
2242:FreeRTOS/Source/tasks.c **** 	assigned a priority above the configured maximum system call priority.
2243:FreeRTOS/Source/tasks.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
2244:FreeRTOS/Source/tasks.c **** 	that have been assigned a priority at or (logically) below the maximum
2245:FreeRTOS/Source/tasks.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
2246:FreeRTOS/Source/tasks.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
2247:FreeRTOS/Source/tasks.c **** 	More information (albeit Cortex-M specific) is provided on the following
2248:FreeRTOS/Source/tasks.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
2249:FreeRTOS/Source/tasks.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
2250:FreeRTOS/Source/tasks.c **** 
2251:FreeRTOS/Source/tasks.c **** 	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
2252:FreeRTOS/Source/tasks.c **** 	{
2253:FreeRTOS/Source/tasks.c **** 		xReturn = xTickCount;
2254:FreeRTOS/Source/tasks.c **** 	}
2255:FreeRTOS/Source/tasks.c **** 	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
2256:FreeRTOS/Source/tasks.c **** 
2257:FreeRTOS/Source/tasks.c **** 	return xReturn;
2258:FreeRTOS/Source/tasks.c **** }
2259:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2260:FreeRTOS/Source/tasks.c **** 
2261:FreeRTOS/Source/tasks.c **** UBaseType_t uxTaskGetNumberOfTasks( void )
2262:FreeRTOS/Source/tasks.c **** {
2263:FreeRTOS/Source/tasks.c **** 	/* A critical section is not required because the variables are of type
2264:FreeRTOS/Source/tasks.c **** 	BaseType_t. */
2265:FreeRTOS/Source/tasks.c **** 	return uxCurrentNumberOfTasks;
2266:FreeRTOS/Source/tasks.c **** }
2267:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2268:FreeRTOS/Source/tasks.c **** 
2269:FreeRTOS/Source/tasks.c **** char *pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed fo
2270:FreeRTOS/Source/tasks.c **** {
2271:FreeRTOS/Source/tasks.c **** TCB_t *pxTCB;
2272:FreeRTOS/Source/tasks.c **** 
2273:FreeRTOS/Source/tasks.c **** 	/* If null is passed in here then the name of the calling task is being
2274:FreeRTOS/Source/tasks.c **** 	queried. */
2275:FreeRTOS/Source/tasks.c **** 	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
2276:FreeRTOS/Source/tasks.c **** 	configASSERT( pxTCB );
2277:FreeRTOS/Source/tasks.c **** 	return &( pxTCB->pcTaskName[ 0 ] );
2278:FreeRTOS/Source/tasks.c **** }
2279:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2280:FreeRTOS/Source/tasks.c **** 
2281:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_xTaskGetHandle == 1 )
2282:FreeRTOS/Source/tasks.c **** 
2283:FreeRTOS/Source/tasks.c **** 	static TCB_t *prvSearchForNameWithinSingleList( List_t *pxList, const char pcNameToQuery[] )
2284:FreeRTOS/Source/tasks.c **** 	{
2285:FreeRTOS/Source/tasks.c **** 	TCB_t *pxNextTCB, *pxFirstTCB, *pxReturn = NULL;
2286:FreeRTOS/Source/tasks.c **** 	UBaseType_t x;
2287:FreeRTOS/Source/tasks.c **** 	char cNextChar;
2288:FreeRTOS/Source/tasks.c **** 
2289:FreeRTOS/Source/tasks.c **** 		/* This function is called with the scheduler suspended. */
2290:FreeRTOS/Source/tasks.c **** 
2291:FreeRTOS/Source/tasks.c **** 		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
2292:FreeRTOS/Source/tasks.c **** 		{
2293:FreeRTOS/Source/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
2294:FreeRTOS/Source/tasks.c **** 
2295:FreeRTOS/Source/tasks.c **** 			do
2296:FreeRTOS/Source/tasks.c **** 			{
2297:FreeRTOS/Source/tasks.c **** 				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
2298:FreeRTOS/Source/tasks.c **** 
2299:FreeRTOS/Source/tasks.c **** 				/* Check each character in the name looking for a match or
2300:FreeRTOS/Source/tasks.c **** 				mismatch. */
2301:FreeRTOS/Source/tasks.c **** 				for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
2302:FreeRTOS/Source/tasks.c **** 				{
2303:FreeRTOS/Source/tasks.c **** 					cNextChar = pxNextTCB->pcTaskName[ x ];
2304:FreeRTOS/Source/tasks.c **** 
2305:FreeRTOS/Source/tasks.c **** 					if( cNextChar != pcNameToQuery[ x ] )
2306:FreeRTOS/Source/tasks.c **** 					{
2307:FreeRTOS/Source/tasks.c **** 						/* Characters didn't match. */
2308:FreeRTOS/Source/tasks.c **** 						break;
2309:FreeRTOS/Source/tasks.c **** 					}
2310:FreeRTOS/Source/tasks.c **** 					else if( cNextChar == 0x00 )
2311:FreeRTOS/Source/tasks.c **** 					{
2312:FreeRTOS/Source/tasks.c **** 						/* Both strings terminated, a match must have been
2313:FreeRTOS/Source/tasks.c **** 						found. */
2314:FreeRTOS/Source/tasks.c **** 						pxReturn = pxNextTCB;
2315:FreeRTOS/Source/tasks.c **** 						break;
2316:FreeRTOS/Source/tasks.c **** 					}
2317:FreeRTOS/Source/tasks.c **** 					else
2318:FreeRTOS/Source/tasks.c **** 					{
2319:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2320:FreeRTOS/Source/tasks.c **** 					}
2321:FreeRTOS/Source/tasks.c **** 				}
2322:FreeRTOS/Source/tasks.c **** 
2323:FreeRTOS/Source/tasks.c **** 				if( pxReturn != NULL )
2324:FreeRTOS/Source/tasks.c **** 				{
2325:FreeRTOS/Source/tasks.c **** 					/* The handle has been found. */
2326:FreeRTOS/Source/tasks.c **** 					break;
2327:FreeRTOS/Source/tasks.c **** 				}
2328:FreeRTOS/Source/tasks.c **** 
2329:FreeRTOS/Source/tasks.c **** 			} while( pxNextTCB != pxFirstTCB );
2330:FreeRTOS/Source/tasks.c **** 		}
2331:FreeRTOS/Source/tasks.c **** 		else
2332:FreeRTOS/Source/tasks.c **** 		{
2333:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
2334:FreeRTOS/Source/tasks.c **** 		}
2335:FreeRTOS/Source/tasks.c **** 
2336:FreeRTOS/Source/tasks.c **** 		return pxReturn;
2337:FreeRTOS/Source/tasks.c **** 	}
2338:FreeRTOS/Source/tasks.c **** 
2339:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_xTaskGetHandle */
2340:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2341:FreeRTOS/Source/tasks.c **** 
2342:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_xTaskGetHandle == 1 )
2343:FreeRTOS/Source/tasks.c **** 
2344:FreeRTOS/Source/tasks.c **** 	TaskHandle_t xTaskGetHandle( const char *pcNameToQuery ) /*lint !e971 Unqualified char types are a
2345:FreeRTOS/Source/tasks.c **** 	{
2346:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxQueue = configMAX_PRIORITIES;
2347:FreeRTOS/Source/tasks.c **** 	TCB_t* pxTCB;
2348:FreeRTOS/Source/tasks.c **** 
2349:FreeRTOS/Source/tasks.c **** 		/* Task names will be truncated to configMAX_TASK_NAME_LEN - 1 bytes. */
2350:FreeRTOS/Source/tasks.c **** 		configASSERT( strlen( pcNameToQuery ) < configMAX_TASK_NAME_LEN );
2351:FreeRTOS/Source/tasks.c **** 
2352:FreeRTOS/Source/tasks.c **** 		vTaskSuspendAll();
2353:FreeRTOS/Source/tasks.c **** 		{
2354:FreeRTOS/Source/tasks.c **** 			/* Search the ready lists. */
2355:FreeRTOS/Source/tasks.c **** 			do
2356:FreeRTOS/Source/tasks.c **** 			{
2357:FreeRTOS/Source/tasks.c **** 				uxQueue--;
2358:FreeRTOS/Source/tasks.c **** 				pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) &( pxReadyTasksLists[ uxQueue ] ), pcNam
2359:FreeRTOS/Source/tasks.c **** 
2360:FreeRTOS/Source/tasks.c **** 				if( pxTCB != NULL )
2361:FreeRTOS/Source/tasks.c **** 				{
2362:FreeRTOS/Source/tasks.c **** 					/* Found the handle. */
2363:FreeRTOS/Source/tasks.c **** 					break;
2364:FreeRTOS/Source/tasks.c **** 				}
2365:FreeRTOS/Source/tasks.c **** 
2366:FreeRTOS/Source/tasks.c **** 			} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the casts
2367:FreeRTOS/Source/tasks.c **** 
2368:FreeRTOS/Source/tasks.c **** 			/* Search the delayed lists. */
2369:FreeRTOS/Source/tasks.c **** 			if( pxTCB == NULL )
2370:FreeRTOS/Source/tasks.c **** 			{
2371:FreeRTOS/Source/tasks.c **** 				pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) pxDelayedTaskList, pcNameToQuery );
2372:FreeRTOS/Source/tasks.c **** 			}
2373:FreeRTOS/Source/tasks.c **** 
2374:FreeRTOS/Source/tasks.c **** 			if( pxTCB == NULL )
2375:FreeRTOS/Source/tasks.c **** 			{
2376:FreeRTOS/Source/tasks.c **** 				pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) pxOverflowDelayedTaskList, pcNameToQuery
2377:FreeRTOS/Source/tasks.c **** 			}
2378:FreeRTOS/Source/tasks.c **** 
2379:FreeRTOS/Source/tasks.c **** 			#if ( INCLUDE_vTaskSuspend == 1 )
2380:FreeRTOS/Source/tasks.c **** 			{
2381:FreeRTOS/Source/tasks.c **** 				if( pxTCB == NULL )
2382:FreeRTOS/Source/tasks.c **** 				{
2383:FreeRTOS/Source/tasks.c **** 					/* Search the suspended list. */
2384:FreeRTOS/Source/tasks.c **** 					pxTCB = prvSearchForNameWithinSingleList( &xSuspendedTaskList, pcNameToQuery );
2385:FreeRTOS/Source/tasks.c **** 				}
2386:FreeRTOS/Source/tasks.c **** 			}
2387:FreeRTOS/Source/tasks.c **** 			#endif
2388:FreeRTOS/Source/tasks.c **** 
2389:FreeRTOS/Source/tasks.c **** 			#if( INCLUDE_vTaskDelete == 1 )
2390:FreeRTOS/Source/tasks.c **** 			{
2391:FreeRTOS/Source/tasks.c **** 				if( pxTCB == NULL )
2392:FreeRTOS/Source/tasks.c **** 				{
2393:FreeRTOS/Source/tasks.c **** 					/* Search the deleted list. */
2394:FreeRTOS/Source/tasks.c **** 					pxTCB = prvSearchForNameWithinSingleList( &xTasksWaitingTermination, pcNameToQuery );
2395:FreeRTOS/Source/tasks.c **** 				}
2396:FreeRTOS/Source/tasks.c **** 			}
2397:FreeRTOS/Source/tasks.c **** 			#endif
2398:FreeRTOS/Source/tasks.c **** 		}
2399:FreeRTOS/Source/tasks.c **** 		( void ) xTaskResumeAll();
2400:FreeRTOS/Source/tasks.c **** 
2401:FreeRTOS/Source/tasks.c **** 		return ( TaskHandle_t ) pxTCB;
2402:FreeRTOS/Source/tasks.c **** 	}
2403:FreeRTOS/Source/tasks.c **** 
2404:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_xTaskGetHandle */
2405:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2406:FreeRTOS/Source/tasks.c **** 
2407:FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2408:FreeRTOS/Source/tasks.c **** 
2409:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArra
2410:FreeRTOS/Source/tasks.c **** 	{
2411:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxTask = 0, uxQueue = configMAX_PRIORITIES;
2412:FreeRTOS/Source/tasks.c **** 
2413:FreeRTOS/Source/tasks.c **** 		vTaskSuspendAll();
2414:FreeRTOS/Source/tasks.c **** 		{
2415:FreeRTOS/Source/tasks.c **** 			/* Is there a space in the array for each task in the system? */
2416:FreeRTOS/Source/tasks.c **** 			if( uxArraySize >= uxCurrentNumberOfTasks )
2417:FreeRTOS/Source/tasks.c **** 			{
2418:FreeRTOS/Source/tasks.c **** 				/* Fill in an TaskStatus_t structure with information on each
2419:FreeRTOS/Source/tasks.c **** 				task in the Ready state. */
2420:FreeRTOS/Source/tasks.c **** 				do
2421:FreeRTOS/Source/tasks.c **** 				{
2422:FreeRTOS/Source/tasks.c **** 					uxQueue--;
2423:FreeRTOS/Source/tasks.c **** 					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &( pxReadyTasksLists
2424:FreeRTOS/Source/tasks.c **** 
2425:FreeRTOS/Source/tasks.c **** 				} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the cast
2426:FreeRTOS/Source/tasks.c **** 
2427:FreeRTOS/Source/tasks.c **** 				/* Fill in an TaskStatus_t structure with information on each
2428:FreeRTOS/Source/tasks.c **** 				task in the Blocked state. */
2429:FreeRTOS/Source/tasks.c **** 				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxDelaye
2430:FreeRTOS/Source/tasks.c **** 				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxOverfl
2431:FreeRTOS/Source/tasks.c **** 
2432:FreeRTOS/Source/tasks.c **** 				#if( INCLUDE_vTaskDelete == 1 )
2433:FreeRTOS/Source/tasks.c **** 				{
2434:FreeRTOS/Source/tasks.c **** 					/* Fill in an TaskStatus_t structure with information on
2435:FreeRTOS/Source/tasks.c **** 					each task that has been deleted but not yet cleaned up. */
2436:FreeRTOS/Source/tasks.c **** 					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xTasksWaitingTermin
2437:FreeRTOS/Source/tasks.c **** 				}
2438:FreeRTOS/Source/tasks.c **** 				#endif
2439:FreeRTOS/Source/tasks.c **** 
2440:FreeRTOS/Source/tasks.c **** 				#if ( INCLUDE_vTaskSuspend == 1 )
2441:FreeRTOS/Source/tasks.c **** 				{
2442:FreeRTOS/Source/tasks.c **** 					/* Fill in an TaskStatus_t structure with information on
2443:FreeRTOS/Source/tasks.c **** 					each task in the Suspended state. */
2444:FreeRTOS/Source/tasks.c **** 					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xSuspendedTaskList,
2445:FreeRTOS/Source/tasks.c **** 				}
2446:FreeRTOS/Source/tasks.c **** 				#endif
2447:FreeRTOS/Source/tasks.c **** 
2448:FreeRTOS/Source/tasks.c **** 				#if ( configGENERATE_RUN_TIME_STATS == 1)
2449:FreeRTOS/Source/tasks.c **** 				{
2450:FreeRTOS/Source/tasks.c **** 					if( pulTotalRunTime != NULL )
2451:FreeRTOS/Source/tasks.c **** 					{
2452:FreeRTOS/Source/tasks.c **** 						#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
2453:FreeRTOS/Source/tasks.c **** 							portALT_GET_RUN_TIME_COUNTER_VALUE( ( *pulTotalRunTime ) );
2454:FreeRTOS/Source/tasks.c **** 						#else
2455:FreeRTOS/Source/tasks.c **** 							*pulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
2456:FreeRTOS/Source/tasks.c **** 						#endif
2457:FreeRTOS/Source/tasks.c **** 					}
2458:FreeRTOS/Source/tasks.c **** 				}
2459:FreeRTOS/Source/tasks.c **** 				#else
2460:FreeRTOS/Source/tasks.c **** 				{
2461:FreeRTOS/Source/tasks.c **** 					if( pulTotalRunTime != NULL )
2462:FreeRTOS/Source/tasks.c **** 					{
2463:FreeRTOS/Source/tasks.c **** 						*pulTotalRunTime = 0;
2464:FreeRTOS/Source/tasks.c **** 					}
2465:FreeRTOS/Source/tasks.c **** 				}
2466:FreeRTOS/Source/tasks.c **** 				#endif
2467:FreeRTOS/Source/tasks.c **** 			}
2468:FreeRTOS/Source/tasks.c **** 			else
2469:FreeRTOS/Source/tasks.c **** 			{
2470:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
2471:FreeRTOS/Source/tasks.c **** 			}
2472:FreeRTOS/Source/tasks.c **** 		}
2473:FreeRTOS/Source/tasks.c **** 		( void ) xTaskResumeAll();
2474:FreeRTOS/Source/tasks.c **** 
2475:FreeRTOS/Source/tasks.c **** 		return uxTask;
2476:FreeRTOS/Source/tasks.c **** 	}
2477:FreeRTOS/Source/tasks.c **** 
2478:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
2479:FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
2480:FreeRTOS/Source/tasks.c **** 
2481:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
2482:FreeRTOS/Source/tasks.c **** 
2483:FreeRTOS/Source/tasks.c **** 	TaskHandle_t xTaskGetIdleTaskHandle( void )
2484:FreeRTOS/Source/tasks.c **** 	{
2485:FreeRTOS/Source/tasks.c **** 		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
2486:FreeRTOS/Source/tasks.c **** 		started, then xIdleTaskHandle will be NULL. */
2487:FreeRTOS/Source/tasks.c **** 		configASSERT( ( xIdleTaskHandle != NULL ) );
2488:FreeRTOS/Source/tasks.c **** 		return xIdleTaskHandle;
2489:FreeRTOS/Source/tasks.c **** 	}
2490:FreeRTOS/Source/tasks.c **** 
2491:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_xTaskGetIdleTaskHandle */
2492:FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
2493:FreeRTOS/Source/tasks.c **** 
2494:FreeRTOS/Source/tasks.c **** /* This conditional compilation should use inequality to 0, not equality to 1.
2495:FreeRTOS/Source/tasks.c **** This is to ensure vTaskStepTick() is available when user defined low power mode
2496:FreeRTOS/Source/tasks.c **** implementations require configUSE_TICKLESS_IDLE to be set to a value other than
2497:FreeRTOS/Source/tasks.c **** 1. */
2498:FreeRTOS/Source/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
2499:FreeRTOS/Source/tasks.c **** 
2500:FreeRTOS/Source/tasks.c **** 	void vTaskStepTick( const TickType_t xTicksToJump )
2501:FreeRTOS/Source/tasks.c **** 	{
2502:FreeRTOS/Source/tasks.c **** 		/* Correct the tick count value after a period during which the tick
2503:FreeRTOS/Source/tasks.c **** 		was suppressed.  Note this does *not* call the tick hook function for
2504:FreeRTOS/Source/tasks.c **** 		each stepped tick. */
2505:FreeRTOS/Source/tasks.c **** 		configASSERT( ( xTickCount + xTicksToJump ) <= xNextTaskUnblockTime );
2506:FreeRTOS/Source/tasks.c **** 		xTickCount += xTicksToJump;
2507:FreeRTOS/Source/tasks.c **** 		traceINCREASE_TICK_COUNT( xTicksToJump );
2508:FreeRTOS/Source/tasks.c **** 	}
2509:FreeRTOS/Source/tasks.c **** 
2510:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
2511:FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
2512:FreeRTOS/Source/tasks.c **** 
2513:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_xTaskAbortDelay == 1 )
2514:FreeRTOS/Source/tasks.c **** 
2515:FreeRTOS/Source/tasks.c **** 	BaseType_t xTaskAbortDelay( TaskHandle_t xTask )
2516:FreeRTOS/Source/tasks.c **** 	{
2517:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB = ( TCB_t * ) xTask;
2518:FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn;
2519:FreeRTOS/Source/tasks.c **** 
2520:FreeRTOS/Source/tasks.c **** 		configASSERT( pxTCB );
2521:FreeRTOS/Source/tasks.c **** 
2522:FreeRTOS/Source/tasks.c **** 		vTaskSuspendAll();
2523:FreeRTOS/Source/tasks.c **** 		{
2524:FreeRTOS/Source/tasks.c **** 			/* A task can only be prematurely removed from the Blocked state if
2525:FreeRTOS/Source/tasks.c **** 			it is actually in the Blocked state. */
2526:FreeRTOS/Source/tasks.c **** 			if( eTaskGetState( xTask ) == eBlocked )
2527:FreeRTOS/Source/tasks.c **** 			{
2528:FreeRTOS/Source/tasks.c **** 				xReturn = pdPASS;
2529:FreeRTOS/Source/tasks.c **** 
2530:FreeRTOS/Source/tasks.c **** 				/* Remove the reference to the task from the blocked list.  An
2531:FreeRTOS/Source/tasks.c **** 				interrupt won't touch the xStateListItem because the
2532:FreeRTOS/Source/tasks.c **** 				scheduler is suspended. */
2533:FreeRTOS/Source/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
2534:FreeRTOS/Source/tasks.c **** 
2535:FreeRTOS/Source/tasks.c **** 				/* Is the task waiting on an event also?  If so remove it from
2536:FreeRTOS/Source/tasks.c **** 				the event list too.  Interrupts can touch the event list item,
2537:FreeRTOS/Source/tasks.c **** 				even though the scheduler is suspended, so a critical section
2538:FreeRTOS/Source/tasks.c **** 				is used. */
2539:FreeRTOS/Source/tasks.c **** 				taskENTER_CRITICAL();
2540:FreeRTOS/Source/tasks.c **** 				{
2541:FreeRTOS/Source/tasks.c **** 					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
2542:FreeRTOS/Source/tasks.c **** 					{
2543:FreeRTOS/Source/tasks.c **** 						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
2544:FreeRTOS/Source/tasks.c **** 						pxTCB->ucDelayAborted = pdTRUE;
2545:FreeRTOS/Source/tasks.c **** 					}
2546:FreeRTOS/Source/tasks.c **** 					else
2547:FreeRTOS/Source/tasks.c **** 					{
2548:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2549:FreeRTOS/Source/tasks.c **** 					}
2550:FreeRTOS/Source/tasks.c **** 				}
2551:FreeRTOS/Source/tasks.c **** 				taskEXIT_CRITICAL();
2552:FreeRTOS/Source/tasks.c **** 
2553:FreeRTOS/Source/tasks.c **** 				/* Place the unblocked task into the appropriate ready list. */
2554:FreeRTOS/Source/tasks.c **** 				prvAddTaskToReadyList( pxTCB );
2555:FreeRTOS/Source/tasks.c **** 
2556:FreeRTOS/Source/tasks.c **** 				/* A task being unblocked cannot cause an immediate context
2557:FreeRTOS/Source/tasks.c **** 				switch if preemption is turned off. */
2558:FreeRTOS/Source/tasks.c **** 				#if (  configUSE_PREEMPTION == 1 )
2559:FreeRTOS/Source/tasks.c **** 				{
2560:FreeRTOS/Source/tasks.c **** 					/* Preemption is on, but a context switch should only be
2561:FreeRTOS/Source/tasks.c **** 					performed if the unblocked task has a priority that is
2562:FreeRTOS/Source/tasks.c **** 					equal to or higher than the currently executing task. */
2563:FreeRTOS/Source/tasks.c **** 					if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
2564:FreeRTOS/Source/tasks.c **** 					{
2565:FreeRTOS/Source/tasks.c **** 						/* Pend the yield to be performed when the scheduler
2566:FreeRTOS/Source/tasks.c **** 						is unsuspended. */
2567:FreeRTOS/Source/tasks.c **** 						xYieldPending = pdTRUE;
2568:FreeRTOS/Source/tasks.c **** 					}
2569:FreeRTOS/Source/tasks.c **** 					else
2570:FreeRTOS/Source/tasks.c **** 					{
2571:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2572:FreeRTOS/Source/tasks.c **** 					}
2573:FreeRTOS/Source/tasks.c **** 				}
2574:FreeRTOS/Source/tasks.c **** 				#endif /* configUSE_PREEMPTION */
2575:FreeRTOS/Source/tasks.c **** 			}
2576:FreeRTOS/Source/tasks.c **** 			else
2577:FreeRTOS/Source/tasks.c **** 			{
2578:FreeRTOS/Source/tasks.c **** 				xReturn = pdFAIL;
2579:FreeRTOS/Source/tasks.c **** 			}
2580:FreeRTOS/Source/tasks.c **** 		}
2581:FreeRTOS/Source/tasks.c **** 		( void ) xTaskResumeAll();
2582:FreeRTOS/Source/tasks.c **** 
2583:FreeRTOS/Source/tasks.c **** 		return xReturn;
2584:FreeRTOS/Source/tasks.c **** 	}
2585:FreeRTOS/Source/tasks.c **** 
2586:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_xTaskAbortDelay */
2587:FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
2588:FreeRTOS/Source/tasks.c **** 
2589:FreeRTOS/Source/tasks.c **** BaseType_t xTaskIncrementTick( void )
2590:FreeRTOS/Source/tasks.c **** {
2591:FreeRTOS/Source/tasks.c **** TCB_t * pxTCB;
2592:FreeRTOS/Source/tasks.c **** TickType_t xItemValue;
2593:FreeRTOS/Source/tasks.c **** BaseType_t xSwitchRequired = pdFALSE;
2594:FreeRTOS/Source/tasks.c **** 
2595:FreeRTOS/Source/tasks.c **** 	/* Called by the portable layer each time a tick interrupt occurs.
2596:FreeRTOS/Source/tasks.c **** 	Increments the tick then checks to see if the new tick value will cause any
2597:FreeRTOS/Source/tasks.c **** 	tasks to be unblocked. */
2598:FreeRTOS/Source/tasks.c **** 	traceTASK_INCREMENT_TICK( xTickCount );
2599:FreeRTOS/Source/tasks.c **** 	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
2600:FreeRTOS/Source/tasks.c **** 	{
2601:FreeRTOS/Source/tasks.c **** 		/* Minor optimisation.  The tick count cannot change in this
2602:FreeRTOS/Source/tasks.c **** 		block. */
2603:FreeRTOS/Source/tasks.c **** 		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
2604:FreeRTOS/Source/tasks.c **** 
2605:FreeRTOS/Source/tasks.c **** 		/* Increment the RTOS tick, switching the delayed and overflowed
2606:FreeRTOS/Source/tasks.c **** 		delayed lists if it wraps to 0. */
2607:FreeRTOS/Source/tasks.c **** 		xTickCount = xConstTickCount;
2608:FreeRTOS/Source/tasks.c **** 
2609:FreeRTOS/Source/tasks.c **** 		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as
2610:FreeRTOS/Source/tasks.c **** 		{
2611:FreeRTOS/Source/tasks.c **** 			taskSWITCH_DELAYED_LISTS();
2612:FreeRTOS/Source/tasks.c **** 		}
2613:FreeRTOS/Source/tasks.c **** 		else
2614:FreeRTOS/Source/tasks.c **** 		{
2615:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
2616:FreeRTOS/Source/tasks.c **** 		}
2617:FreeRTOS/Source/tasks.c **** 
2618:FreeRTOS/Source/tasks.c **** 		/* See if this tick has made a timeout expire.  Tasks are stored in
2619:FreeRTOS/Source/tasks.c **** 		the	queue in the order of their wake time - meaning once one task
2620:FreeRTOS/Source/tasks.c **** 		has been found whose block time has not expired there is no need to
2621:FreeRTOS/Source/tasks.c **** 		look any further down the list. */
2622:FreeRTOS/Source/tasks.c **** 		if( xConstTickCount >= xNextTaskUnblockTime )
2623:FreeRTOS/Source/tasks.c **** 		{
2624:FreeRTOS/Source/tasks.c **** 			for( ;; )
2625:FreeRTOS/Source/tasks.c **** 			{
2626:FreeRTOS/Source/tasks.c **** 				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
2627:FreeRTOS/Source/tasks.c **** 				{
2628:FreeRTOS/Source/tasks.c **** 					/* The delayed list is empty.  Set xNextTaskUnblockTime
2629:FreeRTOS/Source/tasks.c **** 					to the maximum possible value so it is extremely
2630:FreeRTOS/Source/tasks.c **** 					unlikely that the
2631:FreeRTOS/Source/tasks.c **** 					if( xTickCount >= xNextTaskUnblockTime ) test will pass
2632:FreeRTOS/Source/tasks.c **** 					next time through. */
2633:FreeRTOS/Source/tasks.c **** 					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redun
2634:FreeRTOS/Source/tasks.c **** 					break;
2635:FreeRTOS/Source/tasks.c **** 				}
2636:FreeRTOS/Source/tasks.c **** 				else
2637:FreeRTOS/Source/tasks.c **** 				{
2638:FreeRTOS/Source/tasks.c **** 					/* The delayed list is not empty, get the value of the
2639:FreeRTOS/Source/tasks.c **** 					item at the head of the delayed list.  This is the time
2640:FreeRTOS/Source/tasks.c **** 					at which the task at the head of the delayed list must
2641:FreeRTOS/Source/tasks.c **** 					be removed from the Blocked state. */
2642:FreeRTOS/Source/tasks.c **** 					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
2643:FreeRTOS/Source/tasks.c **** 					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
2644:FreeRTOS/Source/tasks.c **** 
2645:FreeRTOS/Source/tasks.c **** 					if( xConstTickCount < xItemValue )
2646:FreeRTOS/Source/tasks.c **** 					{
2647:FreeRTOS/Source/tasks.c **** 						/* It is not time to unblock this item yet, but the
2648:FreeRTOS/Source/tasks.c **** 						item value is the time at which the task at the head
2649:FreeRTOS/Source/tasks.c **** 						of the blocked list must be removed from the Blocked
2650:FreeRTOS/Source/tasks.c **** 						state -	so record the item value in
2651:FreeRTOS/Source/tasks.c **** 						xNextTaskUnblockTime. */
2652:FreeRTOS/Source/tasks.c **** 						xNextTaskUnblockTime = xItemValue;
2653:FreeRTOS/Source/tasks.c **** 						break;
2654:FreeRTOS/Source/tasks.c **** 					}
2655:FreeRTOS/Source/tasks.c **** 					else
2656:FreeRTOS/Source/tasks.c **** 					{
2657:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2658:FreeRTOS/Source/tasks.c **** 					}
2659:FreeRTOS/Source/tasks.c **** 
2660:FreeRTOS/Source/tasks.c **** 					/* It is time to remove the item from the Blocked state. */
2661:FreeRTOS/Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
2662:FreeRTOS/Source/tasks.c **** 
2663:FreeRTOS/Source/tasks.c **** 					/* Is the task waiting on an event also?  If so remove
2664:FreeRTOS/Source/tasks.c **** 					it from the event list. */
2665:FreeRTOS/Source/tasks.c **** 					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
2666:FreeRTOS/Source/tasks.c **** 					{
2667:FreeRTOS/Source/tasks.c **** 						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
2668:FreeRTOS/Source/tasks.c **** 					}
2669:FreeRTOS/Source/tasks.c **** 					else
2670:FreeRTOS/Source/tasks.c **** 					{
2671:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2672:FreeRTOS/Source/tasks.c **** 					}
2673:FreeRTOS/Source/tasks.c **** 
2674:FreeRTOS/Source/tasks.c **** 					/* Place the unblocked task into the appropriate ready
2675:FreeRTOS/Source/tasks.c **** 					list. */
2676:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
2677:FreeRTOS/Source/tasks.c **** 
2678:FreeRTOS/Source/tasks.c **** 					/* A task being unblocked cannot cause an immediate
2679:FreeRTOS/Source/tasks.c **** 					context switch if preemption is turned off. */
2680:FreeRTOS/Source/tasks.c **** 					#if (  configUSE_PREEMPTION == 1 )
2681:FreeRTOS/Source/tasks.c **** 					{
2682:FreeRTOS/Source/tasks.c **** 						/* Preemption is on, but a context switch should
2683:FreeRTOS/Source/tasks.c **** 						only be performed if the unblocked task has a
2684:FreeRTOS/Source/tasks.c **** 						priority that is equal to or higher than the
2685:FreeRTOS/Source/tasks.c **** 						currently executing task. */
2686:FreeRTOS/Source/tasks.c **** 						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
2687:FreeRTOS/Source/tasks.c **** 						{
2688:FreeRTOS/Source/tasks.c **** 							xSwitchRequired = pdTRUE;
2689:FreeRTOS/Source/tasks.c **** 						}
2690:FreeRTOS/Source/tasks.c **** 						else
2691:FreeRTOS/Source/tasks.c **** 						{
2692:FreeRTOS/Source/tasks.c **** 							mtCOVERAGE_TEST_MARKER();
2693:FreeRTOS/Source/tasks.c **** 						}
2694:FreeRTOS/Source/tasks.c **** 					}
2695:FreeRTOS/Source/tasks.c **** 					#endif /* configUSE_PREEMPTION */
2696:FreeRTOS/Source/tasks.c **** 				}
2697:FreeRTOS/Source/tasks.c **** 			}
2698:FreeRTOS/Source/tasks.c **** 		}
2699:FreeRTOS/Source/tasks.c **** 
2700:FreeRTOS/Source/tasks.c **** 		/* Tasks of equal priority to the currently running task will share
2701:FreeRTOS/Source/tasks.c **** 		processing time (time slice) if preemption is on, and the application
2702:FreeRTOS/Source/tasks.c **** 		writer has not explicitly turned time slicing off. */
2703:FreeRTOS/Source/tasks.c **** 		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
2704:FreeRTOS/Source/tasks.c **** 		{
2705:FreeRTOS/Source/tasks.c **** 			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_
2706:FreeRTOS/Source/tasks.c **** 			{
2707:FreeRTOS/Source/tasks.c **** 				xSwitchRequired = pdTRUE;
2708:FreeRTOS/Source/tasks.c **** 			}
2709:FreeRTOS/Source/tasks.c **** 			else
2710:FreeRTOS/Source/tasks.c **** 			{
2711:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
2712:FreeRTOS/Source/tasks.c **** 			}
2713:FreeRTOS/Source/tasks.c **** 		}
2714:FreeRTOS/Source/tasks.c **** 		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) ) */
2715:FreeRTOS/Source/tasks.c **** 
2716:FreeRTOS/Source/tasks.c **** 		#if ( configUSE_TICK_HOOK == 1 )
2717:FreeRTOS/Source/tasks.c **** 		{
2718:FreeRTOS/Source/tasks.c **** 			/* Guard against the tick hook being called when the pended tick
2719:FreeRTOS/Source/tasks.c **** 			count is being unwound (when the scheduler is being unlocked). */
2720:FreeRTOS/Source/tasks.c **** 			if( uxPendedTicks == ( UBaseType_t ) 0U )
2721:FreeRTOS/Source/tasks.c **** 			{
2722:FreeRTOS/Source/tasks.c **** 				vApplicationTickHook();
2723:FreeRTOS/Source/tasks.c **** 			}
2724:FreeRTOS/Source/tasks.c **** 			else
2725:FreeRTOS/Source/tasks.c **** 			{
2726:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
2727:FreeRTOS/Source/tasks.c **** 			}
2728:FreeRTOS/Source/tasks.c **** 		}
2729:FreeRTOS/Source/tasks.c **** 		#endif /* configUSE_TICK_HOOK */
2730:FreeRTOS/Source/tasks.c **** 	}
2731:FreeRTOS/Source/tasks.c **** 	else
2732:FreeRTOS/Source/tasks.c **** 	{
2733:FreeRTOS/Source/tasks.c **** 		++uxPendedTicks;
2734:FreeRTOS/Source/tasks.c **** 
2735:FreeRTOS/Source/tasks.c **** 		/* The tick hook gets called at regular intervals, even if the
2736:FreeRTOS/Source/tasks.c **** 		scheduler is locked. */
2737:FreeRTOS/Source/tasks.c **** 		#if ( configUSE_TICK_HOOK == 1 )
2738:FreeRTOS/Source/tasks.c **** 		{
2739:FreeRTOS/Source/tasks.c **** 			vApplicationTickHook();
2740:FreeRTOS/Source/tasks.c **** 		}
2741:FreeRTOS/Source/tasks.c **** 		#endif
2742:FreeRTOS/Source/tasks.c **** 	}
2743:FreeRTOS/Source/tasks.c **** 
2744:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_PREEMPTION == 1 )
2745:FreeRTOS/Source/tasks.c **** 	{
2746:FreeRTOS/Source/tasks.c **** 		if( xYieldPending != pdFALSE )
2747:FreeRTOS/Source/tasks.c **** 		{
2748:FreeRTOS/Source/tasks.c **** 			xSwitchRequired = pdTRUE;
2749:FreeRTOS/Source/tasks.c **** 		}
2750:FreeRTOS/Source/tasks.c **** 		else
2751:FreeRTOS/Source/tasks.c **** 		{
2752:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
2753:FreeRTOS/Source/tasks.c **** 		}
2754:FreeRTOS/Source/tasks.c **** 	}
2755:FreeRTOS/Source/tasks.c **** 	#endif /* configUSE_PREEMPTION */
2756:FreeRTOS/Source/tasks.c **** 
2757:FreeRTOS/Source/tasks.c **** 	return xSwitchRequired;
2758:FreeRTOS/Source/tasks.c **** }
2759:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2760:FreeRTOS/Source/tasks.c **** 
2761:FreeRTOS/Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2762:FreeRTOS/Source/tasks.c **** 
2763:FreeRTOS/Source/tasks.c **** 	void vTaskSetApplicationTaskTag( TaskHandle_t xTask, TaskHookFunction_t pxHookFunction )
2764:FreeRTOS/Source/tasks.c **** 	{
2765:FreeRTOS/Source/tasks.c **** 	TCB_t *xTCB;
2766:FreeRTOS/Source/tasks.c **** 
2767:FreeRTOS/Source/tasks.c **** 		/* If xTask is NULL then it is the task hook of the calling task that is
2768:FreeRTOS/Source/tasks.c **** 		getting set. */
2769:FreeRTOS/Source/tasks.c **** 		if( xTask == NULL )
2770:FreeRTOS/Source/tasks.c **** 		{
2771:FreeRTOS/Source/tasks.c **** 			xTCB = ( TCB_t * ) pxCurrentTCB;
2772:FreeRTOS/Source/tasks.c **** 		}
2773:FreeRTOS/Source/tasks.c **** 		else
2774:FreeRTOS/Source/tasks.c **** 		{
2775:FreeRTOS/Source/tasks.c **** 			xTCB = ( TCB_t * ) xTask;
2776:FreeRTOS/Source/tasks.c **** 		}
2777:FreeRTOS/Source/tasks.c **** 
2778:FreeRTOS/Source/tasks.c **** 		/* Save the hook function in the TCB.  A critical section is required as
2779:FreeRTOS/Source/tasks.c **** 		the value can be accessed from an interrupt. */
2780:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
2781:FreeRTOS/Source/tasks.c **** 			xTCB->pxTaskTag = pxHookFunction;
2782:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
2783:FreeRTOS/Source/tasks.c **** 	}
2784:FreeRTOS/Source/tasks.c **** 
2785:FreeRTOS/Source/tasks.c **** #endif /* configUSE_APPLICATION_TASK_TAG */
2786:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2787:FreeRTOS/Source/tasks.c **** 
2788:FreeRTOS/Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2789:FreeRTOS/Source/tasks.c **** 
2790:FreeRTOS/Source/tasks.c **** 	TaskHookFunction_t xTaskGetApplicationTaskTag( TaskHandle_t xTask )
2791:FreeRTOS/Source/tasks.c **** 	{
2792:FreeRTOS/Source/tasks.c **** 	TCB_t *xTCB;
2793:FreeRTOS/Source/tasks.c **** 	TaskHookFunction_t xReturn;
2794:FreeRTOS/Source/tasks.c **** 
2795:FreeRTOS/Source/tasks.c **** 		/* If xTask is NULL then we are setting our own task hook. */
2796:FreeRTOS/Source/tasks.c **** 		if( xTask == NULL )
2797:FreeRTOS/Source/tasks.c **** 		{
2798:FreeRTOS/Source/tasks.c **** 			xTCB = ( TCB_t * ) pxCurrentTCB;
2799:FreeRTOS/Source/tasks.c **** 		}
2800:FreeRTOS/Source/tasks.c **** 		else
2801:FreeRTOS/Source/tasks.c **** 		{
2802:FreeRTOS/Source/tasks.c **** 			xTCB = ( TCB_t * ) xTask;
2803:FreeRTOS/Source/tasks.c **** 		}
2804:FreeRTOS/Source/tasks.c **** 
2805:FreeRTOS/Source/tasks.c **** 		/* Save the hook function in the TCB.  A critical section is required as
2806:FreeRTOS/Source/tasks.c **** 		the value can be accessed from an interrupt. */
2807:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
2808:FreeRTOS/Source/tasks.c **** 		{
2809:FreeRTOS/Source/tasks.c **** 			xReturn = xTCB->pxTaskTag;
2810:FreeRTOS/Source/tasks.c **** 		}
2811:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
2812:FreeRTOS/Source/tasks.c **** 
2813:FreeRTOS/Source/tasks.c **** 		return xReturn;
2814:FreeRTOS/Source/tasks.c **** 	}
2815:FreeRTOS/Source/tasks.c **** 
2816:FreeRTOS/Source/tasks.c **** #endif /* configUSE_APPLICATION_TASK_TAG */
2817:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2818:FreeRTOS/Source/tasks.c **** 
2819:FreeRTOS/Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2820:FreeRTOS/Source/tasks.c **** 
2821:FreeRTOS/Source/tasks.c **** 	BaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter )
2822:FreeRTOS/Source/tasks.c **** 	{
2823:FreeRTOS/Source/tasks.c **** 	TCB_t *xTCB;
2824:FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn;
2825:FreeRTOS/Source/tasks.c **** 
2826:FreeRTOS/Source/tasks.c **** 		/* If xTask is NULL then we are calling our own task hook. */
2827:FreeRTOS/Source/tasks.c **** 		if( xTask == NULL )
2828:FreeRTOS/Source/tasks.c **** 		{
2829:FreeRTOS/Source/tasks.c **** 			xTCB = ( TCB_t * ) pxCurrentTCB;
2830:FreeRTOS/Source/tasks.c **** 		}
2831:FreeRTOS/Source/tasks.c **** 		else
2832:FreeRTOS/Source/tasks.c **** 		{
2833:FreeRTOS/Source/tasks.c **** 			xTCB = ( TCB_t * ) xTask;
2834:FreeRTOS/Source/tasks.c **** 		}
2835:FreeRTOS/Source/tasks.c **** 
2836:FreeRTOS/Source/tasks.c **** 		if( xTCB->pxTaskTag != NULL )
2837:FreeRTOS/Source/tasks.c **** 		{
2838:FreeRTOS/Source/tasks.c **** 			xReturn = xTCB->pxTaskTag( pvParameter );
2839:FreeRTOS/Source/tasks.c **** 		}
2840:FreeRTOS/Source/tasks.c **** 		else
2841:FreeRTOS/Source/tasks.c **** 		{
2842:FreeRTOS/Source/tasks.c **** 			xReturn = pdFAIL;
2843:FreeRTOS/Source/tasks.c **** 		}
2844:FreeRTOS/Source/tasks.c **** 
2845:FreeRTOS/Source/tasks.c **** 		return xReturn;
2846:FreeRTOS/Source/tasks.c **** 	}
2847:FreeRTOS/Source/tasks.c **** 
2848:FreeRTOS/Source/tasks.c **** #endif /* configUSE_APPLICATION_TASK_TAG */
2849:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2850:FreeRTOS/Source/tasks.c **** 
2851:FreeRTOS/Source/tasks.c **** void vTaskSwitchContext( void )
2852:FreeRTOS/Source/tasks.c **** {
2853:FreeRTOS/Source/tasks.c **** 	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
2854:FreeRTOS/Source/tasks.c **** 	{
2855:FreeRTOS/Source/tasks.c **** 		/* The scheduler is currently suspended - do not allow a context
2856:FreeRTOS/Source/tasks.c **** 		switch. */
2857:FreeRTOS/Source/tasks.c **** 		xYieldPending = pdTRUE;
2858:FreeRTOS/Source/tasks.c **** 	}
2859:FreeRTOS/Source/tasks.c **** 	else
2860:FreeRTOS/Source/tasks.c **** 	{
2861:FreeRTOS/Source/tasks.c **** 		xYieldPending = pdFALSE;
2862:FreeRTOS/Source/tasks.c **** 		traceTASK_SWITCHED_OUT();
2863:FreeRTOS/Source/tasks.c **** 
2864:FreeRTOS/Source/tasks.c **** 		#if ( configGENERATE_RUN_TIME_STATS == 1 )
2865:FreeRTOS/Source/tasks.c **** 		{
2866:FreeRTOS/Source/tasks.c **** 				#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
2867:FreeRTOS/Source/tasks.c **** 					portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
2868:FreeRTOS/Source/tasks.c **** 				#else
2869:FreeRTOS/Source/tasks.c **** 					ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
2870:FreeRTOS/Source/tasks.c **** 				#endif
2871:FreeRTOS/Source/tasks.c **** 
2872:FreeRTOS/Source/tasks.c **** 				/* Add the amount of time the task has been running to the
2873:FreeRTOS/Source/tasks.c **** 				accumulated time so far.  The time the task started running was
2874:FreeRTOS/Source/tasks.c **** 				stored in ulTaskSwitchedInTime.  Note that there is no overflow
2875:FreeRTOS/Source/tasks.c **** 				protection here so count values are only valid until the timer
2876:FreeRTOS/Source/tasks.c **** 				overflows.  The guard against negative values is to protect
2877:FreeRTOS/Source/tasks.c **** 				against suspect run time stat counter implementations - which
2878:FreeRTOS/Source/tasks.c **** 				are provided by the application, not the kernel. */
2879:FreeRTOS/Source/tasks.c **** 				if( ulTotalRunTime > ulTaskSwitchedInTime )
2880:FreeRTOS/Source/tasks.c **** 				{
2881:FreeRTOS/Source/tasks.c **** 					pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
2882:FreeRTOS/Source/tasks.c **** 				}
2883:FreeRTOS/Source/tasks.c **** 				else
2884:FreeRTOS/Source/tasks.c **** 				{
2885:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
2886:FreeRTOS/Source/tasks.c **** 				}
2887:FreeRTOS/Source/tasks.c **** 				ulTaskSwitchedInTime = ulTotalRunTime;
2888:FreeRTOS/Source/tasks.c **** 		}
2889:FreeRTOS/Source/tasks.c **** 		#endif /* configGENERATE_RUN_TIME_STATS */
2890:FreeRTOS/Source/tasks.c **** 
2891:FreeRTOS/Source/tasks.c **** 		/* Check for stack overflow, if configured. */
2892:FreeRTOS/Source/tasks.c **** 		taskCHECK_FOR_STACK_OVERFLOW();
2893:FreeRTOS/Source/tasks.c **** 
2894:FreeRTOS/Source/tasks.c **** 		/* Select a new task to run using either the generic C or port
2895:FreeRTOS/Source/tasks.c **** 		optimised asm code. */
2896:FreeRTOS/Source/tasks.c **** 		taskSELECT_HIGHEST_PRIORITY_TASK();
2897:FreeRTOS/Source/tasks.c **** 		traceTASK_SWITCHED_IN();
2898:FreeRTOS/Source/tasks.c **** 
2899:FreeRTOS/Source/tasks.c **** 		#if ( configUSE_NEWLIB_REENTRANT == 1 )
2900:FreeRTOS/Source/tasks.c **** 		{
2901:FreeRTOS/Source/tasks.c **** 			/* Switch Newlib's _impure_ptr variable to point to the _reent
2902:FreeRTOS/Source/tasks.c **** 			structure specific to this task. */
2903:FreeRTOS/Source/tasks.c **** 			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
2904:FreeRTOS/Source/tasks.c **** 		}
2905:FreeRTOS/Source/tasks.c **** 		#endif /* configUSE_NEWLIB_REENTRANT */
2906:FreeRTOS/Source/tasks.c **** 	}
2907:FreeRTOS/Source/tasks.c **** }
2908:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2909:FreeRTOS/Source/tasks.c **** 
2910:FreeRTOS/Source/tasks.c **** void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
2911:FreeRTOS/Source/tasks.c **** {
2912:FreeRTOS/Source/tasks.c **** 	configASSERT( pxEventList );
2913:FreeRTOS/Source/tasks.c **** 
2914:FreeRTOS/Source/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH EITHER INTERRUPTS DISABLED OR THE
2915:FreeRTOS/Source/tasks.c **** 	SCHEDULER SUSPENDED AND THE QUEUE BEING ACCESSED LOCKED. */
2916:FreeRTOS/Source/tasks.c **** 
2917:FreeRTOS/Source/tasks.c **** 	/* Place the event list item of the TCB in the appropriate event list.
2918:FreeRTOS/Source/tasks.c **** 	This is placed in the list in priority order so the highest priority task
2919:FreeRTOS/Source/tasks.c **** 	is the first to be woken by the event.  The queue that contains the event
2920:FreeRTOS/Source/tasks.c **** 	list is locked, preventing simultaneous access from interrupts. */
2921:FreeRTOS/Source/tasks.c **** 	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
2922:FreeRTOS/Source/tasks.c **** 
2923:FreeRTOS/Source/tasks.c **** 	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
2924:FreeRTOS/Source/tasks.c **** }
2925:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2926:FreeRTOS/Source/tasks.c **** 
2927:FreeRTOS/Source/tasks.c **** void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickT
2928:FreeRTOS/Source/tasks.c **** {
2929:FreeRTOS/Source/tasks.c **** 	configASSERT( pxEventList );
2930:FreeRTOS/Source/tasks.c **** 
2931:FreeRTOS/Source/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
2932:FreeRTOS/Source/tasks.c **** 	the event groups implementation. */
2933:FreeRTOS/Source/tasks.c **** 	configASSERT( uxSchedulerSuspended != 0 );
2934:FreeRTOS/Source/tasks.c **** 
2935:FreeRTOS/Source/tasks.c **** 	/* Store the item value in the event list item.  It is safe to access the
2936:FreeRTOS/Source/tasks.c **** 	event list item here as interrupts won't access the event list item of a
2937:FreeRTOS/Source/tasks.c **** 	task that is not in the Blocked state. */
2938:FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE
2939:FreeRTOS/Source/tasks.c **** 
2940:FreeRTOS/Source/tasks.c **** 	/* Place the event list item of the TCB at the end of the appropriate event
2941:FreeRTOS/Source/tasks.c **** 	list.  It is safe to access the event list here because it is part of an
2942:FreeRTOS/Source/tasks.c **** 	event group implementation - and interrupts don't access event groups
2943:FreeRTOS/Source/tasks.c **** 	directly (instead they access them indirectly by pending function calls to
2944:FreeRTOS/Source/tasks.c **** 	the task level). */
2945:FreeRTOS/Source/tasks.c **** 	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
2946:FreeRTOS/Source/tasks.c **** 
2947:FreeRTOS/Source/tasks.c **** 	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
2948:FreeRTOS/Source/tasks.c **** }
2949:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2950:FreeRTOS/Source/tasks.c **** 
2951:FreeRTOS/Source/tasks.c **** #if( configUSE_TIMERS == 1 )
2952:FreeRTOS/Source/tasks.c **** 
2953:FreeRTOS/Source/tasks.c **** 	void vTaskPlaceOnEventListRestricted( List_t * const pxEventList, TickType_t xTicksToWait, const B
2954:FreeRTOS/Source/tasks.c **** 	{
2955:FreeRTOS/Source/tasks.c **** 		configASSERT( pxEventList );
2956:FreeRTOS/Source/tasks.c **** 
2957:FreeRTOS/Source/tasks.c **** 		/* This function should not be called by application code hence the
2958:FreeRTOS/Source/tasks.c **** 		'Restricted' in its name.  It is not part of the public API.  It is
2959:FreeRTOS/Source/tasks.c **** 		designed for use by kernel code, and has special calling requirements -
2960:FreeRTOS/Source/tasks.c **** 		it should be called with the scheduler suspended. */
2961:FreeRTOS/Source/tasks.c **** 
2962:FreeRTOS/Source/tasks.c **** 
2963:FreeRTOS/Source/tasks.c **** 		/* Place the event list item of the TCB in the appropriate event list.
2964:FreeRTOS/Source/tasks.c **** 		In this case it is assume that this is the only task that is going to
2965:FreeRTOS/Source/tasks.c **** 		be waiting on this event list, so the faster vListInsertEnd() function
2966:FreeRTOS/Source/tasks.c **** 		can be used in place of vListInsert. */
2967:FreeRTOS/Source/tasks.c **** 		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
2968:FreeRTOS/Source/tasks.c **** 
2969:FreeRTOS/Source/tasks.c **** 		/* If the task should block indefinitely then set the block time to a
2970:FreeRTOS/Source/tasks.c **** 		value that will be recognised as an indefinite delay inside the
2971:FreeRTOS/Source/tasks.c **** 		prvAddCurrentTaskToDelayedList() function. */
2972:FreeRTOS/Source/tasks.c **** 		if( xWaitIndefinitely != pdFALSE )
2973:FreeRTOS/Source/tasks.c **** 		{
2974:FreeRTOS/Source/tasks.c **** 			xTicksToWait = portMAX_DELAY;
2975:FreeRTOS/Source/tasks.c **** 		}
2976:FreeRTOS/Source/tasks.c **** 
2977:FreeRTOS/Source/tasks.c **** 		traceTASK_DELAY_UNTIL( ( xTickCount + xTicksToWait ) );
2978:FreeRTOS/Source/tasks.c **** 		prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
2979:FreeRTOS/Source/tasks.c **** 	}
2980:FreeRTOS/Source/tasks.c **** 
2981:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TIMERS */
2982:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2983:FreeRTOS/Source/tasks.c **** 
2984:FreeRTOS/Source/tasks.c **** BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
2985:FreeRTOS/Source/tasks.c **** {
2986:FreeRTOS/Source/tasks.c **** TCB_t *pxUnblockedTCB;
2987:FreeRTOS/Source/tasks.c **** BaseType_t xReturn;
2988:FreeRTOS/Source/tasks.c **** 
2989:FreeRTOS/Source/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED FROM A CRITICAL SECTION.  It can also be
2990:FreeRTOS/Source/tasks.c **** 	called from a critical section within an ISR. */
2991:FreeRTOS/Source/tasks.c **** 
2992:FreeRTOS/Source/tasks.c **** 	/* The event list is sorted in priority order, so the first in the list can
2993:FreeRTOS/Source/tasks.c **** 	be removed as it is known to be the highest priority.  Remove the TCB from
2994:FreeRTOS/Source/tasks.c **** 	the delayed list, and add it to the ready list.
2995:FreeRTOS/Source/tasks.c **** 
2996:FreeRTOS/Source/tasks.c **** 	If an event is for a queue that is locked then this function will never
2997:FreeRTOS/Source/tasks.c **** 	get called - the lock count on the queue will get modified instead.  This
2998:FreeRTOS/Source/tasks.c **** 	means exclusive access to the event list is guaranteed here.
2999:FreeRTOS/Source/tasks.c **** 
3000:FreeRTOS/Source/tasks.c **** 	This function assumes that a check has already been made to ensure that
3001:FreeRTOS/Source/tasks.c **** 	pxEventList is not empty. */
3002:FreeRTOS/Source/tasks.c **** 	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
3003:FreeRTOS/Source/tasks.c **** 	configASSERT( pxUnblockedTCB );
3004:FreeRTOS/Source/tasks.c **** 	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
3005:FreeRTOS/Source/tasks.c **** 
3006:FreeRTOS/Source/tasks.c **** 	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
3007:FreeRTOS/Source/tasks.c **** 	{
3008:FreeRTOS/Source/tasks.c **** 		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
3009:FreeRTOS/Source/tasks.c **** 		prvAddTaskToReadyList( pxUnblockedTCB );
3010:FreeRTOS/Source/tasks.c **** 	}
3011:FreeRTOS/Source/tasks.c **** 	else
3012:FreeRTOS/Source/tasks.c **** 	{
3013:FreeRTOS/Source/tasks.c **** 		/* The delayed and ready lists cannot be accessed, so hold this task
3014:FreeRTOS/Source/tasks.c **** 		pending until the scheduler is resumed. */
3015:FreeRTOS/Source/tasks.c **** 		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
3016:FreeRTOS/Source/tasks.c **** 	}
3017:FreeRTOS/Source/tasks.c **** 
3018:FreeRTOS/Source/tasks.c **** 	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
3019:FreeRTOS/Source/tasks.c **** 	{
3020:FreeRTOS/Source/tasks.c **** 		/* Return true if the task removed from the event list has a higher
3021:FreeRTOS/Source/tasks.c **** 		priority than the calling task.  This allows the calling task to know if
3022:FreeRTOS/Source/tasks.c **** 		it should force a context switch now. */
3023:FreeRTOS/Source/tasks.c **** 		xReturn = pdTRUE;
3024:FreeRTOS/Source/tasks.c **** 
3025:FreeRTOS/Source/tasks.c **** 		/* Mark that a yield is pending in case the user is not using the
3026:FreeRTOS/Source/tasks.c **** 		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
3027:FreeRTOS/Source/tasks.c **** 		xYieldPending = pdTRUE;
3028:FreeRTOS/Source/tasks.c **** 	}
3029:FreeRTOS/Source/tasks.c **** 	else
3030:FreeRTOS/Source/tasks.c **** 	{
3031:FreeRTOS/Source/tasks.c **** 		xReturn = pdFALSE;
3032:FreeRTOS/Source/tasks.c **** 	}
3033:FreeRTOS/Source/tasks.c **** 
3034:FreeRTOS/Source/tasks.c **** 	#if( configUSE_TICKLESS_IDLE != 0 )
3035:FreeRTOS/Source/tasks.c **** 	{
3036:FreeRTOS/Source/tasks.c **** 		/* If a task is blocked on a kernel object then xNextTaskUnblockTime
3037:FreeRTOS/Source/tasks.c **** 		might be set to the blocked task's time out time.  If the task is
3038:FreeRTOS/Source/tasks.c **** 		unblocked for a reason other than a timeout xNextTaskUnblockTime is
3039:FreeRTOS/Source/tasks.c **** 		normally left unchanged, because it is automatically reset to a new
3040:FreeRTOS/Source/tasks.c **** 		value when the tick count equals xNextTaskUnblockTime.  However if
3041:FreeRTOS/Source/tasks.c **** 		tickless idling is used it might be more important to enter sleep mode
3042:FreeRTOS/Source/tasks.c **** 		at the earliest possible time - so reset xNextTaskUnblockTime here to
3043:FreeRTOS/Source/tasks.c **** 		ensure it is updated at the earliest possible time. */
3044:FreeRTOS/Source/tasks.c **** 		prvResetNextTaskUnblockTime();
3045:FreeRTOS/Source/tasks.c **** 	}
3046:FreeRTOS/Source/tasks.c **** 	#endif
3047:FreeRTOS/Source/tasks.c **** 
3048:FreeRTOS/Source/tasks.c **** 	return xReturn;
3049:FreeRTOS/Source/tasks.c **** }
3050:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3051:FreeRTOS/Source/tasks.c **** 
3052:FreeRTOS/Source/tasks.c **** void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
3053:FreeRTOS/Source/tasks.c **** {
3054:FreeRTOS/Source/tasks.c **** TCB_t *pxUnblockedTCB;
3055:FreeRTOS/Source/tasks.c **** 
3056:FreeRTOS/Source/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
3057:FreeRTOS/Source/tasks.c **** 	the event flags implementation. */
3058:FreeRTOS/Source/tasks.c **** 	configASSERT( uxSchedulerSuspended != pdFALSE );
3059:FreeRTOS/Source/tasks.c **** 
3060:FreeRTOS/Source/tasks.c **** 	/* Store the new item value in the event list. */
3061:FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
3062:FreeRTOS/Source/tasks.c **** 
3063:FreeRTOS/Source/tasks.c **** 	/* Remove the event list form the event flag.  Interrupts do not access
3064:FreeRTOS/Source/tasks.c **** 	event flags. */
3065:FreeRTOS/Source/tasks.c **** 	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
3066:FreeRTOS/Source/tasks.c **** 	configASSERT( pxUnblockedTCB );
3067:FreeRTOS/Source/tasks.c **** 	( void ) uxListRemove( pxEventListItem );
3068:FreeRTOS/Source/tasks.c **** 
3069:FreeRTOS/Source/tasks.c **** 	/* Remove the task from the delayed list and add it to the ready list.  The
3070:FreeRTOS/Source/tasks.c **** 	scheduler is suspended so interrupts will not be accessing the ready
3071:FreeRTOS/Source/tasks.c **** 	lists. */
3072:FreeRTOS/Source/tasks.c **** 	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
3073:FreeRTOS/Source/tasks.c **** 	prvAddTaskToReadyList( pxUnblockedTCB );
3074:FreeRTOS/Source/tasks.c **** 
3075:FreeRTOS/Source/tasks.c **** 	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
3076:FreeRTOS/Source/tasks.c **** 	{
3077:FreeRTOS/Source/tasks.c **** 		/* The unblocked task has a priority above that of the calling task, so
3078:FreeRTOS/Source/tasks.c **** 		a context switch is required.  This function is called with the
3079:FreeRTOS/Source/tasks.c **** 		scheduler suspended so xYieldPending is set so the context switch
3080:FreeRTOS/Source/tasks.c **** 		occurs immediately that the scheduler is resumed (unsuspended). */
3081:FreeRTOS/Source/tasks.c **** 		xYieldPending = pdTRUE;
3082:FreeRTOS/Source/tasks.c **** 	}
3083:FreeRTOS/Source/tasks.c **** }
3084:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3085:FreeRTOS/Source/tasks.c **** 
3086:FreeRTOS/Source/tasks.c **** void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
3087:FreeRTOS/Source/tasks.c **** {
3088:FreeRTOS/Source/tasks.c **** 	configASSERT( pxTimeOut );
3089:FreeRTOS/Source/tasks.c **** 	taskENTER_CRITICAL();
3090:FreeRTOS/Source/tasks.c **** 	{
3091:FreeRTOS/Source/tasks.c **** 		pxTimeOut->xOverflowCount = xNumOfOverflows;
3092:FreeRTOS/Source/tasks.c **** 		pxTimeOut->xTimeOnEntering = xTickCount;
3093:FreeRTOS/Source/tasks.c **** 	}
3094:FreeRTOS/Source/tasks.c **** 	taskEXIT_CRITICAL();
3095:FreeRTOS/Source/tasks.c **** }
3096:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3097:FreeRTOS/Source/tasks.c **** 
3098:FreeRTOS/Source/tasks.c **** void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
3099:FreeRTOS/Source/tasks.c **** {
3100:FreeRTOS/Source/tasks.c **** 	/* For internal use only as it does not use a critical section. */
3101:FreeRTOS/Source/tasks.c **** 	pxTimeOut->xOverflowCount = xNumOfOverflows;
3102:FreeRTOS/Source/tasks.c **** 	pxTimeOut->xTimeOnEntering = xTickCount;
3103:FreeRTOS/Source/tasks.c **** }
3104:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3105:FreeRTOS/Source/tasks.c **** 
3106:FreeRTOS/Source/tasks.c **** BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
3107:FreeRTOS/Source/tasks.c **** {
3108:FreeRTOS/Source/tasks.c **** BaseType_t xReturn;
3109:FreeRTOS/Source/tasks.c **** 
3110:FreeRTOS/Source/tasks.c **** 	configASSERT( pxTimeOut );
3111:FreeRTOS/Source/tasks.c **** 	configASSERT( pxTicksToWait );
3112:FreeRTOS/Source/tasks.c **** 
3113:FreeRTOS/Source/tasks.c **** 	taskENTER_CRITICAL();
3114:FreeRTOS/Source/tasks.c **** 	{
3115:FreeRTOS/Source/tasks.c **** 		/* Minor optimisation.  The tick count cannot change in this block. */
3116:FreeRTOS/Source/tasks.c **** 		const TickType_t xConstTickCount = xTickCount;
3117:FreeRTOS/Source/tasks.c **** 		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
3118:FreeRTOS/Source/tasks.c **** 
3119:FreeRTOS/Source/tasks.c **** 		#if( INCLUDE_xTaskAbortDelay == 1 )
3120:FreeRTOS/Source/tasks.c **** 			if( pxCurrentTCB->ucDelayAborted != pdFALSE )
3121:FreeRTOS/Source/tasks.c **** 			{
3122:FreeRTOS/Source/tasks.c **** 				/* The delay was aborted, which is not the same as a time out,
3123:FreeRTOS/Source/tasks.c **** 				but has the same result. */
3124:FreeRTOS/Source/tasks.c **** 				pxCurrentTCB->ucDelayAborted = pdFALSE;
3125:FreeRTOS/Source/tasks.c **** 				xReturn = pdTRUE;
3126:FreeRTOS/Source/tasks.c **** 			}
3127:FreeRTOS/Source/tasks.c **** 			else
3128:FreeRTOS/Source/tasks.c **** 		#endif
3129:FreeRTOS/Source/tasks.c **** 
3130:FreeRTOS/Source/tasks.c **** 		#if ( INCLUDE_vTaskSuspend == 1 )
3131:FreeRTOS/Source/tasks.c **** 			if( *pxTicksToWait == portMAX_DELAY )
3132:FreeRTOS/Source/tasks.c **** 			{
3133:FreeRTOS/Source/tasks.c **** 				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
3134:FreeRTOS/Source/tasks.c **** 				specified is the maximum block time then the task should block
3135:FreeRTOS/Source/tasks.c **** 				indefinitely, and therefore never time out. */
3136:FreeRTOS/Source/tasks.c **** 				xReturn = pdFALSE;
3137:FreeRTOS/Source/tasks.c **** 			}
3138:FreeRTOS/Source/tasks.c **** 			else
3139:FreeRTOS/Source/tasks.c **** 		#endif
3140:FreeRTOS/Source/tasks.c **** 
3141:FreeRTOS/Source/tasks.c **** 		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEn
3142:FreeRTOS/Source/tasks.c **** 		{
3143:FreeRTOS/Source/tasks.c **** 			/* The tick count is greater than the time at which
3144:FreeRTOS/Source/tasks.c **** 			vTaskSetTimeout() was called, but has also overflowed since
3145:FreeRTOS/Source/tasks.c **** 			vTaskSetTimeOut() was called.  It must have wrapped all the way
3146:FreeRTOS/Source/tasks.c **** 			around and gone past again. This passed since vTaskSetTimeout()
3147:FreeRTOS/Source/tasks.c **** 			was called. */
3148:FreeRTOS/Source/tasks.c **** 			xReturn = pdTRUE;
3149:FreeRTOS/Source/tasks.c **** 		}
3150:FreeRTOS/Source/tasks.c **** 		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with som
3151:FreeRTOS/Source/tasks.c **** 		{
3152:FreeRTOS/Source/tasks.c **** 			/* Not a genuine timeout. Adjust parameters for time remaining. */
3153:FreeRTOS/Source/tasks.c **** 			*pxTicksToWait -= xElapsedTime;
3154:FreeRTOS/Source/tasks.c **** 			vTaskInternalSetTimeOutState( pxTimeOut );
3155:FreeRTOS/Source/tasks.c **** 			xReturn = pdFALSE;
3156:FreeRTOS/Source/tasks.c **** 		}
3157:FreeRTOS/Source/tasks.c **** 		else
3158:FreeRTOS/Source/tasks.c **** 		{
3159:FreeRTOS/Source/tasks.c **** 			*pxTicksToWait = 0;
3160:FreeRTOS/Source/tasks.c **** 			xReturn = pdTRUE;
3161:FreeRTOS/Source/tasks.c **** 		}
3162:FreeRTOS/Source/tasks.c **** 	}
3163:FreeRTOS/Source/tasks.c **** 	taskEXIT_CRITICAL();
3164:FreeRTOS/Source/tasks.c **** 
3165:FreeRTOS/Source/tasks.c **** 	return xReturn;
3166:FreeRTOS/Source/tasks.c **** }
3167:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3168:FreeRTOS/Source/tasks.c **** 
3169:FreeRTOS/Source/tasks.c **** void vTaskMissedYield( void )
3170:FreeRTOS/Source/tasks.c **** {
3171:FreeRTOS/Source/tasks.c **** 	xYieldPending = pdTRUE;
3172:FreeRTOS/Source/tasks.c **** }
3173:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3174:FreeRTOS/Source/tasks.c **** 
3175:FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
3176:FreeRTOS/Source/tasks.c **** 
3177:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask )
3178:FreeRTOS/Source/tasks.c **** 	{
3179:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxReturn;
3180:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
3181:FreeRTOS/Source/tasks.c **** 
3182:FreeRTOS/Source/tasks.c **** 		if( xTask != NULL )
3183:FreeRTOS/Source/tasks.c **** 		{
3184:FreeRTOS/Source/tasks.c **** 			pxTCB = ( TCB_t * ) xTask;
3185:FreeRTOS/Source/tasks.c **** 			uxReturn = pxTCB->uxTaskNumber;
3186:FreeRTOS/Source/tasks.c **** 		}
3187:FreeRTOS/Source/tasks.c **** 		else
3188:FreeRTOS/Source/tasks.c **** 		{
3189:FreeRTOS/Source/tasks.c **** 			uxReturn = 0U;
3190:FreeRTOS/Source/tasks.c **** 		}
3191:FreeRTOS/Source/tasks.c **** 
3192:FreeRTOS/Source/tasks.c **** 		return uxReturn;
3193:FreeRTOS/Source/tasks.c **** 	}
3194:FreeRTOS/Source/tasks.c **** 
3195:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
3196:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3197:FreeRTOS/Source/tasks.c **** 
3198:FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
3199:FreeRTOS/Source/tasks.c **** 
3200:FreeRTOS/Source/tasks.c **** 	void vTaskSetTaskNumber( TaskHandle_t xTask, const UBaseType_t uxHandle )
3201:FreeRTOS/Source/tasks.c **** 	{
3202:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
3203:FreeRTOS/Source/tasks.c **** 
3204:FreeRTOS/Source/tasks.c **** 		if( xTask != NULL )
3205:FreeRTOS/Source/tasks.c **** 		{
3206:FreeRTOS/Source/tasks.c **** 			pxTCB = ( TCB_t * ) xTask;
3207:FreeRTOS/Source/tasks.c **** 			pxTCB->uxTaskNumber = uxHandle;
3208:FreeRTOS/Source/tasks.c **** 		}
3209:FreeRTOS/Source/tasks.c **** 	}
3210:FreeRTOS/Source/tasks.c **** 
3211:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
3212:FreeRTOS/Source/tasks.c **** 
3213:FreeRTOS/Source/tasks.c **** /*
3214:FreeRTOS/Source/tasks.c ****  * -----------------------------------------------------------
3215:FreeRTOS/Source/tasks.c ****  * The Idle task.
3216:FreeRTOS/Source/tasks.c ****  * ----------------------------------------------------------
3217:FreeRTOS/Source/tasks.c ****  *
3218:FreeRTOS/Source/tasks.c ****  * The portTASK_FUNCTION() macro is used to allow port/compiler specific
3219:FreeRTOS/Source/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
3220:FreeRTOS/Source/tasks.c ****  *
3221:FreeRTOS/Source/tasks.c ****  * void prvIdleTask( void *pvParameters );
3222:FreeRTOS/Source/tasks.c ****  *
3223:FreeRTOS/Source/tasks.c ****  */
3224:FreeRTOS/Source/tasks.c **** static portTASK_FUNCTION( prvIdleTask, pvParameters )
3225:FreeRTOS/Source/tasks.c **** {
3226:FreeRTOS/Source/tasks.c **** 	/* Stop warnings. */
3227:FreeRTOS/Source/tasks.c **** 	( void ) pvParameters;
3228:FreeRTOS/Source/tasks.c **** 
3229:FreeRTOS/Source/tasks.c **** 	/** THIS IS THE RTOS IDLE TASK - WHICH IS CREATED AUTOMATICALLY WHEN THE
3230:FreeRTOS/Source/tasks.c **** 	SCHEDULER IS STARTED. **/
3231:FreeRTOS/Source/tasks.c **** 
3232:FreeRTOS/Source/tasks.c **** 	/* In case a task that has a secure context deletes itself, in which case
3233:FreeRTOS/Source/tasks.c **** 	the idle task is responsible for deleting the task's secure context, if
3234:FreeRTOS/Source/tasks.c **** 	any. */
3235:FreeRTOS/Source/tasks.c **** 	portTASK_CALLS_SECURE_FUNCTIONS();
3236:FreeRTOS/Source/tasks.c **** 
3237:FreeRTOS/Source/tasks.c **** 	for( ;; )
3238:FreeRTOS/Source/tasks.c **** 	{
3239:FreeRTOS/Source/tasks.c **** 		/* See if any tasks have deleted themselves - if so then the idle task
3240:FreeRTOS/Source/tasks.c **** 		is responsible for freeing the deleted task's TCB and stack. */
3241:FreeRTOS/Source/tasks.c **** 		prvCheckTasksWaitingTermination();
3242:FreeRTOS/Source/tasks.c **** 
3243:FreeRTOS/Source/tasks.c **** 		#if ( configUSE_PREEMPTION == 0 )
3244:FreeRTOS/Source/tasks.c **** 		{
3245:FreeRTOS/Source/tasks.c **** 			/* If we are not using preemption we keep forcing a task switch to
3246:FreeRTOS/Source/tasks.c **** 			see if any other task has become available.  If we are using
3247:FreeRTOS/Source/tasks.c **** 			preemption we don't need to do this as any task becoming available
3248:FreeRTOS/Source/tasks.c **** 			will automatically get the processor anyway. */
3249:FreeRTOS/Source/tasks.c **** 			taskYIELD();
3250:FreeRTOS/Source/tasks.c **** 		}
3251:FreeRTOS/Source/tasks.c **** 		#endif /* configUSE_PREEMPTION */
3252:FreeRTOS/Source/tasks.c **** 
3253:FreeRTOS/Source/tasks.c **** 		#if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
3254:FreeRTOS/Source/tasks.c **** 		{
3255:FreeRTOS/Source/tasks.c **** 			/* When using preemption tasks of equal priority will be
3256:FreeRTOS/Source/tasks.c **** 			timesliced.  If a task that is sharing the idle priority is ready
3257:FreeRTOS/Source/tasks.c **** 			to run then the idle task should yield before the end of the
3258:FreeRTOS/Source/tasks.c **** 			timeslice.
3259:FreeRTOS/Source/tasks.c **** 
3260:FreeRTOS/Source/tasks.c **** 			A critical region is not required here as we are just reading from
3261:FreeRTOS/Source/tasks.c **** 			the list, and an occasional incorrect value will not matter.  If
3262:FreeRTOS/Source/tasks.c **** 			the ready list at the idle priority contains more than one task
3263:FreeRTOS/Source/tasks.c **** 			then a task other than the idle task is ready to execute. */
3264:FreeRTOS/Source/tasks.c **** 			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
3265:FreeRTOS/Source/tasks.c **** 			{
3266:FreeRTOS/Source/tasks.c **** 				taskYIELD();
3267:FreeRTOS/Source/tasks.c **** 			}
3268:FreeRTOS/Source/tasks.c **** 			else
3269:FreeRTOS/Source/tasks.c **** 			{
3270:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3271:FreeRTOS/Source/tasks.c **** 			}
3272:FreeRTOS/Source/tasks.c **** 		}
3273:FreeRTOS/Source/tasks.c **** 		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) ) */
3274:FreeRTOS/Source/tasks.c **** 
3275:FreeRTOS/Source/tasks.c **** 		#if ( configUSE_IDLE_HOOK == 1 )
3276:FreeRTOS/Source/tasks.c **** 		{
3277:FreeRTOS/Source/tasks.c **** 			extern void vApplicationIdleHook( void );
3278:FreeRTOS/Source/tasks.c **** 
3279:FreeRTOS/Source/tasks.c **** 			/* Call the user defined function from within the idle task.  This
3280:FreeRTOS/Source/tasks.c **** 			allows the application designer to add background functionality
3281:FreeRTOS/Source/tasks.c **** 			without the overhead of a separate task.
3282:FreeRTOS/Source/tasks.c **** 			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
3283:FreeRTOS/Source/tasks.c **** 			CALL A FUNCTION THAT MIGHT BLOCK. */
3284:FreeRTOS/Source/tasks.c **** 			vApplicationIdleHook();
3285:FreeRTOS/Source/tasks.c **** 		}
3286:FreeRTOS/Source/tasks.c **** 		#endif /* configUSE_IDLE_HOOK */
3287:FreeRTOS/Source/tasks.c **** 
3288:FreeRTOS/Source/tasks.c **** 		/* This conditional compilation should use inequality to 0, not equality
3289:FreeRTOS/Source/tasks.c **** 		to 1.  This is to ensure portSUPPRESS_TICKS_AND_SLEEP() is called when
3290:FreeRTOS/Source/tasks.c **** 		user defined low power mode	implementations require
3291:FreeRTOS/Source/tasks.c **** 		configUSE_TICKLESS_IDLE to be set to a value other than 1. */
3292:FreeRTOS/Source/tasks.c **** 		#if ( configUSE_TICKLESS_IDLE != 0 )
3293:FreeRTOS/Source/tasks.c **** 		{
3294:FreeRTOS/Source/tasks.c **** 		TickType_t xExpectedIdleTime;
3295:FreeRTOS/Source/tasks.c **** 
3296:FreeRTOS/Source/tasks.c **** 			/* It is not desirable to suspend then resume the scheduler on
3297:FreeRTOS/Source/tasks.c **** 			each iteration of the idle task.  Therefore, a preliminary
3298:FreeRTOS/Source/tasks.c **** 			test of the expected idle time is performed without the
3299:FreeRTOS/Source/tasks.c **** 			scheduler suspended.  The result here is not necessarily
3300:FreeRTOS/Source/tasks.c **** 			valid. */
3301:FreeRTOS/Source/tasks.c **** 			xExpectedIdleTime = prvGetExpectedIdleTime();
3302:FreeRTOS/Source/tasks.c **** 
3303:FreeRTOS/Source/tasks.c **** 			if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
3304:FreeRTOS/Source/tasks.c **** 			{
3305:FreeRTOS/Source/tasks.c **** 				vTaskSuspendAll();
3306:FreeRTOS/Source/tasks.c **** 				{
3307:FreeRTOS/Source/tasks.c **** 					/* Now the scheduler is suspended, the expected idle
3308:FreeRTOS/Source/tasks.c **** 					time can be sampled again, and this time its value can
3309:FreeRTOS/Source/tasks.c **** 					be used. */
3310:FreeRTOS/Source/tasks.c **** 					configASSERT( xNextTaskUnblockTime >= xTickCount );
3311:FreeRTOS/Source/tasks.c **** 					xExpectedIdleTime = prvGetExpectedIdleTime();
3312:FreeRTOS/Source/tasks.c **** 
3313:FreeRTOS/Source/tasks.c **** 					/* Define the following macro to set xExpectedIdleTime to 0
3314:FreeRTOS/Source/tasks.c **** 					if the application does not want
3315:FreeRTOS/Source/tasks.c **** 					portSUPPRESS_TICKS_AND_SLEEP() to be called. */
3316:FreeRTOS/Source/tasks.c **** 					configPRE_SUPPRESS_TICKS_AND_SLEEP_PROCESSING( xExpectedIdleTime );
3317:FreeRTOS/Source/tasks.c **** 
3318:FreeRTOS/Source/tasks.c **** 					if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
3319:FreeRTOS/Source/tasks.c **** 					{
3320:FreeRTOS/Source/tasks.c **** 						traceLOW_POWER_IDLE_BEGIN();
3321:FreeRTOS/Source/tasks.c **** 						portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime );
3322:FreeRTOS/Source/tasks.c **** 						traceLOW_POWER_IDLE_END();
3323:FreeRTOS/Source/tasks.c **** 					}
3324:FreeRTOS/Source/tasks.c **** 					else
3325:FreeRTOS/Source/tasks.c **** 					{
3326:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
3327:FreeRTOS/Source/tasks.c **** 					}
3328:FreeRTOS/Source/tasks.c **** 				}
3329:FreeRTOS/Source/tasks.c **** 				( void ) xTaskResumeAll();
3330:FreeRTOS/Source/tasks.c **** 			}
3331:FreeRTOS/Source/tasks.c **** 			else
3332:FreeRTOS/Source/tasks.c **** 			{
3333:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3334:FreeRTOS/Source/tasks.c **** 			}
3335:FreeRTOS/Source/tasks.c **** 		}
3336:FreeRTOS/Source/tasks.c **** 		#endif /* configUSE_TICKLESS_IDLE */
3337:FreeRTOS/Source/tasks.c **** 	}
3338:FreeRTOS/Source/tasks.c **** }
3339:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3340:FreeRTOS/Source/tasks.c **** 
3341:FreeRTOS/Source/tasks.c **** #if( configUSE_TICKLESS_IDLE != 0 )
3342:FreeRTOS/Source/tasks.c **** 
3343:FreeRTOS/Source/tasks.c **** 	eSleepModeStatus eTaskConfirmSleepModeStatus( void )
3344:FreeRTOS/Source/tasks.c **** 	{
3345:FreeRTOS/Source/tasks.c **** 	/* The idle task exists in addition to the application tasks. */
3346:FreeRTOS/Source/tasks.c **** 	const UBaseType_t uxNonApplicationTasks = 1;
3347:FreeRTOS/Source/tasks.c **** 	eSleepModeStatus eReturn = eStandardSleep;
3348:FreeRTOS/Source/tasks.c **** 
3349:FreeRTOS/Source/tasks.c **** 		if( listCURRENT_LIST_LENGTH( &xPendingReadyList ) != 0 )
3350:FreeRTOS/Source/tasks.c **** 		{
3351:FreeRTOS/Source/tasks.c **** 			/* A task was made ready while the scheduler was suspended. */
3352:FreeRTOS/Source/tasks.c **** 			eReturn = eAbortSleep;
3353:FreeRTOS/Source/tasks.c **** 		}
3354:FreeRTOS/Source/tasks.c **** 		else if( xYieldPending != pdFALSE )
3355:FreeRTOS/Source/tasks.c **** 		{
3356:FreeRTOS/Source/tasks.c **** 			/* A yield was pended while the scheduler was suspended. */
3357:FreeRTOS/Source/tasks.c **** 			eReturn = eAbortSleep;
3358:FreeRTOS/Source/tasks.c **** 		}
3359:FreeRTOS/Source/tasks.c **** 		else
3360:FreeRTOS/Source/tasks.c **** 		{
3361:FreeRTOS/Source/tasks.c **** 			/* If all the tasks are in the suspended list (which might mean they
3362:FreeRTOS/Source/tasks.c **** 			have an infinite block time rather than actually being suspended)
3363:FreeRTOS/Source/tasks.c **** 			then it is safe to turn all clocks off and just wait for external
3364:FreeRTOS/Source/tasks.c **** 			interrupts. */
3365:FreeRTOS/Source/tasks.c **** 			if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == ( uxCurrentNumberOfTasks - uxNonApplicatio
3366:FreeRTOS/Source/tasks.c **** 			{
3367:FreeRTOS/Source/tasks.c **** 				eReturn = eNoTasksWaitingTimeout;
3368:FreeRTOS/Source/tasks.c **** 			}
3369:FreeRTOS/Source/tasks.c **** 			else
3370:FreeRTOS/Source/tasks.c **** 			{
3371:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3372:FreeRTOS/Source/tasks.c **** 			}
3373:FreeRTOS/Source/tasks.c **** 		}
3374:FreeRTOS/Source/tasks.c **** 
3375:FreeRTOS/Source/tasks.c **** 		return eReturn;
3376:FreeRTOS/Source/tasks.c **** 	}
3377:FreeRTOS/Source/tasks.c **** 
3378:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
3379:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3380:FreeRTOS/Source/tasks.c **** 
3381:FreeRTOS/Source/tasks.c **** #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
3382:FreeRTOS/Source/tasks.c **** 
3383:FreeRTOS/Source/tasks.c **** 	void vTaskSetThreadLocalStoragePointer( TaskHandle_t xTaskToSet, BaseType_t xIndex, void *pvValue 
3384:FreeRTOS/Source/tasks.c **** 	{
3385:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
3386:FreeRTOS/Source/tasks.c **** 
3387:FreeRTOS/Source/tasks.c **** 		if( xIndex < configNUM_THREAD_LOCAL_STORAGE_POINTERS )
3388:FreeRTOS/Source/tasks.c **** 		{
3389:FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTaskToSet );
3390:FreeRTOS/Source/tasks.c **** 			pxTCB->pvThreadLocalStoragePointers[ xIndex ] = pvValue;
3391:FreeRTOS/Source/tasks.c **** 		}
3392:FreeRTOS/Source/tasks.c **** 	}
3393:FreeRTOS/Source/tasks.c **** 
3394:FreeRTOS/Source/tasks.c **** #endif /* configNUM_THREAD_LOCAL_STORAGE_POINTERS */
3395:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3396:FreeRTOS/Source/tasks.c **** 
3397:FreeRTOS/Source/tasks.c **** #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
3398:FreeRTOS/Source/tasks.c **** 
3399:FreeRTOS/Source/tasks.c **** 	void *pvTaskGetThreadLocalStoragePointer( TaskHandle_t xTaskToQuery, BaseType_t xIndex )
3400:FreeRTOS/Source/tasks.c **** 	{
3401:FreeRTOS/Source/tasks.c **** 	void *pvReturn = NULL;
3402:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
3403:FreeRTOS/Source/tasks.c **** 
3404:FreeRTOS/Source/tasks.c **** 		if( xIndex < configNUM_THREAD_LOCAL_STORAGE_POINTERS )
3405:FreeRTOS/Source/tasks.c **** 		{
3406:FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTaskToQuery );
3407:FreeRTOS/Source/tasks.c **** 			pvReturn = pxTCB->pvThreadLocalStoragePointers[ xIndex ];
3408:FreeRTOS/Source/tasks.c **** 		}
3409:FreeRTOS/Source/tasks.c **** 		else
3410:FreeRTOS/Source/tasks.c **** 		{
3411:FreeRTOS/Source/tasks.c **** 			pvReturn = NULL;
3412:FreeRTOS/Source/tasks.c **** 		}
3413:FreeRTOS/Source/tasks.c **** 
3414:FreeRTOS/Source/tasks.c **** 		return pvReturn;
3415:FreeRTOS/Source/tasks.c **** 	}
3416:FreeRTOS/Source/tasks.c **** 
3417:FreeRTOS/Source/tasks.c **** #endif /* configNUM_THREAD_LOCAL_STORAGE_POINTERS */
3418:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3419:FreeRTOS/Source/tasks.c **** 
3420:FreeRTOS/Source/tasks.c **** #if ( portUSING_MPU_WRAPPERS == 1 )
3421:FreeRTOS/Source/tasks.c **** 
3422:FreeRTOS/Source/tasks.c **** 	void vTaskAllocateMPURegions( TaskHandle_t xTaskToModify, const MemoryRegion_t * const xRegions )
3423:FreeRTOS/Source/tasks.c **** 	{
3424:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
3425:FreeRTOS/Source/tasks.c **** 
3426:FreeRTOS/Source/tasks.c **** 		/* If null is passed in here then we are modifying the MPU settings of
3427:FreeRTOS/Source/tasks.c **** 		the calling task. */
3428:FreeRTOS/Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTaskToModify );
3429:FreeRTOS/Source/tasks.c **** 
3430:FreeRTOS/Source/tasks.c **** 		vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, NULL, 0 );
3431:FreeRTOS/Source/tasks.c **** 	}
3432:FreeRTOS/Source/tasks.c **** 
3433:FreeRTOS/Source/tasks.c **** #endif /* portUSING_MPU_WRAPPERS */
3434:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3435:FreeRTOS/Source/tasks.c **** 
3436:FreeRTOS/Source/tasks.c **** static void prvInitialiseTaskLists( void )
3437:FreeRTOS/Source/tasks.c **** {
3438:FreeRTOS/Source/tasks.c **** UBaseType_t uxPriority;
3439:FreeRTOS/Source/tasks.c **** 
3440:FreeRTOS/Source/tasks.c **** 	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriorit
3441:FreeRTOS/Source/tasks.c **** 	{
3442:FreeRTOS/Source/tasks.c **** 		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
3443:FreeRTOS/Source/tasks.c **** 	}
3444:FreeRTOS/Source/tasks.c **** 
3445:FreeRTOS/Source/tasks.c **** 	vListInitialise( &xDelayedTaskList1 );
3446:FreeRTOS/Source/tasks.c **** 	vListInitialise( &xDelayedTaskList2 );
3447:FreeRTOS/Source/tasks.c **** 	vListInitialise( &xPendingReadyList );
3448:FreeRTOS/Source/tasks.c **** 
3449:FreeRTOS/Source/tasks.c **** 	#if ( INCLUDE_vTaskDelete == 1 )
3450:FreeRTOS/Source/tasks.c **** 	{
3451:FreeRTOS/Source/tasks.c **** 		vListInitialise( &xTasksWaitingTermination );
3452:FreeRTOS/Source/tasks.c **** 	}
3453:FreeRTOS/Source/tasks.c **** 	#endif /* INCLUDE_vTaskDelete */
3454:FreeRTOS/Source/tasks.c **** 
3455:FreeRTOS/Source/tasks.c **** 	#if ( INCLUDE_vTaskSuspend == 1 )
3456:FreeRTOS/Source/tasks.c **** 	{
3457:FreeRTOS/Source/tasks.c **** 		vListInitialise( &xSuspendedTaskList );
3458:FreeRTOS/Source/tasks.c **** 	}
3459:FreeRTOS/Source/tasks.c **** 	#endif /* INCLUDE_vTaskSuspend */
3460:FreeRTOS/Source/tasks.c **** 
3461:FreeRTOS/Source/tasks.c **** 	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
3462:FreeRTOS/Source/tasks.c **** 	using list2. */
3463:FreeRTOS/Source/tasks.c **** 	pxDelayedTaskList = &xDelayedTaskList1;
3464:FreeRTOS/Source/tasks.c **** 	pxOverflowDelayedTaskList = &xDelayedTaskList2;
3465:FreeRTOS/Source/tasks.c **** }
3466:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3467:FreeRTOS/Source/tasks.c **** 
3468:FreeRTOS/Source/tasks.c **** static void prvCheckTasksWaitingTermination( void )
3469:FreeRTOS/Source/tasks.c **** {
3470:FreeRTOS/Source/tasks.c **** 
3471:FreeRTOS/Source/tasks.c **** 	/** THIS FUNCTION IS CALLED FROM THE RTOS IDLE TASK **/
3472:FreeRTOS/Source/tasks.c **** 
3473:FreeRTOS/Source/tasks.c **** 	#if ( INCLUDE_vTaskDelete == 1 )
3474:FreeRTOS/Source/tasks.c **** 	{
3475:FreeRTOS/Source/tasks.c **** 		TCB_t *pxTCB;
3476:FreeRTOS/Source/tasks.c **** 
3477:FreeRTOS/Source/tasks.c **** 		/* uxDeletedTasksWaitingCleanUp is used to prevent vTaskSuspendAll()
3478:FreeRTOS/Source/tasks.c **** 		being called too often in the idle task. */
3479:FreeRTOS/Source/tasks.c **** 		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
3480:FreeRTOS/Source/tasks.c **** 		{
3481:FreeRTOS/Source/tasks.c **** 			taskENTER_CRITICAL();
3482:FreeRTOS/Source/tasks.c **** 			{
3483:FreeRTOS/Source/tasks.c **** 				pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
3484:FreeRTOS/Source/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
3485:FreeRTOS/Source/tasks.c **** 				--uxCurrentNumberOfTasks;
3486:FreeRTOS/Source/tasks.c **** 				--uxDeletedTasksWaitingCleanUp;
3487:FreeRTOS/Source/tasks.c **** 			}
3488:FreeRTOS/Source/tasks.c **** 			taskEXIT_CRITICAL();
3489:FreeRTOS/Source/tasks.c **** 
3490:FreeRTOS/Source/tasks.c **** 			prvDeleteTCB( pxTCB );
3491:FreeRTOS/Source/tasks.c **** 		}
3492:FreeRTOS/Source/tasks.c **** 	}
3493:FreeRTOS/Source/tasks.c **** 	#endif /* INCLUDE_vTaskDelete */
3494:FreeRTOS/Source/tasks.c **** }
3495:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3496:FreeRTOS/Source/tasks.c **** 
3497:FreeRTOS/Source/tasks.c **** #if( configUSE_TRACE_FACILITY == 1 )
3498:FreeRTOS/Source/tasks.c **** 
3499:FreeRTOS/Source/tasks.c **** 	void vTaskGetInfo( TaskHandle_t xTask, TaskStatus_t *pxTaskStatus, BaseType_t xGetFreeStackSpace, 
3500:FreeRTOS/Source/tasks.c **** 	{
3501:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
3502:FreeRTOS/Source/tasks.c **** 
3503:FreeRTOS/Source/tasks.c **** 		/* xTask is NULL then get the state of the calling task. */
3504:FreeRTOS/Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTask );
3505:FreeRTOS/Source/tasks.c **** 
3506:FreeRTOS/Source/tasks.c **** 		pxTaskStatus->xHandle = ( TaskHandle_t ) pxTCB;
3507:FreeRTOS/Source/tasks.c **** 		pxTaskStatus->pcTaskName = ( const char * ) &( pxTCB->pcTaskName [ 0 ] );
3508:FreeRTOS/Source/tasks.c **** 		pxTaskStatus->uxCurrentPriority = pxTCB->uxPriority;
3509:FreeRTOS/Source/tasks.c **** 		pxTaskStatus->pxStackBase = pxTCB->pxStack;
3510:FreeRTOS/Source/tasks.c **** 		pxTaskStatus->xTaskNumber = pxTCB->uxTCBNumber;
3511:FreeRTOS/Source/tasks.c **** 
3512:FreeRTOS/Source/tasks.c **** 		#if ( configUSE_MUTEXES == 1 )
3513:FreeRTOS/Source/tasks.c **** 		{
3514:FreeRTOS/Source/tasks.c **** 			pxTaskStatus->uxBasePriority = pxTCB->uxBasePriority;
3515:FreeRTOS/Source/tasks.c **** 		}
3516:FreeRTOS/Source/tasks.c **** 		#else
3517:FreeRTOS/Source/tasks.c **** 		{
3518:FreeRTOS/Source/tasks.c **** 			pxTaskStatus->uxBasePriority = 0;
3519:FreeRTOS/Source/tasks.c **** 		}
3520:FreeRTOS/Source/tasks.c **** 		#endif
3521:FreeRTOS/Source/tasks.c **** 
3522:FreeRTOS/Source/tasks.c **** 		#if ( configGENERATE_RUN_TIME_STATS == 1 )
3523:FreeRTOS/Source/tasks.c **** 		{
3524:FreeRTOS/Source/tasks.c **** 			pxTaskStatus->ulRunTimeCounter = pxTCB->ulRunTimeCounter;
3525:FreeRTOS/Source/tasks.c **** 		}
3526:FreeRTOS/Source/tasks.c **** 		#else
3527:FreeRTOS/Source/tasks.c **** 		{
3528:FreeRTOS/Source/tasks.c **** 			pxTaskStatus->ulRunTimeCounter = 0;
3529:FreeRTOS/Source/tasks.c **** 		}
3530:FreeRTOS/Source/tasks.c **** 		#endif
3531:FreeRTOS/Source/tasks.c **** 
3532:FreeRTOS/Source/tasks.c **** 		/* Obtaining the task state is a little fiddly, so is only done if the
3533:FreeRTOS/Source/tasks.c **** 		value of eState passed into this function is eInvalid - otherwise the
3534:FreeRTOS/Source/tasks.c **** 		state is just set to whatever is passed in. */
3535:FreeRTOS/Source/tasks.c **** 		if( eState != eInvalid )
3536:FreeRTOS/Source/tasks.c **** 		{
3537:FreeRTOS/Source/tasks.c **** 			if( pxTCB == pxCurrentTCB )
3538:FreeRTOS/Source/tasks.c **** 			{
3539:FreeRTOS/Source/tasks.c **** 				pxTaskStatus->eCurrentState = eRunning;
3540:FreeRTOS/Source/tasks.c **** 			}
3541:FreeRTOS/Source/tasks.c **** 			else
3542:FreeRTOS/Source/tasks.c **** 			{
3543:FreeRTOS/Source/tasks.c **** 				pxTaskStatus->eCurrentState = eState;
3544:FreeRTOS/Source/tasks.c **** 
3545:FreeRTOS/Source/tasks.c **** 				#if ( INCLUDE_vTaskSuspend == 1 )
3546:FreeRTOS/Source/tasks.c **** 				{
3547:FreeRTOS/Source/tasks.c **** 					/* If the task is in the suspended list then there is a
3548:FreeRTOS/Source/tasks.c **** 					chance it is actually just blocked indefinitely - so really
3549:FreeRTOS/Source/tasks.c **** 					it should be reported as being in the Blocked state. */
3550:FreeRTOS/Source/tasks.c **** 					if( eState == eSuspended )
3551:FreeRTOS/Source/tasks.c **** 					{
3552:FreeRTOS/Source/tasks.c **** 						vTaskSuspendAll();
3553:FreeRTOS/Source/tasks.c **** 						{
3554:FreeRTOS/Source/tasks.c **** 							if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
3555:FreeRTOS/Source/tasks.c **** 							{
3556:FreeRTOS/Source/tasks.c **** 								pxTaskStatus->eCurrentState = eBlocked;
3557:FreeRTOS/Source/tasks.c **** 							}
3558:FreeRTOS/Source/tasks.c **** 						}
3559:FreeRTOS/Source/tasks.c **** 						( void ) xTaskResumeAll();
3560:FreeRTOS/Source/tasks.c **** 					}
3561:FreeRTOS/Source/tasks.c **** 				}
3562:FreeRTOS/Source/tasks.c **** 				#endif /* INCLUDE_vTaskSuspend */
3563:FreeRTOS/Source/tasks.c **** 			}
3564:FreeRTOS/Source/tasks.c **** 		}
3565:FreeRTOS/Source/tasks.c **** 		else
3566:FreeRTOS/Source/tasks.c **** 		{
3567:FreeRTOS/Source/tasks.c **** 			pxTaskStatus->eCurrentState = eTaskGetState( pxTCB );
3568:FreeRTOS/Source/tasks.c **** 		}
3569:FreeRTOS/Source/tasks.c **** 
3570:FreeRTOS/Source/tasks.c **** 		/* Obtaining the stack space takes some time, so the xGetFreeStackSpace
3571:FreeRTOS/Source/tasks.c **** 		parameter is provided to allow it to be skipped. */
3572:FreeRTOS/Source/tasks.c **** 		if( xGetFreeStackSpace != pdFALSE )
3573:FreeRTOS/Source/tasks.c **** 		{
3574:FreeRTOS/Source/tasks.c **** 			#if ( portSTACK_GROWTH > 0 )
3575:FreeRTOS/Source/tasks.c **** 			{
3576:FreeRTOS/Source/tasks.c **** 				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxEndOfSt
3577:FreeRTOS/Source/tasks.c **** 			}
3578:FreeRTOS/Source/tasks.c **** 			#else
3579:FreeRTOS/Source/tasks.c **** 			{
3580:FreeRTOS/Source/tasks.c **** 				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxStack )
3581:FreeRTOS/Source/tasks.c **** 			}
3582:FreeRTOS/Source/tasks.c **** 			#endif
3583:FreeRTOS/Source/tasks.c **** 		}
3584:FreeRTOS/Source/tasks.c **** 		else
3585:FreeRTOS/Source/tasks.c **** 		{
3586:FreeRTOS/Source/tasks.c **** 			pxTaskStatus->usStackHighWaterMark = 0;
3587:FreeRTOS/Source/tasks.c **** 		}
3588:FreeRTOS/Source/tasks.c **** 	}
3589:FreeRTOS/Source/tasks.c **** 
3590:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
3591:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3592:FreeRTOS/Source/tasks.c **** 
3593:FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
3594:FreeRTOS/Source/tasks.c **** 
3595:FreeRTOS/Source/tasks.c **** 	static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, 
3596:FreeRTOS/Source/tasks.c **** 	{
3597:FreeRTOS/Source/tasks.c **** 	configLIST_VOLATILE TCB_t *pxNextTCB, *pxFirstTCB;
3598:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxTask = 0;
3599:FreeRTOS/Source/tasks.c **** 
3600:FreeRTOS/Source/tasks.c **** 		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
3601:FreeRTOS/Source/tasks.c **** 		{
3602:FreeRTOS/Source/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
3603:FreeRTOS/Source/tasks.c **** 
3604:FreeRTOS/Source/tasks.c **** 			/* Populate an TaskStatus_t structure within the
3605:FreeRTOS/Source/tasks.c **** 			pxTaskStatusArray array for each task that is referenced from
3606:FreeRTOS/Source/tasks.c **** 			pxList.  See the definition of TaskStatus_t in task.h for the
3607:FreeRTOS/Source/tasks.c **** 			meaning of each TaskStatus_t structure member. */
3608:FreeRTOS/Source/tasks.c **** 			do
3609:FreeRTOS/Source/tasks.c **** 			{
3610:FreeRTOS/Source/tasks.c **** 				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
3611:FreeRTOS/Source/tasks.c **** 				vTaskGetInfo( ( TaskHandle_t ) pxNextTCB, &( pxTaskStatusArray[ uxTask ] ), pdTRUE, eState );
3612:FreeRTOS/Source/tasks.c **** 				uxTask++;
3613:FreeRTOS/Source/tasks.c **** 			} while( pxNextTCB != pxFirstTCB );
3614:FreeRTOS/Source/tasks.c **** 		}
3615:FreeRTOS/Source/tasks.c **** 		else
3616:FreeRTOS/Source/tasks.c **** 		{
3617:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
3618:FreeRTOS/Source/tasks.c **** 		}
3619:FreeRTOS/Source/tasks.c **** 
3620:FreeRTOS/Source/tasks.c **** 		return uxTask;
3621:FreeRTOS/Source/tasks.c **** 	}
3622:FreeRTOS/Source/tasks.c **** 
3623:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
3624:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3625:FreeRTOS/Source/tasks.c **** 
3626:FreeRTOS/Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
3627:FreeRTOS/Source/tasks.c **** 
3628:FreeRTOS/Source/tasks.c **** 	static uint16_t prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
3629:FreeRTOS/Source/tasks.c **** 	{
3630:FreeRTOS/Source/tasks.c **** 	uint32_t ulCount = 0U;
3631:FreeRTOS/Source/tasks.c **** 
3632:FreeRTOS/Source/tasks.c **** 		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
3633:FreeRTOS/Source/tasks.c **** 		{
3634:FreeRTOS/Source/tasks.c **** 			pucStackByte -= portSTACK_GROWTH;
3635:FreeRTOS/Source/tasks.c **** 			ulCount++;
3636:FreeRTOS/Source/tasks.c **** 		}
3637:FreeRTOS/Source/tasks.c **** 
3638:FreeRTOS/Source/tasks.c **** 		ulCount /= ( uint32_t ) sizeof( StackType_t ); /*lint !e961 Casting is not redundant on smaller a
3639:FreeRTOS/Source/tasks.c **** 
3640:FreeRTOS/Source/tasks.c **** 		return ( uint16_t ) ulCount;
3641:FreeRTOS/Source/tasks.c **** 	}
3642:FreeRTOS/Source/tasks.c **** 
3643:FreeRTOS/Source/tasks.c **** #endif /* ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) ) */
3644:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3645:FreeRTOS/Source/tasks.c **** 
3646:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )
3647:FreeRTOS/Source/tasks.c **** 
3648:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask )
3649:FreeRTOS/Source/tasks.c **** 	{
3650:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
3651:FreeRTOS/Source/tasks.c **** 	uint8_t *pucEndOfStack;
3652:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxReturn;
3653:FreeRTOS/Source/tasks.c **** 
3654:FreeRTOS/Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTask );
3655:FreeRTOS/Source/tasks.c **** 
3656:FreeRTOS/Source/tasks.c **** 		#if portSTACK_GROWTH < 0
3657:FreeRTOS/Source/tasks.c **** 		{
3658:FreeRTOS/Source/tasks.c **** 			pucEndOfStack = ( uint8_t * ) pxTCB->pxStack;
3659:FreeRTOS/Source/tasks.c **** 		}
3660:FreeRTOS/Source/tasks.c **** 		#else
3661:FreeRTOS/Source/tasks.c **** 		{
3662:FreeRTOS/Source/tasks.c **** 			pucEndOfStack = ( uint8_t * ) pxTCB->pxEndOfStack;
3663:FreeRTOS/Source/tasks.c **** 		}
3664:FreeRTOS/Source/tasks.c **** 		#endif
3665:FreeRTOS/Source/tasks.c **** 
3666:FreeRTOS/Source/tasks.c **** 		uxReturn = ( UBaseType_t ) prvTaskCheckFreeStackSpace( pucEndOfStack );
3667:FreeRTOS/Source/tasks.c **** 
3668:FreeRTOS/Source/tasks.c **** 		return uxReturn;
3669:FreeRTOS/Source/tasks.c **** 	}
3670:FreeRTOS/Source/tasks.c **** 
3671:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_uxTaskGetStackHighWaterMark */
3672:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3673:FreeRTOS/Source/tasks.c **** 
3674:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
3675:FreeRTOS/Source/tasks.c **** 
3676:FreeRTOS/Source/tasks.c **** 	static void prvDeleteTCB( TCB_t *pxTCB )
3677:FreeRTOS/Source/tasks.c **** 	{
3678:FreeRTOS/Source/tasks.c **** 		/* This call is required specifically for the TriCore port.  It must be
3679:FreeRTOS/Source/tasks.c **** 		above the vPortFree() calls.  The call is also used by ports/demos that
3680:FreeRTOS/Source/tasks.c **** 		want to allocate and clean RAM statically. */
3681:FreeRTOS/Source/tasks.c **** 		portCLEAN_UP_TCB( pxTCB );
3682:FreeRTOS/Source/tasks.c **** 
3683:FreeRTOS/Source/tasks.c **** 		/* Free up the memory allocated by the scheduler for the task.  It is up
3684:FreeRTOS/Source/tasks.c **** 		to the task to free any memory allocated at the application level. */
3685:FreeRTOS/Source/tasks.c **** 		#if ( configUSE_NEWLIB_REENTRANT == 1 )
3686:FreeRTOS/Source/tasks.c **** 		{
3687:FreeRTOS/Source/tasks.c **** 			_reclaim_reent( &( pxTCB->xNewLib_reent ) );
3688:FreeRTOS/Source/tasks.c **** 		}
3689:FreeRTOS/Source/tasks.c **** 		#endif /* configUSE_NEWLIB_REENTRANT */
3690:FreeRTOS/Source/tasks.c **** 
3691:FreeRTOS/Source/tasks.c **** 		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( p
3692:FreeRTOS/Source/tasks.c **** 		{
3693:FreeRTOS/Source/tasks.c **** 			/* The task can only have been allocated dynamically - free both
3694:FreeRTOS/Source/tasks.c **** 			the stack and TCB. */
3695:FreeRTOS/Source/tasks.c **** 			vPortFree( pxTCB->pxStack );
3696:FreeRTOS/Source/tasks.c **** 			vPortFree( pxTCB );
3697:FreeRTOS/Source/tasks.c **** 		}
3698:FreeRTOS/Source/tasks.c **** 		#elif( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 Macro has been consolidated 
3699:FreeRTOS/Source/tasks.c **** 		{
3700:FreeRTOS/Source/tasks.c **** 			/* The task could have been allocated statically or dynamically, so
3701:FreeRTOS/Source/tasks.c **** 			check what was statically allocated before trying to free the
3702:FreeRTOS/Source/tasks.c **** 			memory. */
3703:FreeRTOS/Source/tasks.c **** 			if( pxTCB->ucStaticallyAllocated == tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB )
3704:FreeRTOS/Source/tasks.c **** 			{
3705:FreeRTOS/Source/tasks.c **** 				/* Both the stack and TCB were allocated dynamically, so both
3706:FreeRTOS/Source/tasks.c **** 				must be freed. */
3707:FreeRTOS/Source/tasks.c **** 				vPortFree( pxTCB->pxStack );
3708:FreeRTOS/Source/tasks.c **** 				vPortFree( pxTCB );
3709:FreeRTOS/Source/tasks.c **** 			}
3710:FreeRTOS/Source/tasks.c **** 			else if( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_ONLY )
3711:FreeRTOS/Source/tasks.c **** 			{
3712:FreeRTOS/Source/tasks.c **** 				/* Only the stack was statically allocated, so the TCB is the
3713:FreeRTOS/Source/tasks.c **** 				only memory that must be freed. */
3714:FreeRTOS/Source/tasks.c **** 				vPortFree( pxTCB );
3715:FreeRTOS/Source/tasks.c **** 			}
3716:FreeRTOS/Source/tasks.c **** 			else
3717:FreeRTOS/Source/tasks.c **** 			{
3718:FreeRTOS/Source/tasks.c **** 				/* Neither the stack nor the TCB were allocated dynamically, so
3719:FreeRTOS/Source/tasks.c **** 				nothing needs to be freed. */
3720:FreeRTOS/Source/tasks.c **** 				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
3721:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3722:FreeRTOS/Source/tasks.c **** 			}
3723:FreeRTOS/Source/tasks.c **** 		}
3724:FreeRTOS/Source/tasks.c **** 		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
3725:FreeRTOS/Source/tasks.c **** 	}
3726:FreeRTOS/Source/tasks.c **** 
3727:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskDelete */
3728:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3729:FreeRTOS/Source/tasks.c **** 
3730:FreeRTOS/Source/tasks.c **** static void prvResetNextTaskUnblockTime( void )
3731:FreeRTOS/Source/tasks.c **** {
 190               	.LM0:
 191               	.LFBB1:
 192               	/* prologue: function */
 193               	/* frame size = 0 */
 194               	/* stack size = 0 */
 195               	.L__stack_usage = 0
3732:FreeRTOS/Source/tasks.c **** TCB_t *pxTCB;
3733:FreeRTOS/Source/tasks.c **** 
3734:FreeRTOS/Source/tasks.c **** 	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 197               	.LM1:
 198 0000 E091 0000 		lds r30,pxDelayedTaskList
 199 0004 F091 0000 		lds r31,pxDelayedTaskList+1
 200 0008 8081      		ld r24,Z
 201 000a 8111      		cpse r24,__zero_reg__
 202 000c 00C0      		rjmp .L2
3735:FreeRTOS/Source/tasks.c **** 	{
3736:FreeRTOS/Source/tasks.c **** 		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
3737:FreeRTOS/Source/tasks.c **** 		the maximum possible value so it is	extremely unlikely that the
3738:FreeRTOS/Source/tasks.c **** 		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
3739:FreeRTOS/Source/tasks.c **** 		there is an item in the delayed list. */
3740:FreeRTOS/Source/tasks.c **** 		xNextTaskUnblockTime = portMAX_DELAY;
 204               	.LM2:
 205 000e 8FEF      		ldi r24,lo8(-1)
 206 0010 9FEF      		ldi r25,lo8(-1)
 207 0012 00C0      		rjmp .L4
 208               	.L2:
 209               	.LBB4:
 210               	.LBB5:
3741:FreeRTOS/Source/tasks.c **** 	}
3742:FreeRTOS/Source/tasks.c **** 	else
3743:FreeRTOS/Source/tasks.c **** 	{
3744:FreeRTOS/Source/tasks.c **** 		/* The new current delayed list is not empty, get the value of
3745:FreeRTOS/Source/tasks.c **** 		the item at the head of the delayed list.  This is the time at
3746:FreeRTOS/Source/tasks.c **** 		which the task at the head of the delayed list should be removed
3747:FreeRTOS/Source/tasks.c **** 		from the Blocked state. */
3748:FreeRTOS/Source/tasks.c **** 		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 212               	.LM3:
 213 0014 E091 0000 		lds r30,pxDelayedTaskList
 214 0018 F091 0000 		lds r31,pxDelayedTaskList+1
 215 001c 0580      		ldd __tmp_reg__,Z+5
 216 001e F681      		ldd r31,Z+6
 217 0020 E02D      		mov r30,__tmp_reg__
3749:FreeRTOS/Source/tasks.c **** 		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 219               	.LM4:
 220 0022 0680      		ldd __tmp_reg__,Z+6
 221 0024 F781      		ldd r31,Z+7
 222 0026 E02D      		mov r30,__tmp_reg__
 223 0028 8281      		ldd r24,Z+2
 224 002a 9381      		ldd r25,Z+3
 225               	.L4:
 226 002c 9093 0000 		sts xNextTaskUnblockTime+1,r25
 227 0030 8093 0000 		sts xNextTaskUnblockTime,r24
 228 0034 0895      		ret
 229               	.LBE5:
 230               	.LBE4:
 232               	.Lscope1:
 234               		.stabd	78,0,0
 238               	prvAddCurrentTaskToDelayedList.isra.2:
 239               		.stabd	46,0,0
3750:FreeRTOS/Source/tasks.c **** 	}
3751:FreeRTOS/Source/tasks.c **** }
3752:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3753:FreeRTOS/Source/tasks.c **** 
3754:FreeRTOS/Source/tasks.c **** #if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )
3755:FreeRTOS/Source/tasks.c **** 
3756:FreeRTOS/Source/tasks.c **** 	TaskHandle_t xTaskGetCurrentTaskHandle( void )
3757:FreeRTOS/Source/tasks.c **** 	{
3758:FreeRTOS/Source/tasks.c **** 	TaskHandle_t xReturn;
3759:FreeRTOS/Source/tasks.c **** 
3760:FreeRTOS/Source/tasks.c **** 		/* A critical section is not required as this is not called from
3761:FreeRTOS/Source/tasks.c **** 		an interrupt and the current TCB will always be the same for any
3762:FreeRTOS/Source/tasks.c **** 		individual execution thread. */
3763:FreeRTOS/Source/tasks.c **** 		xReturn = pxCurrentTCB;
3764:FreeRTOS/Source/tasks.c **** 
3765:FreeRTOS/Source/tasks.c **** 		return xReturn;
3766:FreeRTOS/Source/tasks.c **** 	}
3767:FreeRTOS/Source/tasks.c **** 
3768:FreeRTOS/Source/tasks.c **** #endif /* ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) ) */
3769:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3770:FreeRTOS/Source/tasks.c **** 
3771:FreeRTOS/Source/tasks.c **** #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
3772:FreeRTOS/Source/tasks.c **** 
3773:FreeRTOS/Source/tasks.c **** 	BaseType_t xTaskGetSchedulerState( void )
3774:FreeRTOS/Source/tasks.c **** 	{
3775:FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn;
3776:FreeRTOS/Source/tasks.c **** 
3777:FreeRTOS/Source/tasks.c **** 		if( xSchedulerRunning == pdFALSE )
3778:FreeRTOS/Source/tasks.c **** 		{
3779:FreeRTOS/Source/tasks.c **** 			xReturn = taskSCHEDULER_NOT_STARTED;
3780:FreeRTOS/Source/tasks.c **** 		}
3781:FreeRTOS/Source/tasks.c **** 		else
3782:FreeRTOS/Source/tasks.c **** 		{
3783:FreeRTOS/Source/tasks.c **** 			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
3784:FreeRTOS/Source/tasks.c **** 			{
3785:FreeRTOS/Source/tasks.c **** 				xReturn = taskSCHEDULER_RUNNING;
3786:FreeRTOS/Source/tasks.c **** 			}
3787:FreeRTOS/Source/tasks.c **** 			else
3788:FreeRTOS/Source/tasks.c **** 			{
3789:FreeRTOS/Source/tasks.c **** 				xReturn = taskSCHEDULER_SUSPENDED;
3790:FreeRTOS/Source/tasks.c **** 			}
3791:FreeRTOS/Source/tasks.c **** 		}
3792:FreeRTOS/Source/tasks.c **** 
3793:FreeRTOS/Source/tasks.c **** 		return xReturn;
3794:FreeRTOS/Source/tasks.c **** 	}
3795:FreeRTOS/Source/tasks.c **** 
3796:FreeRTOS/Source/tasks.c **** #endif /* ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) ) */
3797:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3798:FreeRTOS/Source/tasks.c **** 
3799:FreeRTOS/Source/tasks.c **** #if ( configUSE_MUTEXES == 1 )
3800:FreeRTOS/Source/tasks.c **** 
3801:FreeRTOS/Source/tasks.c **** 	BaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
3802:FreeRTOS/Source/tasks.c **** 	{
3803:FreeRTOS/Source/tasks.c **** 	TCB_t * const pxMutexHolderTCB = ( TCB_t * ) pxMutexHolder;
3804:FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn = pdFALSE;
3805:FreeRTOS/Source/tasks.c **** 
3806:FreeRTOS/Source/tasks.c **** 		/* If the mutex was given back by an interrupt while the queue was
3807:FreeRTOS/Source/tasks.c **** 		locked then the mutex holder might now be NULL.  _RB_ Is this still
3808:FreeRTOS/Source/tasks.c **** 		needed as interrupts can no longer use mutexes? */
3809:FreeRTOS/Source/tasks.c **** 		if( pxMutexHolder != NULL )
3810:FreeRTOS/Source/tasks.c **** 		{
3811:FreeRTOS/Source/tasks.c **** 			/* If the holder of the mutex has a priority below the priority of
3812:FreeRTOS/Source/tasks.c **** 			the task attempting to obtain the mutex then it will temporarily
3813:FreeRTOS/Source/tasks.c **** 			inherit the priority of the task attempting to obtain the mutex. */
3814:FreeRTOS/Source/tasks.c **** 			if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
3815:FreeRTOS/Source/tasks.c **** 			{
3816:FreeRTOS/Source/tasks.c **** 				/* Adjust the mutex holder state to account for its new
3817:FreeRTOS/Source/tasks.c **** 				priority.  Only reset the event list item value if the value is
3818:FreeRTOS/Source/tasks.c **** 				not being used for anything else. */
3819:FreeRTOS/Source/tasks.c **** 				if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VA
3820:FreeRTOS/Source/tasks.c **** 				{
3821:FreeRTOS/Source/tasks.c **** 					listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIOR
3822:FreeRTOS/Source/tasks.c **** 				}
3823:FreeRTOS/Source/tasks.c **** 				else
3824:FreeRTOS/Source/tasks.c **** 				{
3825:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
3826:FreeRTOS/Source/tasks.c **** 				}
3827:FreeRTOS/Source/tasks.c **** 
3828:FreeRTOS/Source/tasks.c **** 				/* If the task being modified is in the ready state it will need
3829:FreeRTOS/Source/tasks.c **** 				to be moved into a new list. */
3830:FreeRTOS/Source/tasks.c **** 				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutex
3831:FreeRTOS/Source/tasks.c **** 				{
3832:FreeRTOS/Source/tasks.c **** 					if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
3833:FreeRTOS/Source/tasks.c **** 					{
3834:FreeRTOS/Source/tasks.c **** 						taskRESET_READY_PRIORITY( pxMutexHolderTCB->uxPriority );
3835:FreeRTOS/Source/tasks.c **** 					}
3836:FreeRTOS/Source/tasks.c **** 					else
3837:FreeRTOS/Source/tasks.c **** 					{
3838:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
3839:FreeRTOS/Source/tasks.c **** 					}
3840:FreeRTOS/Source/tasks.c **** 
3841:FreeRTOS/Source/tasks.c **** 					/* Inherit the priority before being moved into the new list. */
3842:FreeRTOS/Source/tasks.c **** 					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
3843:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxMutexHolderTCB );
3844:FreeRTOS/Source/tasks.c **** 				}
3845:FreeRTOS/Source/tasks.c **** 				else
3846:FreeRTOS/Source/tasks.c **** 				{
3847:FreeRTOS/Source/tasks.c **** 					/* Just inherit the priority. */
3848:FreeRTOS/Source/tasks.c **** 					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
3849:FreeRTOS/Source/tasks.c **** 				}
3850:FreeRTOS/Source/tasks.c **** 
3851:FreeRTOS/Source/tasks.c **** 				traceTASK_PRIORITY_INHERIT( pxMutexHolderTCB, pxCurrentTCB->uxPriority );
3852:FreeRTOS/Source/tasks.c **** 
3853:FreeRTOS/Source/tasks.c **** 				/* Inheritance occurred. */
3854:FreeRTOS/Source/tasks.c **** 				xReturn = pdTRUE;
3855:FreeRTOS/Source/tasks.c **** 			}
3856:FreeRTOS/Source/tasks.c **** 			else
3857:FreeRTOS/Source/tasks.c **** 			{
3858:FreeRTOS/Source/tasks.c **** 				if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
3859:FreeRTOS/Source/tasks.c **** 				{
3860:FreeRTOS/Source/tasks.c **** 					/* The base priority of the mutex holder is lower than the
3861:FreeRTOS/Source/tasks.c **** 					priority of the task attempting to take the mutex, but the
3862:FreeRTOS/Source/tasks.c **** 					current priority of the mutex holder is not lower than the
3863:FreeRTOS/Source/tasks.c **** 					priority of the task attempting to take the mutex.
3864:FreeRTOS/Source/tasks.c **** 					Therefore the mutex holder must have already inherited a
3865:FreeRTOS/Source/tasks.c **** 					priority, but inheritance would have occurred if that had
3866:FreeRTOS/Source/tasks.c **** 					not been the case. */
3867:FreeRTOS/Source/tasks.c **** 					xReturn = pdTRUE;
3868:FreeRTOS/Source/tasks.c **** 				}
3869:FreeRTOS/Source/tasks.c **** 				else
3870:FreeRTOS/Source/tasks.c **** 				{
3871:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
3872:FreeRTOS/Source/tasks.c **** 				}
3873:FreeRTOS/Source/tasks.c **** 			}
3874:FreeRTOS/Source/tasks.c **** 		}
3875:FreeRTOS/Source/tasks.c **** 		else
3876:FreeRTOS/Source/tasks.c **** 		{
3877:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
3878:FreeRTOS/Source/tasks.c **** 		}
3879:FreeRTOS/Source/tasks.c **** 
3880:FreeRTOS/Source/tasks.c **** 		return xReturn;
3881:FreeRTOS/Source/tasks.c **** 	}
3882:FreeRTOS/Source/tasks.c **** 
3883:FreeRTOS/Source/tasks.c **** #endif /* configUSE_MUTEXES */
3884:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3885:FreeRTOS/Source/tasks.c **** 
3886:FreeRTOS/Source/tasks.c **** #if ( configUSE_MUTEXES == 1 )
3887:FreeRTOS/Source/tasks.c **** 
3888:FreeRTOS/Source/tasks.c **** 	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
3889:FreeRTOS/Source/tasks.c **** 	{
3890:FreeRTOS/Source/tasks.c **** 	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
3891:FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn = pdFALSE;
3892:FreeRTOS/Source/tasks.c **** 
3893:FreeRTOS/Source/tasks.c **** 		if( pxMutexHolder != NULL )
3894:FreeRTOS/Source/tasks.c **** 		{
3895:FreeRTOS/Source/tasks.c **** 			/* A task can only have an inherited priority if it holds the mutex.
3896:FreeRTOS/Source/tasks.c **** 			If the mutex is held by a task then it cannot be given from an
3897:FreeRTOS/Source/tasks.c **** 			interrupt, and if a mutex is given by the holding task then it must
3898:FreeRTOS/Source/tasks.c **** 			be the running state task. */
3899:FreeRTOS/Source/tasks.c **** 			configASSERT( pxTCB == pxCurrentTCB );
3900:FreeRTOS/Source/tasks.c **** 			configASSERT( pxTCB->uxMutexesHeld );
3901:FreeRTOS/Source/tasks.c **** 			( pxTCB->uxMutexesHeld )--;
3902:FreeRTOS/Source/tasks.c **** 
3903:FreeRTOS/Source/tasks.c **** 			/* Has the holder of the mutex inherited the priority of another
3904:FreeRTOS/Source/tasks.c **** 			task? */
3905:FreeRTOS/Source/tasks.c **** 			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
3906:FreeRTOS/Source/tasks.c **** 			{
3907:FreeRTOS/Source/tasks.c **** 				/* Only disinherit if no other mutexes are held. */
3908:FreeRTOS/Source/tasks.c **** 				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
3909:FreeRTOS/Source/tasks.c **** 				{
3910:FreeRTOS/Source/tasks.c **** 					/* A task can only have an inherited priority if it holds
3911:FreeRTOS/Source/tasks.c **** 					the mutex.  If the mutex is held by a task then it cannot be
3912:FreeRTOS/Source/tasks.c **** 					given from an interrupt, and if a mutex is given by the
3913:FreeRTOS/Source/tasks.c **** 					holding task then it must be the running state task.  Remove
3914:FreeRTOS/Source/tasks.c **** 					the holding task from the ready list. */
3915:FreeRTOS/Source/tasks.c **** 					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
3916:FreeRTOS/Source/tasks.c **** 					{
3917:FreeRTOS/Source/tasks.c **** 						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
3918:FreeRTOS/Source/tasks.c **** 					}
3919:FreeRTOS/Source/tasks.c **** 					else
3920:FreeRTOS/Source/tasks.c **** 					{
3921:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
3922:FreeRTOS/Source/tasks.c **** 					}
3923:FreeRTOS/Source/tasks.c **** 
3924:FreeRTOS/Source/tasks.c **** 					/* Disinherit the priority before adding the task into the
3925:FreeRTOS/Source/tasks.c **** 					new	ready list. */
3926:FreeRTOS/Source/tasks.c **** 					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
3927:FreeRTOS/Source/tasks.c **** 					pxTCB->uxPriority = pxTCB->uxBasePriority;
3928:FreeRTOS/Source/tasks.c **** 
3929:FreeRTOS/Source/tasks.c **** 					/* Reset the event list item value.  It cannot be in use for
3930:FreeRTOS/Source/tasks.c **** 					any other purpose if this task is running, and it must be
3931:FreeRTOS/Source/tasks.c **** 					running to give back the mutex. */
3932:FreeRTOS/Source/tasks.c **** 					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( T
3933:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
3934:FreeRTOS/Source/tasks.c **** 
3935:FreeRTOS/Source/tasks.c **** 					/* Return true to indicate that a context switch is required.
3936:FreeRTOS/Source/tasks.c **** 					This is only actually required in the corner case whereby
3937:FreeRTOS/Source/tasks.c **** 					multiple mutexes were held and the mutexes were given back
3938:FreeRTOS/Source/tasks.c **** 					in an order different to that in which they were taken.
3939:FreeRTOS/Source/tasks.c **** 					If a context switch did not occur when the first mutex was
3940:FreeRTOS/Source/tasks.c **** 					returned, even if a task was waiting on it, then a context
3941:FreeRTOS/Source/tasks.c **** 					switch should occur when the last mutex is returned whether
3942:FreeRTOS/Source/tasks.c **** 					a task is waiting on it or not. */
3943:FreeRTOS/Source/tasks.c **** 					xReturn = pdTRUE;
3944:FreeRTOS/Source/tasks.c **** 				}
3945:FreeRTOS/Source/tasks.c **** 				else
3946:FreeRTOS/Source/tasks.c **** 				{
3947:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
3948:FreeRTOS/Source/tasks.c **** 				}
3949:FreeRTOS/Source/tasks.c **** 			}
3950:FreeRTOS/Source/tasks.c **** 			else
3951:FreeRTOS/Source/tasks.c **** 			{
3952:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3953:FreeRTOS/Source/tasks.c **** 			}
3954:FreeRTOS/Source/tasks.c **** 		}
3955:FreeRTOS/Source/tasks.c **** 		else
3956:FreeRTOS/Source/tasks.c **** 		{
3957:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
3958:FreeRTOS/Source/tasks.c **** 		}
3959:FreeRTOS/Source/tasks.c **** 
3960:FreeRTOS/Source/tasks.c **** 		return xReturn;
3961:FreeRTOS/Source/tasks.c **** 	}
3962:FreeRTOS/Source/tasks.c **** 
3963:FreeRTOS/Source/tasks.c **** #endif /* configUSE_MUTEXES */
3964:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3965:FreeRTOS/Source/tasks.c **** 
3966:FreeRTOS/Source/tasks.c **** #if ( configUSE_MUTEXES == 1 )
3967:FreeRTOS/Source/tasks.c **** 
3968:FreeRTOS/Source/tasks.c **** 	void vTaskPriorityDisinheritAfterTimeout( TaskHandle_t const pxMutexHolder, UBaseType_t uxHighestP
3969:FreeRTOS/Source/tasks.c **** 	{
3970:FreeRTOS/Source/tasks.c **** 	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
3971:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxPriorityUsedOnEntry, uxPriorityToUse;
3972:FreeRTOS/Source/tasks.c **** 	const UBaseType_t uxOnlyOneMutexHeld = ( UBaseType_t ) 1;
3973:FreeRTOS/Source/tasks.c **** 
3974:FreeRTOS/Source/tasks.c **** 		if( pxMutexHolder != NULL )
3975:FreeRTOS/Source/tasks.c **** 		{
3976:FreeRTOS/Source/tasks.c **** 			/* If pxMutexHolder is not NULL then the holder must hold at least
3977:FreeRTOS/Source/tasks.c **** 			one mutex. */
3978:FreeRTOS/Source/tasks.c **** 			configASSERT( pxTCB->uxMutexesHeld );
3979:FreeRTOS/Source/tasks.c **** 
3980:FreeRTOS/Source/tasks.c **** 			/* Determine the priority to which the priority of the task that
3981:FreeRTOS/Source/tasks.c **** 			holds the mutex should be set.  This will be the greater of the
3982:FreeRTOS/Source/tasks.c **** 			holding task's base priority and the priority of the highest
3983:FreeRTOS/Source/tasks.c **** 			priority task that is waiting to obtain the mutex. */
3984:FreeRTOS/Source/tasks.c **** 			if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )
3985:FreeRTOS/Source/tasks.c **** 			{
3986:FreeRTOS/Source/tasks.c **** 				uxPriorityToUse = uxHighestPriorityWaitingTask;
3987:FreeRTOS/Source/tasks.c **** 			}
3988:FreeRTOS/Source/tasks.c **** 			else
3989:FreeRTOS/Source/tasks.c **** 			{
3990:FreeRTOS/Source/tasks.c **** 				uxPriorityToUse = pxTCB->uxBasePriority;
3991:FreeRTOS/Source/tasks.c **** 			}
3992:FreeRTOS/Source/tasks.c **** 
3993:FreeRTOS/Source/tasks.c **** 			/* Does the priority need to change? */
3994:FreeRTOS/Source/tasks.c **** 			if( pxTCB->uxPriority != uxPriorityToUse )
3995:FreeRTOS/Source/tasks.c **** 			{
3996:FreeRTOS/Source/tasks.c **** 				/* Only disinherit if no other mutexes are held.  This is a
3997:FreeRTOS/Source/tasks.c **** 				simplification in the priority inheritance implementation.  If
3998:FreeRTOS/Source/tasks.c **** 				the task that holds the mutex is also holding other mutexes then
3999:FreeRTOS/Source/tasks.c **** 				the other mutexes may have caused the priority inheritance. */
4000:FreeRTOS/Source/tasks.c **** 				if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
4001:FreeRTOS/Source/tasks.c **** 				{
4002:FreeRTOS/Source/tasks.c **** 					/* If a task has timed out because it already holds the
4003:FreeRTOS/Source/tasks.c **** 					mutex it was trying to obtain then it cannot of inherited
4004:FreeRTOS/Source/tasks.c **** 					its own priority. */
4005:FreeRTOS/Source/tasks.c **** 					configASSERT( pxTCB != pxCurrentTCB );
4006:FreeRTOS/Source/tasks.c **** 
4007:FreeRTOS/Source/tasks.c **** 					/* Disinherit the priority, remembering the previous
4008:FreeRTOS/Source/tasks.c **** 					priority to facilitate determining the subject task's
4009:FreeRTOS/Source/tasks.c **** 					state. */
4010:FreeRTOS/Source/tasks.c **** 					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
4011:FreeRTOS/Source/tasks.c **** 					uxPriorityUsedOnEntry = pxTCB->uxPriority;
4012:FreeRTOS/Source/tasks.c **** 					pxTCB->uxPriority = uxPriorityToUse;
4013:FreeRTOS/Source/tasks.c **** 
4014:FreeRTOS/Source/tasks.c **** 					/* Only reset the event list item value if the value is not
4015:FreeRTOS/Source/tasks.c **** 					being used for anything else. */
4016:FreeRTOS/Source/tasks.c **** 					if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE
4017:FreeRTOS/Source/tasks.c **** 					{
4018:FreeRTOS/Source/tasks.c **** 						listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( 
4019:FreeRTOS/Source/tasks.c **** 					}
4020:FreeRTOS/Source/tasks.c **** 					else
4021:FreeRTOS/Source/tasks.c **** 					{
4022:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
4023:FreeRTOS/Source/tasks.c **** 					}
4024:FreeRTOS/Source/tasks.c **** 
4025:FreeRTOS/Source/tasks.c **** 					/* If the running task is not the task that holds the mutex
4026:FreeRTOS/Source/tasks.c **** 					then the task that holds the mutex could be in either the
4027:FreeRTOS/Source/tasks.c **** 					Ready, Blocked or Suspended states.  Only remove the task
4028:FreeRTOS/Source/tasks.c **** 					from its current state list if it is in the Ready state as
4029:FreeRTOS/Source/tasks.c **** 					the task's priority is going to change and there is one
4030:FreeRTOS/Source/tasks.c **** 					Ready list per priority. */
4031:FreeRTOS/Source/tasks.c **** 					if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xState
4032:FreeRTOS/Source/tasks.c **** 					{
4033:FreeRTOS/Source/tasks.c **** 						if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
4034:FreeRTOS/Source/tasks.c **** 						{
4035:FreeRTOS/Source/tasks.c **** 							taskRESET_READY_PRIORITY( pxTCB->uxPriority );
4036:FreeRTOS/Source/tasks.c **** 						}
4037:FreeRTOS/Source/tasks.c **** 						else
4038:FreeRTOS/Source/tasks.c **** 						{
4039:FreeRTOS/Source/tasks.c **** 							mtCOVERAGE_TEST_MARKER();
4040:FreeRTOS/Source/tasks.c **** 						}
4041:FreeRTOS/Source/tasks.c **** 
4042:FreeRTOS/Source/tasks.c **** 						prvAddTaskToReadyList( pxTCB );
4043:FreeRTOS/Source/tasks.c **** 					}
4044:FreeRTOS/Source/tasks.c **** 					else
4045:FreeRTOS/Source/tasks.c **** 					{
4046:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
4047:FreeRTOS/Source/tasks.c **** 					}
4048:FreeRTOS/Source/tasks.c **** 				}
4049:FreeRTOS/Source/tasks.c **** 				else
4050:FreeRTOS/Source/tasks.c **** 				{
4051:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4052:FreeRTOS/Source/tasks.c **** 				}
4053:FreeRTOS/Source/tasks.c **** 			}
4054:FreeRTOS/Source/tasks.c **** 			else
4055:FreeRTOS/Source/tasks.c **** 			{
4056:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4057:FreeRTOS/Source/tasks.c **** 			}
4058:FreeRTOS/Source/tasks.c **** 		}
4059:FreeRTOS/Source/tasks.c **** 		else
4060:FreeRTOS/Source/tasks.c **** 		{
4061:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
4062:FreeRTOS/Source/tasks.c **** 		}
4063:FreeRTOS/Source/tasks.c **** 	}
4064:FreeRTOS/Source/tasks.c **** 
4065:FreeRTOS/Source/tasks.c **** #endif /* configUSE_MUTEXES */
4066:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4067:FreeRTOS/Source/tasks.c **** 
4068:FreeRTOS/Source/tasks.c **** #if ( portCRITICAL_NESTING_IN_TCB == 1 )
4069:FreeRTOS/Source/tasks.c **** 
4070:FreeRTOS/Source/tasks.c **** 	void vTaskEnterCritical( void )
4071:FreeRTOS/Source/tasks.c **** 	{
4072:FreeRTOS/Source/tasks.c **** 		portDISABLE_INTERRUPTS();
4073:FreeRTOS/Source/tasks.c **** 
4074:FreeRTOS/Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
4075:FreeRTOS/Source/tasks.c **** 		{
4076:FreeRTOS/Source/tasks.c **** 			( pxCurrentTCB->uxCriticalNesting )++;
4077:FreeRTOS/Source/tasks.c **** 
4078:FreeRTOS/Source/tasks.c **** 			/* This is not the interrupt safe version of the enter critical
4079:FreeRTOS/Source/tasks.c **** 			function so	assert() if it is being called from an interrupt
4080:FreeRTOS/Source/tasks.c **** 			context.  Only API functions that end in "FromISR" can be used in an
4081:FreeRTOS/Source/tasks.c **** 			interrupt.  Only assert if the critical nesting count is 1 to
4082:FreeRTOS/Source/tasks.c **** 			protect against recursive calls if the assert function also uses a
4083:FreeRTOS/Source/tasks.c **** 			critical section. */
4084:FreeRTOS/Source/tasks.c **** 			if( pxCurrentTCB->uxCriticalNesting == 1 )
4085:FreeRTOS/Source/tasks.c **** 			{
4086:FreeRTOS/Source/tasks.c **** 				portASSERT_IF_IN_ISR();
4087:FreeRTOS/Source/tasks.c **** 			}
4088:FreeRTOS/Source/tasks.c **** 		}
4089:FreeRTOS/Source/tasks.c **** 		else
4090:FreeRTOS/Source/tasks.c **** 		{
4091:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
4092:FreeRTOS/Source/tasks.c **** 		}
4093:FreeRTOS/Source/tasks.c **** 	}
4094:FreeRTOS/Source/tasks.c **** 
4095:FreeRTOS/Source/tasks.c **** #endif /* portCRITICAL_NESTING_IN_TCB */
4096:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4097:FreeRTOS/Source/tasks.c **** 
4098:FreeRTOS/Source/tasks.c **** #if ( portCRITICAL_NESTING_IN_TCB == 1 )
4099:FreeRTOS/Source/tasks.c **** 
4100:FreeRTOS/Source/tasks.c **** 	void vTaskExitCritical( void )
4101:FreeRTOS/Source/tasks.c **** 	{
4102:FreeRTOS/Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
4103:FreeRTOS/Source/tasks.c **** 		{
4104:FreeRTOS/Source/tasks.c **** 			if( pxCurrentTCB->uxCriticalNesting > 0U )
4105:FreeRTOS/Source/tasks.c **** 			{
4106:FreeRTOS/Source/tasks.c **** 				( pxCurrentTCB->uxCriticalNesting )--;
4107:FreeRTOS/Source/tasks.c **** 
4108:FreeRTOS/Source/tasks.c **** 				if( pxCurrentTCB->uxCriticalNesting == 0U )
4109:FreeRTOS/Source/tasks.c **** 				{
4110:FreeRTOS/Source/tasks.c **** 					portENABLE_INTERRUPTS();
4111:FreeRTOS/Source/tasks.c **** 				}
4112:FreeRTOS/Source/tasks.c **** 				else
4113:FreeRTOS/Source/tasks.c **** 				{
4114:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4115:FreeRTOS/Source/tasks.c **** 				}
4116:FreeRTOS/Source/tasks.c **** 			}
4117:FreeRTOS/Source/tasks.c **** 			else
4118:FreeRTOS/Source/tasks.c **** 			{
4119:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4120:FreeRTOS/Source/tasks.c **** 			}
4121:FreeRTOS/Source/tasks.c **** 		}
4122:FreeRTOS/Source/tasks.c **** 		else
4123:FreeRTOS/Source/tasks.c **** 		{
4124:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
4125:FreeRTOS/Source/tasks.c **** 		}
4126:FreeRTOS/Source/tasks.c **** 	}
4127:FreeRTOS/Source/tasks.c **** 
4128:FreeRTOS/Source/tasks.c **** #endif /* portCRITICAL_NESTING_IN_TCB */
4129:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4130:FreeRTOS/Source/tasks.c **** 
4131:FreeRTOS/Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
4132:FreeRTOS/Source/tasks.c **** 
4133:FreeRTOS/Source/tasks.c **** 	static char *prvWriteNameToBuffer( char *pcBuffer, const char *pcTaskName )
4134:FreeRTOS/Source/tasks.c **** 	{
4135:FreeRTOS/Source/tasks.c **** 	size_t x;
4136:FreeRTOS/Source/tasks.c **** 
4137:FreeRTOS/Source/tasks.c **** 		/* Start by copying the entire string. */
4138:FreeRTOS/Source/tasks.c **** 		strcpy( pcBuffer, pcTaskName );
4139:FreeRTOS/Source/tasks.c **** 
4140:FreeRTOS/Source/tasks.c **** 		/* Pad the end of the string with spaces to ensure columns line up when
4141:FreeRTOS/Source/tasks.c **** 		printed out. */
4142:FreeRTOS/Source/tasks.c **** 		for( x = strlen( pcBuffer ); x < ( size_t ) ( configMAX_TASK_NAME_LEN - 1 ); x++ )
4143:FreeRTOS/Source/tasks.c **** 		{
4144:FreeRTOS/Source/tasks.c **** 			pcBuffer[ x ] = ' ';
4145:FreeRTOS/Source/tasks.c **** 		}
4146:FreeRTOS/Source/tasks.c **** 
4147:FreeRTOS/Source/tasks.c **** 		/* Terminate. */
4148:FreeRTOS/Source/tasks.c **** 		pcBuffer[ x ] = 0x00;
4149:FreeRTOS/Source/tasks.c **** 
4150:FreeRTOS/Source/tasks.c **** 		/* Return the new end of string. */
4151:FreeRTOS/Source/tasks.c **** 		return &( pcBuffer[ x ] );
4152:FreeRTOS/Source/tasks.c **** 	}
4153:FreeRTOS/Source/tasks.c **** 
4154:FreeRTOS/Source/tasks.c **** #endif /* ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) */
4155:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4156:FreeRTOS/Source/tasks.c **** 
4157:FreeRTOS/Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( config
4158:FreeRTOS/Source/tasks.c **** 
4159:FreeRTOS/Source/tasks.c **** 	void vTaskList( char * pcWriteBuffer )
4160:FreeRTOS/Source/tasks.c **** 	{
4161:FreeRTOS/Source/tasks.c **** 	TaskStatus_t *pxTaskStatusArray;
4162:FreeRTOS/Source/tasks.c **** 	volatile UBaseType_t uxArraySize, x;
4163:FreeRTOS/Source/tasks.c **** 	char cStatus;
4164:FreeRTOS/Source/tasks.c **** 
4165:FreeRTOS/Source/tasks.c **** 		/*
4166:FreeRTOS/Source/tasks.c **** 		 * PLEASE NOTE:
4167:FreeRTOS/Source/tasks.c **** 		 *
4168:FreeRTOS/Source/tasks.c **** 		 * This function is provided for convenience only, and is used by many
4169:FreeRTOS/Source/tasks.c **** 		 * of the demo applications.  Do not consider it to be part of the
4170:FreeRTOS/Source/tasks.c **** 		 * scheduler.
4171:FreeRTOS/Source/tasks.c **** 		 *
4172:FreeRTOS/Source/tasks.c **** 		 * vTaskList() calls uxTaskGetSystemState(), then formats part of the
4173:FreeRTOS/Source/tasks.c **** 		 * uxTaskGetSystemState() output into a human readable table that
4174:FreeRTOS/Source/tasks.c **** 		 * displays task names, states and stack usage.
4175:FreeRTOS/Source/tasks.c **** 		 *
4176:FreeRTOS/Source/tasks.c **** 		 * vTaskList() has a dependency on the sprintf() C library function that
4177:FreeRTOS/Source/tasks.c **** 		 * might bloat the code size, use a lot of stack, and provide different
4178:FreeRTOS/Source/tasks.c **** 		 * results on different platforms.  An alternative, tiny, third party,
4179:FreeRTOS/Source/tasks.c **** 		 * and limited functionality implementation of sprintf() is provided in
4180:FreeRTOS/Source/tasks.c **** 		 * many of the FreeRTOS/Demo sub-directories in a file called
4181:FreeRTOS/Source/tasks.c **** 		 * printf-stdarg.c (note printf-stdarg.c does not provide a full
4182:FreeRTOS/Source/tasks.c **** 		 * snprintf() implementation!).
4183:FreeRTOS/Source/tasks.c **** 		 *
4184:FreeRTOS/Source/tasks.c **** 		 * It is recommended that production systems call uxTaskGetSystemState()
4185:FreeRTOS/Source/tasks.c **** 		 * directly to get access to raw stats data, rather than indirectly
4186:FreeRTOS/Source/tasks.c **** 		 * through a call to vTaskList().
4187:FreeRTOS/Source/tasks.c **** 		 */
4188:FreeRTOS/Source/tasks.c **** 
4189:FreeRTOS/Source/tasks.c **** 
4190:FreeRTOS/Source/tasks.c **** 		/* Make sure the write buffer does not contain a string. */
4191:FreeRTOS/Source/tasks.c **** 		*pcWriteBuffer = 0x00;
4192:FreeRTOS/Source/tasks.c **** 
4193:FreeRTOS/Source/tasks.c **** 		/* Take a snapshot of the number of tasks in case it changes while this
4194:FreeRTOS/Source/tasks.c **** 		function is executing. */
4195:FreeRTOS/Source/tasks.c **** 		uxArraySize = uxCurrentNumberOfTasks;
4196:FreeRTOS/Source/tasks.c **** 
4197:FreeRTOS/Source/tasks.c **** 		/* Allocate an array index for each task.  NOTE!  if
4198:FreeRTOS/Source/tasks.c **** 		configSUPPORT_DYNAMIC_ALLOCATION is set to 0 then pvPortMalloc() will
4199:FreeRTOS/Source/tasks.c **** 		equate to NULL. */
4200:FreeRTOS/Source/tasks.c **** 		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) );
4201:FreeRTOS/Source/tasks.c **** 
4202:FreeRTOS/Source/tasks.c **** 		if( pxTaskStatusArray != NULL )
4203:FreeRTOS/Source/tasks.c **** 		{
4204:FreeRTOS/Source/tasks.c **** 			/* Generate the (binary) data. */
4205:FreeRTOS/Source/tasks.c **** 			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, NULL );
4206:FreeRTOS/Source/tasks.c **** 
4207:FreeRTOS/Source/tasks.c **** 			/* Create a human readable table from the binary data. */
4208:FreeRTOS/Source/tasks.c **** 			for( x = 0; x < uxArraySize; x++ )
4209:FreeRTOS/Source/tasks.c **** 			{
4210:FreeRTOS/Source/tasks.c **** 				switch( pxTaskStatusArray[ x ].eCurrentState )
4211:FreeRTOS/Source/tasks.c **** 				{
4212:FreeRTOS/Source/tasks.c **** 					case eReady:		cStatus = tskREADY_CHAR;
4213:FreeRTOS/Source/tasks.c **** 										break;
4214:FreeRTOS/Source/tasks.c **** 
4215:FreeRTOS/Source/tasks.c **** 					case eBlocked:		cStatus = tskBLOCKED_CHAR;
4216:FreeRTOS/Source/tasks.c **** 										break;
4217:FreeRTOS/Source/tasks.c **** 
4218:FreeRTOS/Source/tasks.c **** 					case eSuspended:	cStatus = tskSUSPENDED_CHAR;
4219:FreeRTOS/Source/tasks.c **** 										break;
4220:FreeRTOS/Source/tasks.c **** 
4221:FreeRTOS/Source/tasks.c **** 					case eDeleted:		cStatus = tskDELETED_CHAR;
4222:FreeRTOS/Source/tasks.c **** 										break;
4223:FreeRTOS/Source/tasks.c **** 
4224:FreeRTOS/Source/tasks.c **** 					default:			/* Should not get here, but it is included
4225:FreeRTOS/Source/tasks.c **** 										to prevent static checking errors. */
4226:FreeRTOS/Source/tasks.c **** 										cStatus = 0x00;
4227:FreeRTOS/Source/tasks.c **** 										break;
4228:FreeRTOS/Source/tasks.c **** 				}
4229:FreeRTOS/Source/tasks.c **** 
4230:FreeRTOS/Source/tasks.c **** 				/* Write the task name to the string, padding with spaces so it
4231:FreeRTOS/Source/tasks.c **** 				can be printed in tabular form more easily. */
4232:FreeRTOS/Source/tasks.c **** 				pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
4233:FreeRTOS/Source/tasks.c **** 
4234:FreeRTOS/Source/tasks.c **** 				/* Write the rest of the string. */
4235:FreeRTOS/Source/tasks.c **** 				sprintf( pcWriteBuffer, "\t%c\t%u\t%u\t%u\r\n", cStatus, ( unsigned int ) pxTaskStatusArray[ x 
4236:FreeRTOS/Source/tasks.c **** 				pcWriteBuffer += strlen( pcWriteBuffer );
4237:FreeRTOS/Source/tasks.c **** 			}
4238:FreeRTOS/Source/tasks.c **** 
4239:FreeRTOS/Source/tasks.c **** 			/* Free the array again.  NOTE!  If configSUPPORT_DYNAMIC_ALLOCATION
4240:FreeRTOS/Source/tasks.c **** 			is 0 then vPortFree() will be #defined to nothing. */
4241:FreeRTOS/Source/tasks.c **** 			vPortFree( pxTaskStatusArray );
4242:FreeRTOS/Source/tasks.c **** 		}
4243:FreeRTOS/Source/tasks.c **** 		else
4244:FreeRTOS/Source/tasks.c **** 		{
4245:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
4246:FreeRTOS/Source/tasks.c **** 		}
4247:FreeRTOS/Source/tasks.c **** 	}
4248:FreeRTOS/Source/tasks.c **** 
4249:FreeRTOS/Source/tasks.c **** #endif /* ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( 
4250:FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
4251:FreeRTOS/Source/tasks.c **** 
4252:FreeRTOS/Source/tasks.c **** #if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( c
4253:FreeRTOS/Source/tasks.c **** 
4254:FreeRTOS/Source/tasks.c **** 	void vTaskGetRunTimeStats( char *pcWriteBuffer )
4255:FreeRTOS/Source/tasks.c **** 	{
4256:FreeRTOS/Source/tasks.c **** 	TaskStatus_t *pxTaskStatusArray;
4257:FreeRTOS/Source/tasks.c **** 	volatile UBaseType_t uxArraySize, x;
4258:FreeRTOS/Source/tasks.c **** 	uint32_t ulTotalTime, ulStatsAsPercentage;
4259:FreeRTOS/Source/tasks.c **** 
4260:FreeRTOS/Source/tasks.c **** 		#if( configUSE_TRACE_FACILITY != 1 )
4261:FreeRTOS/Source/tasks.c **** 		{
4262:FreeRTOS/Source/tasks.c **** 			#error configUSE_TRACE_FACILITY must also be set to 1 in FreeRTOSConfig.h to use vTaskGetRunTime
4263:FreeRTOS/Source/tasks.c **** 		}
4264:FreeRTOS/Source/tasks.c **** 		#endif
4265:FreeRTOS/Source/tasks.c **** 
4266:FreeRTOS/Source/tasks.c **** 		/*
4267:FreeRTOS/Source/tasks.c **** 		 * PLEASE NOTE:
4268:FreeRTOS/Source/tasks.c **** 		 *
4269:FreeRTOS/Source/tasks.c **** 		 * This function is provided for convenience only, and is used by many
4270:FreeRTOS/Source/tasks.c **** 		 * of the demo applications.  Do not consider it to be part of the
4271:FreeRTOS/Source/tasks.c **** 		 * scheduler.
4272:FreeRTOS/Source/tasks.c **** 		 *
4273:FreeRTOS/Source/tasks.c **** 		 * vTaskGetRunTimeStats() calls uxTaskGetSystemState(), then formats part
4274:FreeRTOS/Source/tasks.c **** 		 * of the uxTaskGetSystemState() output into a human readable table that
4275:FreeRTOS/Source/tasks.c **** 		 * displays the amount of time each task has spent in the Running state
4276:FreeRTOS/Source/tasks.c **** 		 * in both absolute and percentage terms.
4277:FreeRTOS/Source/tasks.c **** 		 *
4278:FreeRTOS/Source/tasks.c **** 		 * vTaskGetRunTimeStats() has a dependency on the sprintf() C library
4279:FreeRTOS/Source/tasks.c **** 		 * function that might bloat the code size, use a lot of stack, and
4280:FreeRTOS/Source/tasks.c **** 		 * provide different results on different platforms.  An alternative,
4281:FreeRTOS/Source/tasks.c **** 		 * tiny, third party, and limited functionality implementation of
4282:FreeRTOS/Source/tasks.c **** 		 * sprintf() is provided in many of the FreeRTOS/Demo sub-directories in
4283:FreeRTOS/Source/tasks.c **** 		 * a file called printf-stdarg.c (note printf-stdarg.c does not provide
4284:FreeRTOS/Source/tasks.c **** 		 * a full snprintf() implementation!).
4285:FreeRTOS/Source/tasks.c **** 		 *
4286:FreeRTOS/Source/tasks.c **** 		 * It is recommended that production systems call uxTaskGetSystemState()
4287:FreeRTOS/Source/tasks.c **** 		 * directly to get access to raw stats data, rather than indirectly
4288:FreeRTOS/Source/tasks.c **** 		 * through a call to vTaskGetRunTimeStats().
4289:FreeRTOS/Source/tasks.c **** 		 */
4290:FreeRTOS/Source/tasks.c **** 
4291:FreeRTOS/Source/tasks.c **** 		/* Make sure the write buffer does not contain a string. */
4292:FreeRTOS/Source/tasks.c **** 		*pcWriteBuffer = 0x00;
4293:FreeRTOS/Source/tasks.c **** 
4294:FreeRTOS/Source/tasks.c **** 		/* Take a snapshot of the number of tasks in case it changes while this
4295:FreeRTOS/Source/tasks.c **** 		function is executing. */
4296:FreeRTOS/Source/tasks.c **** 		uxArraySize = uxCurrentNumberOfTasks;
4297:FreeRTOS/Source/tasks.c **** 
4298:FreeRTOS/Source/tasks.c **** 		/* Allocate an array index for each task.  NOTE!  If
4299:FreeRTOS/Source/tasks.c **** 		configSUPPORT_DYNAMIC_ALLOCATION is set to 0 then pvPortMalloc() will
4300:FreeRTOS/Source/tasks.c **** 		equate to NULL. */
4301:FreeRTOS/Source/tasks.c **** 		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) );
4302:FreeRTOS/Source/tasks.c **** 
4303:FreeRTOS/Source/tasks.c **** 		if( pxTaskStatusArray != NULL )
4304:FreeRTOS/Source/tasks.c **** 		{
4305:FreeRTOS/Source/tasks.c **** 			/* Generate the (binary) data. */
4306:FreeRTOS/Source/tasks.c **** 			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, &ulTotalTime );
4307:FreeRTOS/Source/tasks.c **** 
4308:FreeRTOS/Source/tasks.c **** 			/* For percentage calculations. */
4309:FreeRTOS/Source/tasks.c **** 			ulTotalTime /= 100UL;
4310:FreeRTOS/Source/tasks.c **** 
4311:FreeRTOS/Source/tasks.c **** 			/* Avoid divide by zero errors. */
4312:FreeRTOS/Source/tasks.c **** 			if( ulTotalTime > 0 )
4313:FreeRTOS/Source/tasks.c **** 			{
4314:FreeRTOS/Source/tasks.c **** 				/* Create a human readable table from the binary data. */
4315:FreeRTOS/Source/tasks.c **** 				for( x = 0; x < uxArraySize; x++ )
4316:FreeRTOS/Source/tasks.c **** 				{
4317:FreeRTOS/Source/tasks.c **** 					/* What percentage of the total run time has the task used?
4318:FreeRTOS/Source/tasks.c **** 					This will always be rounded down to the nearest integer.
4319:FreeRTOS/Source/tasks.c **** 					ulTotalRunTimeDiv100 has already been divided by 100. */
4320:FreeRTOS/Source/tasks.c **** 					ulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCounter / ulTotalTime;
4321:FreeRTOS/Source/tasks.c **** 
4322:FreeRTOS/Source/tasks.c **** 					/* Write the task name to the string, padding with
4323:FreeRTOS/Source/tasks.c **** 					spaces so it can be printed in tabular form more
4324:FreeRTOS/Source/tasks.c **** 					easily. */
4325:FreeRTOS/Source/tasks.c **** 					pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
4326:FreeRTOS/Source/tasks.c **** 
4327:FreeRTOS/Source/tasks.c **** 					if( ulStatsAsPercentage > 0UL )
4328:FreeRTOS/Source/tasks.c **** 					{
4329:FreeRTOS/Source/tasks.c **** 						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
4330:FreeRTOS/Source/tasks.c **** 						{
4331:FreeRTOS/Source/tasks.c **** 							sprintf( pcWriteBuffer, "\t%lu\t\t%lu%%\r\n", pxTaskStatusArray[ x ].ulRunTimeCounter, ulSta
4332:FreeRTOS/Source/tasks.c **** 						}
4333:FreeRTOS/Source/tasks.c **** 						#else
4334:FreeRTOS/Source/tasks.c **** 						{
4335:FreeRTOS/Source/tasks.c **** 							/* sizeof( int ) == sizeof( long ) so a smaller
4336:FreeRTOS/Source/tasks.c **** 							printf() library can be used. */
4337:FreeRTOS/Source/tasks.c **** 							sprintf( pcWriteBuffer, "\t%u\t\t%u%%\r\n", ( unsigned int ) pxTaskStatusArray[ x ].ulRunTim
4338:FreeRTOS/Source/tasks.c **** 						}
4339:FreeRTOS/Source/tasks.c **** 						#endif
4340:FreeRTOS/Source/tasks.c **** 					}
4341:FreeRTOS/Source/tasks.c **** 					else
4342:FreeRTOS/Source/tasks.c **** 					{
4343:FreeRTOS/Source/tasks.c **** 						/* If the percentage is zero here then the task has
4344:FreeRTOS/Source/tasks.c **** 						consumed less than 1% of the total run time. */
4345:FreeRTOS/Source/tasks.c **** 						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
4346:FreeRTOS/Source/tasks.c **** 						{
4347:FreeRTOS/Source/tasks.c **** 							sprintf( pcWriteBuffer, "\t%lu\t\t<1%%\r\n", pxTaskStatusArray[ x ].ulRunTimeCounter );
4348:FreeRTOS/Source/tasks.c **** 						}
4349:FreeRTOS/Source/tasks.c **** 						#else
4350:FreeRTOS/Source/tasks.c **** 						{
4351:FreeRTOS/Source/tasks.c **** 							/* sizeof( int ) == sizeof( long ) so a smaller
4352:FreeRTOS/Source/tasks.c **** 							printf() library can be used. */
4353:FreeRTOS/Source/tasks.c **** 							sprintf( pcWriteBuffer, "\t%u\t\t<1%%\r\n", ( unsigned int ) pxTaskStatusArray[ x ].ulRunTim
4354:FreeRTOS/Source/tasks.c **** 						}
4355:FreeRTOS/Source/tasks.c **** 						#endif
4356:FreeRTOS/Source/tasks.c **** 					}
4357:FreeRTOS/Source/tasks.c **** 
4358:FreeRTOS/Source/tasks.c **** 					pcWriteBuffer += strlen( pcWriteBuffer );
4359:FreeRTOS/Source/tasks.c **** 				}
4360:FreeRTOS/Source/tasks.c **** 			}
4361:FreeRTOS/Source/tasks.c **** 			else
4362:FreeRTOS/Source/tasks.c **** 			{
4363:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4364:FreeRTOS/Source/tasks.c **** 			}
4365:FreeRTOS/Source/tasks.c **** 
4366:FreeRTOS/Source/tasks.c **** 			/* Free the array again.  NOTE!  If configSUPPORT_DYNAMIC_ALLOCATION
4367:FreeRTOS/Source/tasks.c **** 			is 0 then vPortFree() will be #defined to nothing. */
4368:FreeRTOS/Source/tasks.c **** 			vPortFree( pxTaskStatusArray );
4369:FreeRTOS/Source/tasks.c **** 		}
4370:FreeRTOS/Source/tasks.c **** 		else
4371:FreeRTOS/Source/tasks.c **** 		{
4372:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
4373:FreeRTOS/Source/tasks.c **** 		}
4374:FreeRTOS/Source/tasks.c **** 	}
4375:FreeRTOS/Source/tasks.c **** 
4376:FreeRTOS/Source/tasks.c **** #endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) 
4377:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4378:FreeRTOS/Source/tasks.c **** 
4379:FreeRTOS/Source/tasks.c **** TickType_t uxTaskResetEventItemValue( void )
4380:FreeRTOS/Source/tasks.c **** {
4381:FreeRTOS/Source/tasks.c **** TickType_t uxReturn;
4382:FreeRTOS/Source/tasks.c **** 
4383:FreeRTOS/Source/tasks.c **** 	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
4384:FreeRTOS/Source/tasks.c **** 
4385:FreeRTOS/Source/tasks.c **** 	/* Reset the event list item to its normal value - so it can be used with
4386:FreeRTOS/Source/tasks.c **** 	queues and semaphores. */
4387:FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES 
4388:FreeRTOS/Source/tasks.c **** 
4389:FreeRTOS/Source/tasks.c **** 	return uxReturn;
4390:FreeRTOS/Source/tasks.c **** }
4391:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4392:FreeRTOS/Source/tasks.c **** 
4393:FreeRTOS/Source/tasks.c **** #if ( configUSE_MUTEXES == 1 )
4394:FreeRTOS/Source/tasks.c **** 
4395:FreeRTOS/Source/tasks.c **** 	void *pvTaskIncrementMutexHeldCount( void )
4396:FreeRTOS/Source/tasks.c **** 	{
4397:FreeRTOS/Source/tasks.c **** 		/* If xSemaphoreCreateMutex() is called before any tasks have been created
4398:FreeRTOS/Source/tasks.c **** 		then pxCurrentTCB will be NULL. */
4399:FreeRTOS/Source/tasks.c **** 		if( pxCurrentTCB != NULL )
4400:FreeRTOS/Source/tasks.c **** 		{
4401:FreeRTOS/Source/tasks.c **** 			( pxCurrentTCB->uxMutexesHeld )++;
4402:FreeRTOS/Source/tasks.c **** 		}
4403:FreeRTOS/Source/tasks.c **** 
4404:FreeRTOS/Source/tasks.c **** 		return pxCurrentTCB;
4405:FreeRTOS/Source/tasks.c **** 	}
4406:FreeRTOS/Source/tasks.c **** 
4407:FreeRTOS/Source/tasks.c **** #endif /* configUSE_MUTEXES */
4408:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4409:FreeRTOS/Source/tasks.c **** 
4410:FreeRTOS/Source/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
4411:FreeRTOS/Source/tasks.c **** 
4412:FreeRTOS/Source/tasks.c **** 	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
4413:FreeRTOS/Source/tasks.c **** 	{
4414:FreeRTOS/Source/tasks.c **** 	uint32_t ulReturn;
4415:FreeRTOS/Source/tasks.c **** 
4416:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
4417:FreeRTOS/Source/tasks.c **** 		{
4418:FreeRTOS/Source/tasks.c **** 			/* Only block if the notification count is not already non-zero. */
4419:FreeRTOS/Source/tasks.c **** 			if( pxCurrentTCB->ulNotifiedValue == 0UL )
4420:FreeRTOS/Source/tasks.c **** 			{
4421:FreeRTOS/Source/tasks.c **** 				/* Mark this task as waiting for a notification. */
4422:FreeRTOS/Source/tasks.c **** 				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
4423:FreeRTOS/Source/tasks.c **** 
4424:FreeRTOS/Source/tasks.c **** 				if( xTicksToWait > ( TickType_t ) 0 )
4425:FreeRTOS/Source/tasks.c **** 				{
4426:FreeRTOS/Source/tasks.c **** 					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
4427:FreeRTOS/Source/tasks.c **** 					traceTASK_NOTIFY_TAKE_BLOCK();
4428:FreeRTOS/Source/tasks.c **** 
4429:FreeRTOS/Source/tasks.c **** 					/* All ports are written to allow a yield in a critical
4430:FreeRTOS/Source/tasks.c **** 					section (some will yield immediately, others wait until the
4431:FreeRTOS/Source/tasks.c **** 					critical section exits) - but it is not something that
4432:FreeRTOS/Source/tasks.c **** 					application code should ever do. */
4433:FreeRTOS/Source/tasks.c **** 					portYIELD_WITHIN_API();
4434:FreeRTOS/Source/tasks.c **** 				}
4435:FreeRTOS/Source/tasks.c **** 				else
4436:FreeRTOS/Source/tasks.c **** 				{
4437:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4438:FreeRTOS/Source/tasks.c **** 				}
4439:FreeRTOS/Source/tasks.c **** 			}
4440:FreeRTOS/Source/tasks.c **** 			else
4441:FreeRTOS/Source/tasks.c **** 			{
4442:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4443:FreeRTOS/Source/tasks.c **** 			}
4444:FreeRTOS/Source/tasks.c **** 		}
4445:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
4446:FreeRTOS/Source/tasks.c **** 
4447:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
4448:FreeRTOS/Source/tasks.c **** 		{
4449:FreeRTOS/Source/tasks.c **** 			traceTASK_NOTIFY_TAKE();
4450:FreeRTOS/Source/tasks.c **** 			ulReturn = pxCurrentTCB->ulNotifiedValue;
4451:FreeRTOS/Source/tasks.c **** 
4452:FreeRTOS/Source/tasks.c **** 			if( ulReturn != 0UL )
4453:FreeRTOS/Source/tasks.c **** 			{
4454:FreeRTOS/Source/tasks.c **** 				if( xClearCountOnExit != pdFALSE )
4455:FreeRTOS/Source/tasks.c **** 				{
4456:FreeRTOS/Source/tasks.c **** 					pxCurrentTCB->ulNotifiedValue = 0UL;
4457:FreeRTOS/Source/tasks.c **** 				}
4458:FreeRTOS/Source/tasks.c **** 				else
4459:FreeRTOS/Source/tasks.c **** 				{
4460:FreeRTOS/Source/tasks.c **** 					pxCurrentTCB->ulNotifiedValue = ulReturn - ( uint32_t ) 1;
4461:FreeRTOS/Source/tasks.c **** 				}
4462:FreeRTOS/Source/tasks.c **** 			}
4463:FreeRTOS/Source/tasks.c **** 			else
4464:FreeRTOS/Source/tasks.c **** 			{
4465:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4466:FreeRTOS/Source/tasks.c **** 			}
4467:FreeRTOS/Source/tasks.c **** 
4468:FreeRTOS/Source/tasks.c **** 			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
4469:FreeRTOS/Source/tasks.c **** 		}
4470:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
4471:FreeRTOS/Source/tasks.c **** 
4472:FreeRTOS/Source/tasks.c **** 		return ulReturn;
4473:FreeRTOS/Source/tasks.c **** 	}
4474:FreeRTOS/Source/tasks.c **** 
4475:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
4476:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4477:FreeRTOS/Source/tasks.c **** 
4478:FreeRTOS/Source/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
4479:FreeRTOS/Source/tasks.c **** 
4480:FreeRTOS/Source/tasks.c **** 	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t 
4481:FreeRTOS/Source/tasks.c **** 	{
4482:FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn;
4483:FreeRTOS/Source/tasks.c **** 
4484:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
4485:FreeRTOS/Source/tasks.c **** 		{
4486:FreeRTOS/Source/tasks.c **** 			/* Only block if a notification is not already pending. */
4487:FreeRTOS/Source/tasks.c **** 			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
4488:FreeRTOS/Source/tasks.c **** 			{
4489:FreeRTOS/Source/tasks.c **** 				/* Clear bits in the task's notification value as bits may get
4490:FreeRTOS/Source/tasks.c **** 				set	by the notifying task or interrupt.  This can be used to
4491:FreeRTOS/Source/tasks.c **** 				clear the value to zero. */
4492:FreeRTOS/Source/tasks.c **** 				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
4493:FreeRTOS/Source/tasks.c **** 
4494:FreeRTOS/Source/tasks.c **** 				/* Mark this task as waiting for a notification. */
4495:FreeRTOS/Source/tasks.c **** 				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
4496:FreeRTOS/Source/tasks.c **** 
4497:FreeRTOS/Source/tasks.c **** 				if( xTicksToWait > ( TickType_t ) 0 )
4498:FreeRTOS/Source/tasks.c **** 				{
4499:FreeRTOS/Source/tasks.c **** 					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
4500:FreeRTOS/Source/tasks.c **** 					traceTASK_NOTIFY_WAIT_BLOCK();
4501:FreeRTOS/Source/tasks.c **** 
4502:FreeRTOS/Source/tasks.c **** 					/* All ports are written to allow a yield in a critical
4503:FreeRTOS/Source/tasks.c **** 					section (some will yield immediately, others wait until the
4504:FreeRTOS/Source/tasks.c **** 					critical section exits) - but it is not something that
4505:FreeRTOS/Source/tasks.c **** 					application code should ever do. */
4506:FreeRTOS/Source/tasks.c **** 					portYIELD_WITHIN_API();
4507:FreeRTOS/Source/tasks.c **** 				}
4508:FreeRTOS/Source/tasks.c **** 				else
4509:FreeRTOS/Source/tasks.c **** 				{
4510:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4511:FreeRTOS/Source/tasks.c **** 				}
4512:FreeRTOS/Source/tasks.c **** 			}
4513:FreeRTOS/Source/tasks.c **** 			else
4514:FreeRTOS/Source/tasks.c **** 			{
4515:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4516:FreeRTOS/Source/tasks.c **** 			}
4517:FreeRTOS/Source/tasks.c **** 		}
4518:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
4519:FreeRTOS/Source/tasks.c **** 
4520:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
4521:FreeRTOS/Source/tasks.c **** 		{
4522:FreeRTOS/Source/tasks.c **** 			traceTASK_NOTIFY_WAIT();
4523:FreeRTOS/Source/tasks.c **** 
4524:FreeRTOS/Source/tasks.c **** 			if( pulNotificationValue != NULL )
4525:FreeRTOS/Source/tasks.c **** 			{
4526:FreeRTOS/Source/tasks.c **** 				/* Output the current notification value, which may or may not
4527:FreeRTOS/Source/tasks.c **** 				have changed. */
4528:FreeRTOS/Source/tasks.c **** 				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
4529:FreeRTOS/Source/tasks.c **** 			}
4530:FreeRTOS/Source/tasks.c **** 
4531:FreeRTOS/Source/tasks.c **** 			/* If ucNotifyValue is set then either the task never entered the
4532:FreeRTOS/Source/tasks.c **** 			blocked state (because a notification was already pending) or the
4533:FreeRTOS/Source/tasks.c **** 			task unblocked because of a notification.  Otherwise the task
4534:FreeRTOS/Source/tasks.c **** 			unblocked because of a timeout. */
4535:FreeRTOS/Source/tasks.c **** 			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
4536:FreeRTOS/Source/tasks.c **** 			{
4537:FreeRTOS/Source/tasks.c **** 				/* A notification was not received. */
4538:FreeRTOS/Source/tasks.c **** 				xReturn = pdFALSE;
4539:FreeRTOS/Source/tasks.c **** 			}
4540:FreeRTOS/Source/tasks.c **** 			else
4541:FreeRTOS/Source/tasks.c **** 			{
4542:FreeRTOS/Source/tasks.c **** 				/* A notification was already pending or a notification was
4543:FreeRTOS/Source/tasks.c **** 				received while the task was waiting. */
4544:FreeRTOS/Source/tasks.c **** 				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
4545:FreeRTOS/Source/tasks.c **** 				xReturn = pdTRUE;
4546:FreeRTOS/Source/tasks.c **** 			}
4547:FreeRTOS/Source/tasks.c **** 
4548:FreeRTOS/Source/tasks.c **** 			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
4549:FreeRTOS/Source/tasks.c **** 		}
4550:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
4551:FreeRTOS/Source/tasks.c **** 
4552:FreeRTOS/Source/tasks.c **** 		return xReturn;
4553:FreeRTOS/Source/tasks.c **** 	}
4554:FreeRTOS/Source/tasks.c **** 
4555:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
4556:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4557:FreeRTOS/Source/tasks.c **** 
4558:FreeRTOS/Source/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
4559:FreeRTOS/Source/tasks.c **** 
4560:FreeRTOS/Source/tasks.c **** 	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction
4561:FreeRTOS/Source/tasks.c **** 	{
4562:FreeRTOS/Source/tasks.c **** 	TCB_t * pxTCB;
4563:FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn = pdPASS;
4564:FreeRTOS/Source/tasks.c **** 	uint8_t ucOriginalNotifyState;
4565:FreeRTOS/Source/tasks.c **** 
4566:FreeRTOS/Source/tasks.c **** 		configASSERT( xTaskToNotify );
4567:FreeRTOS/Source/tasks.c **** 		pxTCB = ( TCB_t * ) xTaskToNotify;
4568:FreeRTOS/Source/tasks.c **** 
4569:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
4570:FreeRTOS/Source/tasks.c **** 		{
4571:FreeRTOS/Source/tasks.c **** 			if( pulPreviousNotificationValue != NULL )
4572:FreeRTOS/Source/tasks.c **** 			{
4573:FreeRTOS/Source/tasks.c **** 				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
4574:FreeRTOS/Source/tasks.c **** 			}
4575:FreeRTOS/Source/tasks.c **** 
4576:FreeRTOS/Source/tasks.c **** 			ucOriginalNotifyState = pxTCB->ucNotifyState;
4577:FreeRTOS/Source/tasks.c **** 
4578:FreeRTOS/Source/tasks.c **** 			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
4579:FreeRTOS/Source/tasks.c **** 
4580:FreeRTOS/Source/tasks.c **** 			switch( eAction )
4581:FreeRTOS/Source/tasks.c **** 			{
4582:FreeRTOS/Source/tasks.c **** 				case eSetBits	:
4583:FreeRTOS/Source/tasks.c **** 					pxTCB->ulNotifiedValue |= ulValue;
4584:FreeRTOS/Source/tasks.c **** 					break;
4585:FreeRTOS/Source/tasks.c **** 
4586:FreeRTOS/Source/tasks.c **** 				case eIncrement	:
4587:FreeRTOS/Source/tasks.c **** 					( pxTCB->ulNotifiedValue )++;
4588:FreeRTOS/Source/tasks.c **** 					break;
4589:FreeRTOS/Source/tasks.c **** 
4590:FreeRTOS/Source/tasks.c **** 				case eSetValueWithOverwrite	:
4591:FreeRTOS/Source/tasks.c **** 					pxTCB->ulNotifiedValue = ulValue;
4592:FreeRTOS/Source/tasks.c **** 					break;
4593:FreeRTOS/Source/tasks.c **** 
4594:FreeRTOS/Source/tasks.c **** 				case eSetValueWithoutOverwrite :
4595:FreeRTOS/Source/tasks.c **** 					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
4596:FreeRTOS/Source/tasks.c **** 					{
4597:FreeRTOS/Source/tasks.c **** 						pxTCB->ulNotifiedValue = ulValue;
4598:FreeRTOS/Source/tasks.c **** 					}
4599:FreeRTOS/Source/tasks.c **** 					else
4600:FreeRTOS/Source/tasks.c **** 					{
4601:FreeRTOS/Source/tasks.c **** 						/* The value could not be written to the task. */
4602:FreeRTOS/Source/tasks.c **** 						xReturn = pdFAIL;
4603:FreeRTOS/Source/tasks.c **** 					}
4604:FreeRTOS/Source/tasks.c **** 					break;
4605:FreeRTOS/Source/tasks.c **** 
4606:FreeRTOS/Source/tasks.c **** 				case eNoAction:
4607:FreeRTOS/Source/tasks.c **** 					/* The task is being notified without its notify value being
4608:FreeRTOS/Source/tasks.c **** 					updated. */
4609:FreeRTOS/Source/tasks.c **** 					break;
4610:FreeRTOS/Source/tasks.c **** 			}
4611:FreeRTOS/Source/tasks.c **** 
4612:FreeRTOS/Source/tasks.c **** 			traceTASK_NOTIFY();
4613:FreeRTOS/Source/tasks.c **** 
4614:FreeRTOS/Source/tasks.c **** 			/* If the task is in the blocked state specifically to wait for a
4615:FreeRTOS/Source/tasks.c **** 			notification then unblock it now. */
4616:FreeRTOS/Source/tasks.c **** 			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
4617:FreeRTOS/Source/tasks.c **** 			{
4618:FreeRTOS/Source/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
4619:FreeRTOS/Source/tasks.c **** 				prvAddTaskToReadyList( pxTCB );
4620:FreeRTOS/Source/tasks.c **** 
4621:FreeRTOS/Source/tasks.c **** 				/* The task should not have been on an event list. */
4622:FreeRTOS/Source/tasks.c **** 				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
4623:FreeRTOS/Source/tasks.c **** 
4624:FreeRTOS/Source/tasks.c **** 				#if( configUSE_TICKLESS_IDLE != 0 )
4625:FreeRTOS/Source/tasks.c **** 				{
4626:FreeRTOS/Source/tasks.c **** 					/* If a task is blocked waiting for a notification then
4627:FreeRTOS/Source/tasks.c **** 					xNextTaskUnblockTime might be set to the blocked task's time
4628:FreeRTOS/Source/tasks.c **** 					out time.  If the task is unblocked for a reason other than
4629:FreeRTOS/Source/tasks.c **** 					a timeout xNextTaskUnblockTime is normally left unchanged,
4630:FreeRTOS/Source/tasks.c **** 					because it will automatically get reset to a new value when
4631:FreeRTOS/Source/tasks.c **** 					the tick count equals xNextTaskUnblockTime.  However if
4632:FreeRTOS/Source/tasks.c **** 					tickless idling is used it might be more important to enter
4633:FreeRTOS/Source/tasks.c **** 					sleep mode at the earliest possible time - so reset
4634:FreeRTOS/Source/tasks.c **** 					xNextTaskUnblockTime here to ensure it is updated at the
4635:FreeRTOS/Source/tasks.c **** 					earliest possible time. */
4636:FreeRTOS/Source/tasks.c **** 					prvResetNextTaskUnblockTime();
4637:FreeRTOS/Source/tasks.c **** 				}
4638:FreeRTOS/Source/tasks.c **** 				#endif
4639:FreeRTOS/Source/tasks.c **** 
4640:FreeRTOS/Source/tasks.c **** 				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
4641:FreeRTOS/Source/tasks.c **** 				{
4642:FreeRTOS/Source/tasks.c **** 					/* The notified task has a priority above the currently
4643:FreeRTOS/Source/tasks.c **** 					executing task so a yield is required. */
4644:FreeRTOS/Source/tasks.c **** 					taskYIELD_IF_USING_PREEMPTION();
4645:FreeRTOS/Source/tasks.c **** 				}
4646:FreeRTOS/Source/tasks.c **** 				else
4647:FreeRTOS/Source/tasks.c **** 				{
4648:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4649:FreeRTOS/Source/tasks.c **** 				}
4650:FreeRTOS/Source/tasks.c **** 			}
4651:FreeRTOS/Source/tasks.c **** 			else
4652:FreeRTOS/Source/tasks.c **** 			{
4653:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4654:FreeRTOS/Source/tasks.c **** 			}
4655:FreeRTOS/Source/tasks.c **** 		}
4656:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
4657:FreeRTOS/Source/tasks.c **** 
4658:FreeRTOS/Source/tasks.c **** 		return xReturn;
4659:FreeRTOS/Source/tasks.c **** 	}
4660:FreeRTOS/Source/tasks.c **** 
4661:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
4662:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4663:FreeRTOS/Source/tasks.c **** 
4664:FreeRTOS/Source/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
4665:FreeRTOS/Source/tasks.c **** 
4666:FreeRTOS/Source/tasks.c **** 	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction 
4667:FreeRTOS/Source/tasks.c **** 	{
4668:FreeRTOS/Source/tasks.c **** 	TCB_t * pxTCB;
4669:FreeRTOS/Source/tasks.c **** 	uint8_t ucOriginalNotifyState;
4670:FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn = pdPASS;
4671:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxSavedInterruptStatus;
4672:FreeRTOS/Source/tasks.c **** 
4673:FreeRTOS/Source/tasks.c **** 		configASSERT( xTaskToNotify );
4674:FreeRTOS/Source/tasks.c **** 
4675:FreeRTOS/Source/tasks.c **** 		/* RTOS ports that support interrupt nesting have the concept of a
4676:FreeRTOS/Source/tasks.c **** 		maximum	system call (or maximum API call) interrupt priority.
4677:FreeRTOS/Source/tasks.c **** 		Interrupts that are	above the maximum system call priority are keep
4678:FreeRTOS/Source/tasks.c **** 		permanently enabled, even when the RTOS kernel is in a critical section,
4679:FreeRTOS/Source/tasks.c **** 		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
4680:FreeRTOS/Source/tasks.c **** 		is defined in FreeRTOSConfig.h then
4681:FreeRTOS/Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
4682:FreeRTOS/Source/tasks.c **** 		failure if a FreeRTOS API function is called from an interrupt that has
4683:FreeRTOS/Source/tasks.c **** 		been assigned a priority above the configured maximum system call
4684:FreeRTOS/Source/tasks.c **** 		priority.  Only FreeRTOS functions that end in FromISR can be called
4685:FreeRTOS/Source/tasks.c **** 		from interrupts	that have been assigned a priority at or (logically)
4686:FreeRTOS/Source/tasks.c **** 		below the maximum system call interrupt priority.  FreeRTOS maintains a
4687:FreeRTOS/Source/tasks.c **** 		separate interrupt safe API to ensure interrupt entry is as fast and as
4688:FreeRTOS/Source/tasks.c **** 		simple as possible.  More information (albeit Cortex-M specific) is
4689:FreeRTOS/Source/tasks.c **** 		provided on the following link:
4690:FreeRTOS/Source/tasks.c **** 		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
4691:FreeRTOS/Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
4692:FreeRTOS/Source/tasks.c **** 
4693:FreeRTOS/Source/tasks.c **** 		pxTCB = ( TCB_t * ) xTaskToNotify;
4694:FreeRTOS/Source/tasks.c **** 
4695:FreeRTOS/Source/tasks.c **** 		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
4696:FreeRTOS/Source/tasks.c **** 		{
4697:FreeRTOS/Source/tasks.c **** 			if( pulPreviousNotificationValue != NULL )
4698:FreeRTOS/Source/tasks.c **** 			{
4699:FreeRTOS/Source/tasks.c **** 				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
4700:FreeRTOS/Source/tasks.c **** 			}
4701:FreeRTOS/Source/tasks.c **** 
4702:FreeRTOS/Source/tasks.c **** 			ucOriginalNotifyState = pxTCB->ucNotifyState;
4703:FreeRTOS/Source/tasks.c **** 			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
4704:FreeRTOS/Source/tasks.c **** 
4705:FreeRTOS/Source/tasks.c **** 			switch( eAction )
4706:FreeRTOS/Source/tasks.c **** 			{
4707:FreeRTOS/Source/tasks.c **** 				case eSetBits	:
4708:FreeRTOS/Source/tasks.c **** 					pxTCB->ulNotifiedValue |= ulValue;
4709:FreeRTOS/Source/tasks.c **** 					break;
4710:FreeRTOS/Source/tasks.c **** 
4711:FreeRTOS/Source/tasks.c **** 				case eIncrement	:
4712:FreeRTOS/Source/tasks.c **** 					( pxTCB->ulNotifiedValue )++;
4713:FreeRTOS/Source/tasks.c **** 					break;
4714:FreeRTOS/Source/tasks.c **** 
4715:FreeRTOS/Source/tasks.c **** 				case eSetValueWithOverwrite	:
4716:FreeRTOS/Source/tasks.c **** 					pxTCB->ulNotifiedValue = ulValue;
4717:FreeRTOS/Source/tasks.c **** 					break;
4718:FreeRTOS/Source/tasks.c **** 
4719:FreeRTOS/Source/tasks.c **** 				case eSetValueWithoutOverwrite :
4720:FreeRTOS/Source/tasks.c **** 					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
4721:FreeRTOS/Source/tasks.c **** 					{
4722:FreeRTOS/Source/tasks.c **** 						pxTCB->ulNotifiedValue = ulValue;
4723:FreeRTOS/Source/tasks.c **** 					}
4724:FreeRTOS/Source/tasks.c **** 					else
4725:FreeRTOS/Source/tasks.c **** 					{
4726:FreeRTOS/Source/tasks.c **** 						/* The value could not be written to the task. */
4727:FreeRTOS/Source/tasks.c **** 						xReturn = pdFAIL;
4728:FreeRTOS/Source/tasks.c **** 					}
4729:FreeRTOS/Source/tasks.c **** 					break;
4730:FreeRTOS/Source/tasks.c **** 
4731:FreeRTOS/Source/tasks.c **** 				case eNoAction :
4732:FreeRTOS/Source/tasks.c **** 					/* The task is being notified without its notify value being
4733:FreeRTOS/Source/tasks.c **** 					updated. */
4734:FreeRTOS/Source/tasks.c **** 					break;
4735:FreeRTOS/Source/tasks.c **** 			}
4736:FreeRTOS/Source/tasks.c **** 
4737:FreeRTOS/Source/tasks.c **** 			traceTASK_NOTIFY_FROM_ISR();
4738:FreeRTOS/Source/tasks.c **** 
4739:FreeRTOS/Source/tasks.c **** 			/* If the task is in the blocked state specifically to wait for a
4740:FreeRTOS/Source/tasks.c **** 			notification then unblock it now. */
4741:FreeRTOS/Source/tasks.c **** 			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
4742:FreeRTOS/Source/tasks.c **** 			{
4743:FreeRTOS/Source/tasks.c **** 				/* The task should not have been on an event list. */
4744:FreeRTOS/Source/tasks.c **** 				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
4745:FreeRTOS/Source/tasks.c **** 
4746:FreeRTOS/Source/tasks.c **** 				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
4747:FreeRTOS/Source/tasks.c **** 				{
4748:FreeRTOS/Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
4749:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
4750:FreeRTOS/Source/tasks.c **** 				}
4751:FreeRTOS/Source/tasks.c **** 				else
4752:FreeRTOS/Source/tasks.c **** 				{
4753:FreeRTOS/Source/tasks.c **** 					/* The delayed and ready lists cannot be accessed, so hold
4754:FreeRTOS/Source/tasks.c **** 					this task pending until the scheduler is resumed. */
4755:FreeRTOS/Source/tasks.c **** 					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
4756:FreeRTOS/Source/tasks.c **** 				}
4757:FreeRTOS/Source/tasks.c **** 
4758:FreeRTOS/Source/tasks.c **** 				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
4759:FreeRTOS/Source/tasks.c **** 				{
4760:FreeRTOS/Source/tasks.c **** 					/* The notified task has a priority above the currently
4761:FreeRTOS/Source/tasks.c **** 					executing task so a yield is required. */
4762:FreeRTOS/Source/tasks.c **** 					if( pxHigherPriorityTaskWoken != NULL )
4763:FreeRTOS/Source/tasks.c **** 					{
4764:FreeRTOS/Source/tasks.c **** 						*pxHigherPriorityTaskWoken = pdTRUE;
4765:FreeRTOS/Source/tasks.c **** 					}
4766:FreeRTOS/Source/tasks.c **** 					else
4767:FreeRTOS/Source/tasks.c **** 					{
4768:FreeRTOS/Source/tasks.c **** 						/* Mark that a yield is pending in case the user is not
4769:FreeRTOS/Source/tasks.c **** 						using the "xHigherPriorityTaskWoken" parameter to an ISR
4770:FreeRTOS/Source/tasks.c **** 						safe FreeRTOS function. */
4771:FreeRTOS/Source/tasks.c **** 						xYieldPending = pdTRUE;
4772:FreeRTOS/Source/tasks.c **** 					}
4773:FreeRTOS/Source/tasks.c **** 				}
4774:FreeRTOS/Source/tasks.c **** 				else
4775:FreeRTOS/Source/tasks.c **** 				{
4776:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4777:FreeRTOS/Source/tasks.c **** 				}
4778:FreeRTOS/Source/tasks.c **** 			}
4779:FreeRTOS/Source/tasks.c **** 		}
4780:FreeRTOS/Source/tasks.c **** 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
4781:FreeRTOS/Source/tasks.c **** 
4782:FreeRTOS/Source/tasks.c **** 		return xReturn;
4783:FreeRTOS/Source/tasks.c **** 	}
4784:FreeRTOS/Source/tasks.c **** 
4785:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
4786:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4787:FreeRTOS/Source/tasks.c **** 
4788:FreeRTOS/Source/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
4789:FreeRTOS/Source/tasks.c **** 
4790:FreeRTOS/Source/tasks.c **** 	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
4791:FreeRTOS/Source/tasks.c **** 	{
4792:FreeRTOS/Source/tasks.c **** 	TCB_t * pxTCB;
4793:FreeRTOS/Source/tasks.c **** 	uint8_t ucOriginalNotifyState;
4794:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxSavedInterruptStatus;
4795:FreeRTOS/Source/tasks.c **** 
4796:FreeRTOS/Source/tasks.c **** 		configASSERT( xTaskToNotify );
4797:FreeRTOS/Source/tasks.c **** 
4798:FreeRTOS/Source/tasks.c **** 		/* RTOS ports that support interrupt nesting have the concept of a
4799:FreeRTOS/Source/tasks.c **** 		maximum	system call (or maximum API call) interrupt priority.
4800:FreeRTOS/Source/tasks.c **** 		Interrupts that are	above the maximum system call priority are keep
4801:FreeRTOS/Source/tasks.c **** 		permanently enabled, even when the RTOS kernel is in a critical section,
4802:FreeRTOS/Source/tasks.c **** 		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
4803:FreeRTOS/Source/tasks.c **** 		is defined in FreeRTOSConfig.h then
4804:FreeRTOS/Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
4805:FreeRTOS/Source/tasks.c **** 		failure if a FreeRTOS API function is called from an interrupt that has
4806:FreeRTOS/Source/tasks.c **** 		been assigned a priority above the configured maximum system call
4807:FreeRTOS/Source/tasks.c **** 		priority.  Only FreeRTOS functions that end in FromISR can be called
4808:FreeRTOS/Source/tasks.c **** 		from interrupts	that have been assigned a priority at or (logically)
4809:FreeRTOS/Source/tasks.c **** 		below the maximum system call interrupt priority.  FreeRTOS maintains a
4810:FreeRTOS/Source/tasks.c **** 		separate interrupt safe API to ensure interrupt entry is as fast and as
4811:FreeRTOS/Source/tasks.c **** 		simple as possible.  More information (albeit Cortex-M specific) is
4812:FreeRTOS/Source/tasks.c **** 		provided on the following link:
4813:FreeRTOS/Source/tasks.c **** 		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
4814:FreeRTOS/Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
4815:FreeRTOS/Source/tasks.c **** 
4816:FreeRTOS/Source/tasks.c **** 		pxTCB = ( TCB_t * ) xTaskToNotify;
4817:FreeRTOS/Source/tasks.c **** 
4818:FreeRTOS/Source/tasks.c **** 		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
4819:FreeRTOS/Source/tasks.c **** 		{
4820:FreeRTOS/Source/tasks.c **** 			ucOriginalNotifyState = pxTCB->ucNotifyState;
4821:FreeRTOS/Source/tasks.c **** 			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
4822:FreeRTOS/Source/tasks.c **** 
4823:FreeRTOS/Source/tasks.c **** 			/* 'Giving' is equivalent to incrementing a count in a counting
4824:FreeRTOS/Source/tasks.c **** 			semaphore. */
4825:FreeRTOS/Source/tasks.c **** 			( pxTCB->ulNotifiedValue )++;
4826:FreeRTOS/Source/tasks.c **** 
4827:FreeRTOS/Source/tasks.c **** 			traceTASK_NOTIFY_GIVE_FROM_ISR();
4828:FreeRTOS/Source/tasks.c **** 
4829:FreeRTOS/Source/tasks.c **** 			/* If the task is in the blocked state specifically to wait for a
4830:FreeRTOS/Source/tasks.c **** 			notification then unblock it now. */
4831:FreeRTOS/Source/tasks.c **** 			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
4832:FreeRTOS/Source/tasks.c **** 			{
4833:FreeRTOS/Source/tasks.c **** 				/* The task should not have been on an event list. */
4834:FreeRTOS/Source/tasks.c **** 				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
4835:FreeRTOS/Source/tasks.c **** 
4836:FreeRTOS/Source/tasks.c **** 				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
4837:FreeRTOS/Source/tasks.c **** 				{
4838:FreeRTOS/Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
4839:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
4840:FreeRTOS/Source/tasks.c **** 				}
4841:FreeRTOS/Source/tasks.c **** 				else
4842:FreeRTOS/Source/tasks.c **** 				{
4843:FreeRTOS/Source/tasks.c **** 					/* The delayed and ready lists cannot be accessed, so hold
4844:FreeRTOS/Source/tasks.c **** 					this task pending until the scheduler is resumed. */
4845:FreeRTOS/Source/tasks.c **** 					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
4846:FreeRTOS/Source/tasks.c **** 				}
4847:FreeRTOS/Source/tasks.c **** 
4848:FreeRTOS/Source/tasks.c **** 				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
4849:FreeRTOS/Source/tasks.c **** 				{
4850:FreeRTOS/Source/tasks.c **** 					/* The notified task has a priority above the currently
4851:FreeRTOS/Source/tasks.c **** 					executing task so a yield is required. */
4852:FreeRTOS/Source/tasks.c **** 					if( pxHigherPriorityTaskWoken != NULL )
4853:FreeRTOS/Source/tasks.c **** 					{
4854:FreeRTOS/Source/tasks.c **** 						*pxHigherPriorityTaskWoken = pdTRUE;
4855:FreeRTOS/Source/tasks.c **** 					}
4856:FreeRTOS/Source/tasks.c **** 					else
4857:FreeRTOS/Source/tasks.c **** 					{
4858:FreeRTOS/Source/tasks.c **** 						/* Mark that a yield is pending in case the user is not
4859:FreeRTOS/Source/tasks.c **** 						using the "xHigherPriorityTaskWoken" parameter in an ISR
4860:FreeRTOS/Source/tasks.c **** 						safe FreeRTOS function. */
4861:FreeRTOS/Source/tasks.c **** 						xYieldPending = pdTRUE;
4862:FreeRTOS/Source/tasks.c **** 					}
4863:FreeRTOS/Source/tasks.c **** 				}
4864:FreeRTOS/Source/tasks.c **** 				else
4865:FreeRTOS/Source/tasks.c **** 				{
4866:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4867:FreeRTOS/Source/tasks.c **** 				}
4868:FreeRTOS/Source/tasks.c **** 			}
4869:FreeRTOS/Source/tasks.c **** 		}
4870:FreeRTOS/Source/tasks.c **** 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
4871:FreeRTOS/Source/tasks.c **** 	}
4872:FreeRTOS/Source/tasks.c **** 
4873:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
4874:FreeRTOS/Source/tasks.c **** 
4875:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4876:FreeRTOS/Source/tasks.c **** 
4877:FreeRTOS/Source/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
4878:FreeRTOS/Source/tasks.c **** 
4879:FreeRTOS/Source/tasks.c **** 	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
4880:FreeRTOS/Source/tasks.c **** 	{
4881:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
4882:FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn;
4883:FreeRTOS/Source/tasks.c **** 
4884:FreeRTOS/Source/tasks.c **** 		/* If null is passed in here then it is the calling task that is having
4885:FreeRTOS/Source/tasks.c **** 		its notification state cleared. */
4886:FreeRTOS/Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTask );
4887:FreeRTOS/Source/tasks.c **** 
4888:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
4889:FreeRTOS/Source/tasks.c **** 		{
4890:FreeRTOS/Source/tasks.c **** 			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
4891:FreeRTOS/Source/tasks.c **** 			{
4892:FreeRTOS/Source/tasks.c **** 				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
4893:FreeRTOS/Source/tasks.c **** 				xReturn = pdPASS;
4894:FreeRTOS/Source/tasks.c **** 			}
4895:FreeRTOS/Source/tasks.c **** 			else
4896:FreeRTOS/Source/tasks.c **** 			{
4897:FreeRTOS/Source/tasks.c **** 				xReturn = pdFAIL;
4898:FreeRTOS/Source/tasks.c **** 			}
4899:FreeRTOS/Source/tasks.c **** 		}
4900:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
4901:FreeRTOS/Source/tasks.c **** 
4902:FreeRTOS/Source/tasks.c **** 		return xReturn;
4903:FreeRTOS/Source/tasks.c **** 	}
4904:FreeRTOS/Source/tasks.c **** 
4905:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
4906:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4907:FreeRTOS/Source/tasks.c **** 
4908:FreeRTOS/Source/tasks.c **** 
4909:FreeRTOS/Source/tasks.c **** static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockInde
 241               	.LM5:
 242               	.LFBB2:
 243 0036 0F93      		push r16
 244 0038 1F93      		push r17
 245 003a CF93      		push r28
 246 003c DF93      		push r29
 247               	/* prologue: function */
 248               	/* frame size = 0 */
 249               	/* stack size = 4 */
 250               	.L__stack_usage = 4
 251 003e EC01      		movw r28,r24
4910:FreeRTOS/Source/tasks.c **** {
4911:FreeRTOS/Source/tasks.c **** TickType_t xTimeToWake;
4912:FreeRTOS/Source/tasks.c **** const TickType_t xConstTickCount = xTickCount;
 253               	.LM6:
 254 0040 0091 0000 		lds r16,xTickCount
 255 0044 1091 0000 		lds r17,xTickCount+1
4913:FreeRTOS/Source/tasks.c **** 
4914:FreeRTOS/Source/tasks.c **** 	#if( INCLUDE_xTaskAbortDelay == 1 )
4915:FreeRTOS/Source/tasks.c **** 	{
4916:FreeRTOS/Source/tasks.c **** 		/* About to enter a delayed list, so ensure the ucDelayAborted flag is
4917:FreeRTOS/Source/tasks.c **** 		reset to pdFALSE so it can be detected as having been set to pdTRUE
4918:FreeRTOS/Source/tasks.c **** 		when the task leaves the Blocked state. */
4919:FreeRTOS/Source/tasks.c **** 		pxCurrentTCB->ucDelayAborted = pdFALSE;
4920:FreeRTOS/Source/tasks.c **** 	}
4921:FreeRTOS/Source/tasks.c **** 	#endif
4922:FreeRTOS/Source/tasks.c **** 
4923:FreeRTOS/Source/tasks.c **** 	/* Remove the task from the ready list before adding it to the blocked list
4924:FreeRTOS/Source/tasks.c **** 	as the same list item is used for both lists. */
4925:FreeRTOS/Source/tasks.c **** 	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 257               	.LM7:
 258 0048 8091 0000 		lds r24,pxCurrentTCB
 259 004c 9091 0000 		lds r25,pxCurrentTCB+1
 260 0050 0296      		adiw r24,2
 261 0052 0E94 0000 		call uxListRemove
4926:FreeRTOS/Source/tasks.c **** 	{
4927:FreeRTOS/Source/tasks.c **** 		/* The current task must be in a ready list, so there is no need to
4928:FreeRTOS/Source/tasks.c **** 		check, and the port reset macro can be called directly. */
4929:FreeRTOS/Source/tasks.c **** 		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
4930:FreeRTOS/Source/tasks.c **** 	}
4931:FreeRTOS/Source/tasks.c **** 	else
4932:FreeRTOS/Source/tasks.c **** 	{
4933:FreeRTOS/Source/tasks.c **** 		mtCOVERAGE_TEST_MARKER();
4934:FreeRTOS/Source/tasks.c **** 	}
4935:FreeRTOS/Source/tasks.c **** 
4936:FreeRTOS/Source/tasks.c **** 	#if ( INCLUDE_vTaskSuspend == 1 )
4937:FreeRTOS/Source/tasks.c **** 	{
4938:FreeRTOS/Source/tasks.c **** 		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
4939:FreeRTOS/Source/tasks.c **** 		{
4940:FreeRTOS/Source/tasks.c **** 			/* Add the task to the suspended task list instead of a delayed task
4941:FreeRTOS/Source/tasks.c **** 			list to ensure it is not woken by a timing event.  It will block
4942:FreeRTOS/Source/tasks.c **** 			indefinitely. */
4943:FreeRTOS/Source/tasks.c **** 			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
4944:FreeRTOS/Source/tasks.c **** 		}
4945:FreeRTOS/Source/tasks.c **** 		else
4946:FreeRTOS/Source/tasks.c **** 		{
4947:FreeRTOS/Source/tasks.c **** 			/* Calculate the time at which the task should be woken if the event
4948:FreeRTOS/Source/tasks.c **** 			does not occur.  This may overflow but this doesn't matter, the
4949:FreeRTOS/Source/tasks.c **** 			kernel will manage it correctly. */
4950:FreeRTOS/Source/tasks.c **** 			xTimeToWake = xConstTickCount + xTicksToWait;
4951:FreeRTOS/Source/tasks.c **** 
4952:FreeRTOS/Source/tasks.c **** 			/* The list item will be inserted in wake time order. */
4953:FreeRTOS/Source/tasks.c **** 			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
4954:FreeRTOS/Source/tasks.c **** 
4955:FreeRTOS/Source/tasks.c **** 			if( xTimeToWake < xConstTickCount )
4956:FreeRTOS/Source/tasks.c **** 			{
4957:FreeRTOS/Source/tasks.c **** 				/* Wake time has overflowed.  Place this item in the overflow
4958:FreeRTOS/Source/tasks.c **** 				list. */
4959:FreeRTOS/Source/tasks.c **** 				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
4960:FreeRTOS/Source/tasks.c **** 			}
4961:FreeRTOS/Source/tasks.c **** 			else
4962:FreeRTOS/Source/tasks.c **** 			{
4963:FreeRTOS/Source/tasks.c **** 				/* The wake time has not overflowed, so the current block list
4964:FreeRTOS/Source/tasks.c **** 				is used. */
4965:FreeRTOS/Source/tasks.c **** 				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
4966:FreeRTOS/Source/tasks.c **** 
4967:FreeRTOS/Source/tasks.c **** 				/* If the task entering the blocked state was placed at the
4968:FreeRTOS/Source/tasks.c **** 				head of the list of blocked tasks then xNextTaskUnblockTime
4969:FreeRTOS/Source/tasks.c **** 				needs to be updated too. */
4970:FreeRTOS/Source/tasks.c **** 				if( xTimeToWake < xNextTaskUnblockTime )
4971:FreeRTOS/Source/tasks.c **** 				{
4972:FreeRTOS/Source/tasks.c **** 					xNextTaskUnblockTime = xTimeToWake;
4973:FreeRTOS/Source/tasks.c **** 				}
4974:FreeRTOS/Source/tasks.c **** 				else
4975:FreeRTOS/Source/tasks.c **** 				{
4976:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4977:FreeRTOS/Source/tasks.c **** 				}
4978:FreeRTOS/Source/tasks.c **** 			}
4979:FreeRTOS/Source/tasks.c **** 		}
4980:FreeRTOS/Source/tasks.c **** 	}
4981:FreeRTOS/Source/tasks.c **** 	#else /* INCLUDE_vTaskSuspend */
4982:FreeRTOS/Source/tasks.c **** 	{
4983:FreeRTOS/Source/tasks.c **** 		/* Calculate the time at which the task should be woken if the event
4984:FreeRTOS/Source/tasks.c **** 		does not occur.  This may overflow but this doesn't matter, the kernel
4985:FreeRTOS/Source/tasks.c **** 		will manage it correctly. */
4986:FreeRTOS/Source/tasks.c **** 		xTimeToWake = xConstTickCount + xTicksToWait;
 263               	.LM8:
 264 0056 C00F      		add r28,r16
 265 0058 D11F      		adc r29,r17
4987:FreeRTOS/Source/tasks.c **** 
4988:FreeRTOS/Source/tasks.c **** 		/* The list item will be inserted in wake time order. */
4989:FreeRTOS/Source/tasks.c **** 		listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 267               	.LM9:
 268 005a E091 0000 		lds r30,pxCurrentTCB
 269 005e F091 0000 		lds r31,pxCurrentTCB+1
 270 0062 D383      		std Z+3,r29
 271 0064 C283      		std Z+2,r28
 272               	.LBB8:
 273               	.LBB9:
4990:FreeRTOS/Source/tasks.c **** 
4991:FreeRTOS/Source/tasks.c **** 		if( xTimeToWake < xConstTickCount )
4992:FreeRTOS/Source/tasks.c **** 		{
4993:FreeRTOS/Source/tasks.c **** 			/* Wake time has overflowed.  Place this item in the overflow list. */
4994:FreeRTOS/Source/tasks.c **** 			vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 275               	.LM10:
 276 0066 6091 0000 		lds r22,pxCurrentTCB
 277 006a 7091 0000 		lds r23,pxCurrentTCB+1
 278               	.LBE9:
 279               	.LBE8:
4991:FreeRTOS/Source/tasks.c **** 		{
 281               	.LM11:
 282 006e C017      		cp r28,r16
 283 0070 D107      		cpc r29,r17
 284 0072 00F4      		brsh .L7
 285               	.LBB12:
 286               	.LBB10:
 288               	.LM12:
 289 0074 8091 0000 		lds r24,pxOverflowDelayedTaskList
 290 0078 9091 0000 		lds r25,pxOverflowDelayedTaskList+1
 291 007c 6E5F      		subi r22,-2
 292 007e 7F4F      		sbci r23,-1
 293               	/* epilogue start */
 294               	.LBE10:
 295               	.LBE12:
4995:FreeRTOS/Source/tasks.c **** 		}
4996:FreeRTOS/Source/tasks.c **** 		else
4997:FreeRTOS/Source/tasks.c **** 		{
4998:FreeRTOS/Source/tasks.c **** 			/* The wake time has not overflowed, so the current block list is used. */
4999:FreeRTOS/Source/tasks.c **** 			vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
5000:FreeRTOS/Source/tasks.c **** 
5001:FreeRTOS/Source/tasks.c **** 			/* If the task entering the blocked state was placed at the head of the
5002:FreeRTOS/Source/tasks.c **** 			list of blocked tasks then xNextTaskUnblockTime needs to be updated
5003:FreeRTOS/Source/tasks.c **** 			too. */
5004:FreeRTOS/Source/tasks.c **** 			if( xTimeToWake < xNextTaskUnblockTime )
5005:FreeRTOS/Source/tasks.c **** 			{
5006:FreeRTOS/Source/tasks.c **** 				xNextTaskUnblockTime = xTimeToWake;
5007:FreeRTOS/Source/tasks.c **** 			}
5008:FreeRTOS/Source/tasks.c **** 			else
5009:FreeRTOS/Source/tasks.c **** 			{
5010:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
5011:FreeRTOS/Source/tasks.c **** 			}
5012:FreeRTOS/Source/tasks.c **** 		}
5013:FreeRTOS/Source/tasks.c **** 
5014:FreeRTOS/Source/tasks.c **** 		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
5015:FreeRTOS/Source/tasks.c **** 		( void ) xCanBlockIndefinitely;
5016:FreeRTOS/Source/tasks.c **** 	}
5017:FreeRTOS/Source/tasks.c **** 	#endif /* INCLUDE_vTaskSuspend */
5018:FreeRTOS/Source/tasks.c **** }
 297               	.LM13:
 298 0080 DF91      		pop r29
 299 0082 CF91      		pop r28
 300 0084 1F91      		pop r17
 301 0086 0F91      		pop r16
 302               	.LBB13:
 303               	.LBB11:
4994:FreeRTOS/Source/tasks.c **** 		}
 305               	.LM14:
 306 0088 0C94 0000 		jmp vListInsert
 307               	.L7:
 308               	.LBE11:
 309               	.LBE13:
4999:FreeRTOS/Source/tasks.c **** 
 311               	.LM15:
 312 008c 8091 0000 		lds r24,pxDelayedTaskList
 313 0090 9091 0000 		lds r25,pxDelayedTaskList+1
 314 0094 6E5F      		subi r22,-2
 315 0096 7F4F      		sbci r23,-1
 316 0098 0E94 0000 		call vListInsert
5004:FreeRTOS/Source/tasks.c **** 			{
 318               	.LM16:
 319 009c 8091 0000 		lds r24,xNextTaskUnblockTime
 320 00a0 9091 0000 		lds r25,xNextTaskUnblockTime+1
 321 00a4 C817      		cp r28,r24
 322 00a6 D907      		cpc r29,r25
 323 00a8 00F4      		brsh .L6
5006:FreeRTOS/Source/tasks.c **** 			}
 325               	.LM17:
 326 00aa D093 0000 		sts xNextTaskUnblockTime+1,r29
 327 00ae C093 0000 		sts xNextTaskUnblockTime,r28
 328               	.L6:
 329               	/* epilogue start */
 331               	.LM18:
 332 00b2 DF91      		pop r29
 333 00b4 CF91      		pop r28
 334 00b6 1F91      		pop r17
 335 00b8 0F91      		pop r16
 336 00ba 0895      		ret
 342               	.Lscope2:
 344               		.stabd	78,0,0
 348               	prvIdleTask:
 349               		.stabd	46,0,0
3225:FreeRTOS/Source/tasks.c **** 	/* Stop warnings. */
 351               	.LM19:
 352               	.LFBB3:
 353               	/* prologue: function */
 354               	/* frame size = 0 */
 355               	/* stack size = 0 */
 356               	.L__stack_usage = 0
 357               	.L10:
 358               	.LBB20:
 359               	.LBB21:
3479:FreeRTOS/Source/tasks.c **** 		{
 361               	.LM20:
 362 00bc 8091 0000 		lds r24,uxDeletedTasksWaitingCleanUp
 363 00c0 8823      		tst r24
 364 00c2 01F0      		breq .L14
3481:FreeRTOS/Source/tasks.c **** 			{
 366               	.LM21:
 367               	/* #APP */
 368               	 ;  3481 "FreeRTOS/Source/tasks.c" 1
 369 00c4 0FB6      		in		__tmp_reg__, __SREG__
 370               	 ;  0 "" 2
 371               	 ;  3481 "FreeRTOS/Source/tasks.c" 1
 372 00c6 F894      		cli
 373               	 ;  0 "" 2
 374               	 ;  3481 "FreeRTOS/Source/tasks.c" 1
 375 00c8 0F92      		push	__tmp_reg__
 376               	 ;  0 "" 2
3483:FreeRTOS/Source/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 378               	.LM22:
 379               	/* #NOAPP */
 380 00ca E091 0000 		lds r30,xTasksWaitingTermination+5
 381 00ce F091 0000 		lds r31,xTasksWaitingTermination+5+1
 382 00d2 C681      		ldd r28,Z+6
 383 00d4 D781      		ldd r29,Z+7
3484:FreeRTOS/Source/tasks.c **** 				--uxCurrentNumberOfTasks;
 385               	.LM23:
 386 00d6 CE01      		movw r24,r28
 387 00d8 0296      		adiw r24,2
 388 00da 0E94 0000 		call uxListRemove
3485:FreeRTOS/Source/tasks.c **** 				--uxDeletedTasksWaitingCleanUp;
 390               	.LM24:
 391 00de 8091 0000 		lds r24,uxCurrentNumberOfTasks
 392 00e2 8150      		subi r24,lo8(-(-1))
 393 00e4 8093 0000 		sts uxCurrentNumberOfTasks,r24
3486:FreeRTOS/Source/tasks.c **** 			}
 395               	.LM25:
 396 00e8 8091 0000 		lds r24,uxDeletedTasksWaitingCleanUp
 397 00ec 8150      		subi r24,lo8(-(-1))
 398 00ee 8093 0000 		sts uxDeletedTasksWaitingCleanUp,r24
3488:FreeRTOS/Source/tasks.c **** 
 400               	.LM26:
 401               	/* #APP */
 402               	 ;  3488 "FreeRTOS/Source/tasks.c" 1
 403 00f2 0F90      		pop		__tmp_reg__
 404               	 ;  0 "" 2
 405               	 ;  3488 "FreeRTOS/Source/tasks.c" 1
 406 00f4 0FBE      		out		__SREG__, __tmp_reg__
 407               	 ;  0 "" 2
 408               	/* #NOAPP */
 409               	.LBB22:
 410               	.LBB23:
3695:FreeRTOS/Source/tasks.c **** 			vPortFree( pxTCB );
 412               	.LM27:
 413 00f6 8F89      		ldd r24,Y+23
 414 00f8 988D      		ldd r25,Y+24
 415 00fa 0E94 0000 		call vPortFree
3696:FreeRTOS/Source/tasks.c **** 		}
 417               	.LM28:
 418 00fe CE01      		movw r24,r28
 419 0100 0E94 0000 		call vPortFree
 420 0104 00C0      		rjmp .L10
 421               	.L14:
 422               	.LBE23:
 423               	.LBE22:
 424               	.LBE21:
 425               	.LBE20:
3264:FreeRTOS/Source/tasks.c **** 			{
 427               	.LM29:
 428 0106 8091 0000 		lds r24,pxReadyTasksLists
 429 010a 8230      		cpi r24,lo8(2)
 430 010c 00F0      		brlo .L12
3266:FreeRTOS/Source/tasks.c **** 			}
 432               	.LM30:
 433 010e 0E94 0000 		call vPortYield
 434               	.L12:
 435               	.LBB24:
3284:FreeRTOS/Source/tasks.c **** 		}
 437               	.LM31:
 438 0112 0E94 0000 		call vApplicationIdleHook
 439               	.LBE24:
3337:FreeRTOS/Source/tasks.c **** }
 441               	.LM32:
 442 0116 00C0      		rjmp .L10
 447               	.Lscope3:
 449               		.stabd	78,0,0
 456               	.global	xTaskCreate
 458               	xTaskCreate:
 459               		.stabd	46,0,0
 738:FreeRTOS/Source/tasks.c **** 	TCB_t *pxNewTCB;
 461               	.LM33:
 462               	.LFBB4:
 463 0118 4F92      		push r4
 464 011a 5F92      		push r5
 465 011c 6F92      		push r6
 466 011e 7F92      		push r7
 467 0120 8F92      		push r8
 468 0122 9F92      		push r9
 469 0124 AF92      		push r10
 470 0126 BF92      		push r11
 471 0128 CF92      		push r12
 472 012a DF92      		push r13
 473 012c EF92      		push r14
 474 012e FF92      		push r15
 475 0130 0F93      		push r16
 476 0132 1F93      		push r17
 477 0134 CF93      		push r28
 478 0136 DF93      		push r29
 479               	/* prologue: function */
 480               	/* frame size = 0 */
 481               	/* stack size = 16 */
 482               	.L__stack_usage = 16
 483 0138 5C01      		movw r10,r24
 484 013a 762E      		mov r7,r22
 485 013c 172F      		mov r17,r23
 486 013e 6A01      		movw r12,r20
 487 0140 4901      		movw r8,r18
 488               	.LBB32:
 772:FreeRTOS/Source/tasks.c **** 
 490               	.LM34:
 491 0142 CA01      		movw r24,r20
 492 0144 0E94 0000 		call pvPortMalloc
 493 0148 2C01      		movw r4,r24
 774:FreeRTOS/Source/tasks.c **** 			{
 495               	.LM35:
 496 014a 892B      		or r24,r25
 497 014c 01F4      		brne .+2
 498 014e 00C0      		rjmp .L16
 777:FreeRTOS/Source/tasks.c **** 
 500               	.LM36:
 501 0150 86E2      		ldi r24,lo8(38)
 502 0152 90E0      		ldi r25,0
 503 0154 0E94 0000 		call pvPortMalloc
 504 0158 EC01      		movw r28,r24
 779:FreeRTOS/Source/tasks.c **** 				{
 506               	.LM37:
 507 015a 0097      		sbiw r24,0
 508 015c 01F0      		breq .L17
 782:FreeRTOS/Source/tasks.c **** 				}
 510               	.LM38:
 511 015e 588E      		std Y+24,r5
 512 0160 4F8A      		std Y+23,r4
 513               	.LBE32:
 514               	.LBB33:
 515               	.LBB34:
 863:FreeRTOS/Source/tasks.c **** 		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTE
 517               	.LM39:
 518 0162 21E0      		ldi r18,1
 519 0164 C21A      		sub r12,r18
 520 0166 D108      		sbc r13,__zero_reg__
 521 0168 C40C      		add r12,r4
 522 016a D51C      		adc r13,r5
 523 016c BC01      		movw r22,r24
 524 016e 675E      		subi r22,-25
 525 0170 7F4F      		sbci r23,-1
 526 0172 E72D      		mov r30,r7
 527 0174 F12F      		mov r31,r17
 528 0176 CF01      		movw r24,r30
 529 0178 0896      		adiw r24,8
 530 017a 00C0      		rjmp .L18
 531               	.L17:
 532               	.LBE34:
 533               	.LBE33:
 534               	.LBB36:
 788:FreeRTOS/Source/tasks.c **** 				}
 536               	.LM40:
 537 017c C201      		movw r24,r4
 538 017e 0E94 0000 		call vPortFree
 539 0182 00C0      		rjmp .L16
 540               	.L41:
 541               	.LBE36:
 542               	.LBB37:
 543               	.LBB35:
 891:FreeRTOS/Source/tasks.c **** 	{
 545               	.LM41:
 546 0184 E817      		cp r30,r24
 547 0186 F907      		cpc r31,r25
 548 0188 01F0      		breq .L19
 549               	.L18:
 550 018a 9F01      		movw r18,r30
 893:FreeRTOS/Source/tasks.c **** 
 552               	.LM42:
 553 018c 4191      		ld r20,Z+
 554 018e DB01      		movw r26,r22
 555 0190 4D93      		st X+,r20
 556 0192 BD01      		movw r22,r26
 898:FreeRTOS/Source/tasks.c **** 		{
 558               	.LM43:
 559 0194 D901      		movw r26,r18
 560 0196 2C91      		ld r18,X
 561 0198 2111      		cpse r18,__zero_reg__
 562 019a 00C0      		rjmp .L41
 563               	.L19:
 910:FreeRTOS/Source/tasks.c **** 
 565               	.LM44:
 566 019c 18A2      		std Y+32,__zero_reg__
 567 019e 0430      		cpi r16,lo8(4)
 568 01a0 00F0      		brlo .L20
 569 01a2 03E0      		ldi r16,lo8(3)
 570               	.L20:
 923:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
 572               	.LM45:
 573 01a4 0E8B      		std Y+22,r16
 931:FreeRTOS/Source/tasks.c **** 	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 575               	.LM46:
 576 01a6 3E01      		movw r6,r28
 577 01a8 B2E0      		ldi r27,2
 578 01aa 6B0E      		add r6,r27
 579 01ac 711C      		adc r7,__zero_reg__
 580 01ae C301      		movw r24,r6
 581 01b0 0E94 0000 		call vListInitialiseItem
 932:FreeRTOS/Source/tasks.c **** 
 583               	.LM47:
 584 01b4 CE01      		movw r24,r28
 585 01b6 0C96      		adiw r24,12
 586 01b8 0E94 0000 		call vListInitialiseItem
 936:FreeRTOS/Source/tasks.c **** 
 588               	.LM48:
 589 01bc D987      		std Y+9,r29
 590 01be C887      		std Y+8,r28
 939:FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 592               	.LM49:
 593 01c0 84E0      		ldi r24,lo8(4)
 594 01c2 90E0      		ldi r25,0
 595 01c4 801B      		sub r24,r16
 596 01c6 9109      		sbc r25,__zero_reg__
 597 01c8 9D87      		std Y+13,r25
 598 01ca 8C87      		std Y+12,r24
 940:FreeRTOS/Source/tasks.c **** 
 600               	.LM50:
 601 01cc DB8B      		std Y+19,r29
 602 01ce CA8B      		std Y+18,r28
 982:FreeRTOS/Source/tasks.c **** 		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 604               	.LM51:
 605 01d0 19A2      		std Y+33,__zero_reg__
 606 01d2 1AA2      		std Y+34,__zero_reg__
 607 01d4 1BA2      		std Y+35,__zero_reg__
 608 01d6 1CA2      		std Y+36,__zero_reg__
 983:FreeRTOS/Source/tasks.c **** 	}
 610               	.LM52:
 611 01d8 1DA2      		std Y+37,__zero_reg__
1010:FreeRTOS/Source/tasks.c **** 	}
 613               	.LM53:
 614 01da A401      		movw r20,r8
 615 01dc B501      		movw r22,r10
 616 01de C601      		movw r24,r12
 617 01e0 0E94 0000 		call pxPortInitialiseStack
 618 01e4 9983      		std Y+1,r25
 619 01e6 8883      		st Y,r24
1014:FreeRTOS/Source/tasks.c **** 	{
 621               	.LM54:
 622 01e8 E114      		cp r14,__zero_reg__
 623 01ea F104      		cpc r15,__zero_reg__
 624 01ec 01F0      		breq .L21
1018:FreeRTOS/Source/tasks.c **** 	}
 626               	.LM55:
 627 01ee F701      		movw r30,r14
 628 01f0 D183      		std Z+1,r29
 629 01f2 C083      		st Z,r28
 630               	.L21:
 631               	.LBE35:
 632               	.LBE37:
 633               	.LBB38:
 634               	.LBB39:
1031:FreeRTOS/Source/tasks.c **** 	{
 636               	.LM56:
 637               	/* #APP */
 638               	 ;  1031 "FreeRTOS/Source/tasks.c" 1
 639 01f4 0FB6      		in		__tmp_reg__, __SREG__
 640               	 ;  0 "" 2
 641               	 ;  1031 "FreeRTOS/Source/tasks.c" 1
 642 01f6 F894      		cli
 643               	 ;  0 "" 2
 644               	 ;  1031 "FreeRTOS/Source/tasks.c" 1
 645 01f8 0F92      		push	__tmp_reg__
 646               	 ;  0 "" 2
1033:FreeRTOS/Source/tasks.c **** 		if( pxCurrentTCB == NULL )
 648               	.LM57:
 649               	/* #NOAPP */
 650 01fa 8091 0000 		lds r24,uxCurrentNumberOfTasks
 651 01fe 8F5F      		subi r24,lo8(-(1))
 652 0200 8093 0000 		sts uxCurrentNumberOfTasks,r24
1034:FreeRTOS/Source/tasks.c **** 		{
 654               	.LM58:
 655 0204 8091 0000 		lds r24,pxCurrentTCB
 656 0208 9091 0000 		lds r25,pxCurrentTCB+1
 657 020c 892B      		or r24,r25
 658 020e 01F4      		brne .L22
1038:FreeRTOS/Source/tasks.c **** 
 660               	.LM59:
 661 0210 D093 0000 		sts pxCurrentTCB+1,r29
 662 0214 C093 0000 		sts pxCurrentTCB,r28
1040:FreeRTOS/Source/tasks.c **** 			{
 664               	.LM60:
 665 0218 8091 0000 		lds r24,uxCurrentNumberOfTasks
 666 021c 8130      		cpi r24,lo8(1)
 667 021e 01F4      		brne .L24
 668               	.LBB40:
 669               	.LBB41:
3442:FreeRTOS/Source/tasks.c **** 	}
 671               	.LM61:
 672 0220 80E0      		ldi r24,lo8(pxReadyTasksLists)
 673 0222 90E0      		ldi r25,hi8(pxReadyTasksLists)
 674 0224 0E94 0000 		call vListInitialise
 675 0228 80E0      		ldi r24,lo8(pxReadyTasksLists+9)
 676 022a 90E0      		ldi r25,hi8(pxReadyTasksLists+9)
 677 022c 0E94 0000 		call vListInitialise
 678 0230 80E0      		ldi r24,lo8(pxReadyTasksLists+18)
 679 0232 90E0      		ldi r25,hi8(pxReadyTasksLists+18)
 680 0234 0E94 0000 		call vListInitialise
 681 0238 80E0      		ldi r24,lo8(pxReadyTasksLists+27)
 682 023a 90E0      		ldi r25,hi8(pxReadyTasksLists+27)
 683 023c 0E94 0000 		call vListInitialise
3445:FreeRTOS/Source/tasks.c **** 	vListInitialise( &xDelayedTaskList2 );
 685               	.LM62:
 686 0240 80E0      		ldi r24,lo8(xDelayedTaskList1)
 687 0242 90E0      		ldi r25,hi8(xDelayedTaskList1)
 688 0244 0E94 0000 		call vListInitialise
3446:FreeRTOS/Source/tasks.c **** 	vListInitialise( &xPendingReadyList );
 690               	.LM63:
 691 0248 80E0      		ldi r24,lo8(xDelayedTaskList2)
 692 024a 90E0      		ldi r25,hi8(xDelayedTaskList2)
 693 024c 0E94 0000 		call vListInitialise
3447:FreeRTOS/Source/tasks.c **** 
 695               	.LM64:
 696 0250 80E0      		ldi r24,lo8(xPendingReadyList)
 697 0252 90E0      		ldi r25,hi8(xPendingReadyList)
 698 0254 0E94 0000 		call vListInitialise
3451:FreeRTOS/Source/tasks.c **** 	}
 700               	.LM65:
 701 0258 80E0      		ldi r24,lo8(xTasksWaitingTermination)
 702 025a 90E0      		ldi r25,hi8(xTasksWaitingTermination)
 703 025c 0E94 0000 		call vListInitialise
3463:FreeRTOS/Source/tasks.c **** 	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 705               	.LM66:
 706 0260 80E0      		ldi r24,lo8(xDelayedTaskList1)
 707 0262 90E0      		ldi r25,hi8(xDelayedTaskList1)
 708 0264 9093 0000 		sts pxDelayedTaskList+1,r25
 709 0268 8093 0000 		sts pxDelayedTaskList,r24
3464:FreeRTOS/Source/tasks.c **** }
 711               	.LM67:
 712 026c 80E0      		ldi r24,lo8(xDelayedTaskList2)
 713 026e 90E0      		ldi r25,hi8(xDelayedTaskList2)
 714 0270 9093 0000 		sts pxOverflowDelayedTaskList+1,r25
 715 0274 8093 0000 		sts pxOverflowDelayedTaskList,r24
 716 0278 00C0      		rjmp .L24
 717               	.L22:
 718               	.LBE41:
 719               	.LBE40:
1057:FreeRTOS/Source/tasks.c **** 			{
 721               	.LM68:
 722 027a 8091 0000 		lds r24,xSchedulerRunning
 723 027e 8111      		cpse r24,__zero_reg__
 724 0280 00C0      		rjmp .L24
1059:FreeRTOS/Source/tasks.c **** 				{
 726               	.LM69:
 727 0282 E091 0000 		lds r30,pxCurrentTCB
 728 0286 F091 0000 		lds r31,pxCurrentTCB+1
 729 028a 9689      		ldd r25,Z+22
 730 028c 8E89      		ldd r24,Y+22
 731 028e 8917      		cp r24,r25
 732 0290 00F0      		brlo .L24
1061:FreeRTOS/Source/tasks.c **** 				}
 734               	.LM70:
 735 0292 D093 0000 		sts pxCurrentTCB+1,r29
 736 0296 C093 0000 		sts pxCurrentTCB,r28
 737               	.L24:
1074:FreeRTOS/Source/tasks.c **** 
 739               	.LM71:
 740 029a 8091 0000 		lds r24,uxTaskNumber
 741 029e 8F5F      		subi r24,lo8(-(1))
 742 02a0 8093 0000 		sts uxTaskNumber,r24
1084:FreeRTOS/Source/tasks.c **** 
 744               	.LM72:
 745 02a4 8E89      		ldd r24,Y+22
 746 02a6 9091 0000 		lds r25,uxTopReadyPriority
 747 02aa 9817      		cp r25,r24
 748 02ac 00F4      		brsh .L26
 749 02ae 8093 0000 		sts uxTopReadyPriority,r24
 750               	.L26:
 751 02b2 F9E0      		ldi r31,lo8(9)
 752 02b4 8F9F      		mul r24,r31
 753 02b6 C001      		movw r24,r0
 754 02b8 1124      		clr __zero_reg__
 755 02ba B301      		movw r22,r6
 756 02bc 8050      		subi r24,lo8(-(pxReadyTasksLists))
 757 02be 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 758 02c0 0E94 0000 		call vListInsertEnd
1088:FreeRTOS/Source/tasks.c **** 
 760               	.LM73:
 761               	/* #APP */
 762               	 ;  1088 "FreeRTOS/Source/tasks.c" 1
 763 02c4 0F90      		pop		__tmp_reg__
 764               	 ;  0 "" 2
 765               	 ;  1088 "FreeRTOS/Source/tasks.c" 1
 766 02c6 0FBE      		out		__SREG__, __tmp_reg__
 767               	 ;  0 "" 2
1090:FreeRTOS/Source/tasks.c **** 	{
 769               	.LM74:
 770               	/* #NOAPP */
 771 02c8 8091 0000 		lds r24,xSchedulerRunning
 772 02cc 8823      		tst r24
 773 02ce 01F0      		breq .L29
1094:FreeRTOS/Source/tasks.c **** 		{
 775               	.LM75:
 776 02d0 E091 0000 		lds r30,pxCurrentTCB
 777 02d4 F091 0000 		lds r31,pxCurrentTCB+1
 778 02d8 9689      		ldd r25,Z+22
 779 02da 8E89      		ldd r24,Y+22
 780 02dc 9817      		cp r25,r24
 781 02de 00F4      		brsh .L29
1096:FreeRTOS/Source/tasks.c **** 		}
 783               	.LM76:
 784 02e0 0E94 0000 		call vPortYield
 785               	.L29:
 786               	.LBE39:
 787               	.LBE38:
 810:FreeRTOS/Source/tasks.c **** 		}
 789               	.LM77:
 790 02e4 81E0      		ldi r24,lo8(1)
 791 02e6 00C0      		rjmp .L40
 792               	.L16:
 814:FreeRTOS/Source/tasks.c **** 		}
 794               	.LM78:
 795 02e8 8FEF      		ldi r24,lo8(-1)
 796               	.L40:
 797               	/* epilogue start */
 818:FreeRTOS/Source/tasks.c **** 
 799               	.LM79:
 800 02ea DF91      		pop r29
 801 02ec CF91      		pop r28
 802 02ee 1F91      		pop r17
 803 02f0 0F91      		pop r16
 804 02f2 FF90      		pop r15
 805 02f4 EF90      		pop r14
 806 02f6 DF90      		pop r13
 807 02f8 CF90      		pop r12
 808 02fa BF90      		pop r11
 809 02fc AF90      		pop r10
 810 02fe 9F90      		pop r9
 811 0300 8F90      		pop r8
 812 0302 7F90      		pop r7
 813 0304 6F90      		pop r6
 814 0306 5F90      		pop r5
 815 0308 4F90      		pop r4
 816 030a 0895      		ret
 834               	.Lscope4:
 836               		.stabd	78,0,0
 839               	.global	vTaskDelete
 841               	vTaskDelete:
 842               		.stabd	46,0,0
1113:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
 844               	.LM80:
 845               	.LFBB5:
 846 030c 0F93      		push r16
 847 030e 1F93      		push r17
 848 0310 CF93      		push r28
 849 0312 DF93      		push r29
 850               	/* prologue: function */
 851               	/* frame size = 0 */
 852               	/* stack size = 4 */
 853               	.L__stack_usage = 4
 854 0314 EC01      		movw r28,r24
1116:FreeRTOS/Source/tasks.c **** 		{
 856               	.LM81:
 857               	/* #APP */
 858               	 ;  1116 "FreeRTOS/Source/tasks.c" 1
 859 0316 0FB6      		in		__tmp_reg__, __SREG__
 860               	 ;  0 "" 2
 861               	 ;  1116 "FreeRTOS/Source/tasks.c" 1
 862 0318 F894      		cli
 863               	 ;  0 "" 2
 864               	 ;  1116 "FreeRTOS/Source/tasks.c" 1
 865 031a 0F92      		push	__tmp_reg__
 866               	 ;  0 "" 2
1120:FreeRTOS/Source/tasks.c **** 
 868               	.LM82:
 869               	/* #NOAPP */
 870 031c 892B      		or r24,r25
 871 031e 01F4      		brne .L43
1120:FreeRTOS/Source/tasks.c **** 
 873               	.LM83:
 874 0320 C091 0000 		lds r28,pxCurrentTCB
 875 0324 D091 0000 		lds r29,pxCurrentTCB+1
 876               	.L43:
1123:FreeRTOS/Source/tasks.c **** 			{
 878               	.LM84:
 879 0328 8E01      		movw r16,r28
 880 032a 0E5F      		subi r16,-2
 881 032c 1F4F      		sbci r17,-1
 882 032e C801      		movw r24,r16
 883 0330 0E94 0000 		call uxListRemove
1133:FreeRTOS/Source/tasks.c **** 			{
 885               	.LM85:
 886 0334 8C89      		ldd r24,Y+20
 887 0336 9D89      		ldd r25,Y+21
 888 0338 892B      		or r24,r25
 889 033a 01F0      		breq .L44
1135:FreeRTOS/Source/tasks.c **** 			}
 891               	.LM86:
 892 033c CE01      		movw r24,r28
 893 033e 0C96      		adiw r24,12
 894 0340 0E94 0000 		call uxListRemove
 895               	.L44:
1146:FreeRTOS/Source/tasks.c **** 
 897               	.LM87:
 898 0344 9091 0000 		lds r25,uxTaskNumber
 899 0348 9F5F      		subi r25,lo8(-(1))
 900 034a 9093 0000 		sts uxTaskNumber,r25
1148:FreeRTOS/Source/tasks.c **** 			{
 902               	.LM88:
 903 034e 8091 0000 		lds r24,pxCurrentTCB
 904 0352 9091 0000 		lds r25,pxCurrentTCB+1
 905 0356 C817      		cp r28,r24
 906 0358 D907      		cpc r29,r25
 907 035a 01F4      		brne .L45
1155:FreeRTOS/Source/tasks.c **** 
 909               	.LM89:
 910 035c B801      		movw r22,r16
 911 035e 80E0      		ldi r24,lo8(xTasksWaitingTermination)
 912 0360 90E0      		ldi r25,hi8(xTasksWaitingTermination)
 913 0362 0E94 0000 		call vListInsertEnd
1160:FreeRTOS/Source/tasks.c **** 
 915               	.LM90:
 916 0366 8091 0000 		lds r24,uxDeletedTasksWaitingCleanUp
 917 036a 8F5F      		subi r24,lo8(-(1))
 918 036c 8093 0000 		sts uxDeletedTasksWaitingCleanUp,r24
 919 0370 00C0      		rjmp .L46
 920               	.L45:
1171:FreeRTOS/Source/tasks.c **** 				prvDeleteTCB( pxTCB );
 922               	.LM91:
 923 0372 8091 0000 		lds r24,uxCurrentNumberOfTasks
 924 0376 8150      		subi r24,lo8(-(-1))
 925 0378 8093 0000 		sts uxCurrentNumberOfTasks,r24
 926               	.LBB44:
 927               	.LBB45:
3695:FreeRTOS/Source/tasks.c **** 			vPortFree( pxTCB );
 929               	.LM92:
 930 037c 8F89      		ldd r24,Y+23
 931 037e 988D      		ldd r25,Y+24
 932 0380 0E94 0000 		call vPortFree
3696:FreeRTOS/Source/tasks.c **** 		}
 934               	.LM93:
 935 0384 CE01      		movw r24,r28
 936 0386 0E94 0000 		call vPortFree
 937               	.LBE45:
 938               	.LBE44:
1176:FreeRTOS/Source/tasks.c **** 			}
 940               	.LM94:
 941 038a 0E94 0000 		call prvResetNextTaskUnblockTime
 942               	.L46:
1181:FreeRTOS/Source/tasks.c **** 
 944               	.LM95:
 945               	/* #APP */
 946               	 ;  1181 "FreeRTOS/Source/tasks.c" 1
 947 038e 0F90      		pop		__tmp_reg__
 948               	 ;  0 "" 2
 949               	 ;  1181 "FreeRTOS/Source/tasks.c" 1
 950 0390 0FBE      		out		__SREG__, __tmp_reg__
 951               	 ;  0 "" 2
1185:FreeRTOS/Source/tasks.c **** 		{
 953               	.LM96:
 954               	/* #NOAPP */
 955 0392 8091 0000 		lds r24,xSchedulerRunning
 956 0396 8823      		tst r24
 957 0398 01F0      		breq .L42
1187:FreeRTOS/Source/tasks.c **** 			{
 959               	.LM97:
 960 039a 8091 0000 		lds r24,pxCurrentTCB
 961 039e 9091 0000 		lds r25,pxCurrentTCB+1
 962 03a2 C817      		cp r28,r24
 963 03a4 D907      		cpc r29,r25
 964 03a6 01F4      		brne .L42
1190:FreeRTOS/Source/tasks.c **** 			}
 966               	.LM98:
 967 03a8 0E94 0000 		call vPortYield
 968               	.L42:
 969               	/* epilogue start */
1197:FreeRTOS/Source/tasks.c **** 
 971               	.LM99:
 972 03ac DF91      		pop r29
 973 03ae CF91      		pop r28
 974 03b0 1F91      		pop r17
 975 03b2 0F91      		pop r16
 976 03b4 0895      		ret
 978               	.Lscope5:
 980               		.stabd	78,0,0
 981               		.section	.rodata.str1.1,"aMS",@progbits,1
 982               	.LC0:
 983 0000 4944 4C45 		.string	"IDLE"
 983      00
 984               		.text
 986               	.global	vTaskStartScheduler
 988               	vTaskStartScheduler:
 989               		.stabd	46,0,0
1902:FreeRTOS/Source/tasks.c **** BaseType_t xReturn;
 991               	.LM100:
 992               	.LFBB6:
 993 03b6 EF92      		push r14
 994 03b8 FF92      		push r15
 995 03ba 0F93      		push r16
 996               	/* prologue: function */
 997               	/* frame size = 0 */
 998               	/* stack size = 3 */
 999               	.L__stack_usage = 3
1935:FreeRTOS/Source/tasks.c **** 								configIDLE_TASK_NAME,
 1001               	.LM101:
 1002 03bc 80E0      		ldi r24,lo8(xIdleTaskHandle)
 1003 03be E82E      		mov r14,r24
 1004 03c0 80E0      		ldi r24,hi8(xIdleTaskHandle)
 1005 03c2 F82E      		mov r15,r24
 1006 03c4 00E0      		ldi r16,0
 1007 03c6 20E0      		ldi r18,0
 1008 03c8 30E0      		ldi r19,0
 1009 03ca 45E5      		ldi r20,lo8(85)
 1010 03cc 50E0      		ldi r21,0
 1011 03ce 60E0      		ldi r22,lo8(.LC0)
 1012 03d0 70E0      		ldi r23,hi8(.LC0)
 1013 03d2 80E0      		ldi r24,lo8(gs(prvIdleTask))
 1014 03d4 90E0      		ldi r25,hi8(gs(prvIdleTask))
 1015 03d6 0E94 0000 		call xTaskCreate
1957:FreeRTOS/Source/tasks.c **** 	{
 1017               	.LM102:
 1018 03da 8130      		cpi r24,lo8(1)
 1019 03dc 01F4      		brne .L54
1973:FreeRTOS/Source/tasks.c **** 
 1021               	.LM103:
 1022               	/* #APP */
 1023               	 ;  1973 "FreeRTOS/Source/tasks.c" 1
 1024 03de F894      		cli
 1025               	 ;  0 "" 2
1983:FreeRTOS/Source/tasks.c **** 		xSchedulerRunning = pdTRUE;
 1027               	.LM104:
 1028               	/* #NOAPP */
 1029 03e0 2FEF      		ldi r18,lo8(-1)
 1030 03e2 3FEF      		ldi r19,lo8(-1)
 1031 03e4 3093 0000 		sts xNextTaskUnblockTime+1,r19
 1032 03e8 2093 0000 		sts xNextTaskUnblockTime,r18
1984:FreeRTOS/Source/tasks.c **** 		xTickCount = ( TickType_t ) 0U;
 1034               	.LM105:
 1035 03ec 8093 0000 		sts xSchedulerRunning,r24
1985:FreeRTOS/Source/tasks.c **** 
 1037               	.LM106:
 1038 03f0 1092 0000 		sts xTickCount+1,__zero_reg__
 1039 03f4 1092 0000 		sts xTickCount,__zero_reg__
 1040               	/* epilogue start */
2018:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 1042               	.LM107:
 1043 03f8 0F91      		pop r16
 1044 03fa FF90      		pop r15
 1045 03fc EF90      		pop r14
1997:FreeRTOS/Source/tasks.c **** 		{
 1047               	.LM108:
 1048 03fe 0C94 0000 		jmp xPortStartScheduler
 1049               	.L54:
 1050               	/* epilogue start */
2018:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 1052               	.LM109:
 1053 0402 0F91      		pop r16
 1054 0404 FF90      		pop r15
 1055 0406 EF90      		pop r14
 1056 0408 0895      		ret
 1061               	.Lscope6:
 1063               		.stabd	78,0,0
 1065               	.global	vTaskEndScheduler
 1067               	vTaskEndScheduler:
 1068               		.stabd	46,0,0
2022:FreeRTOS/Source/tasks.c **** 	/* Stop the scheduler interrupts and call the portable scheduler end
 1070               	.LM110:
 1071               	.LFBB7:
 1072               	/* prologue: function */
 1073               	/* frame size = 0 */
 1074               	/* stack size = 0 */
 1075               	.L__stack_usage = 0
2026:FreeRTOS/Source/tasks.c **** 	xSchedulerRunning = pdFALSE;
 1077               	.LM111:
 1078               	/* #APP */
 1079               	 ;  2026 "FreeRTOS/Source/tasks.c" 1
 1080 040a F894      		cli
 1081               	 ;  0 "" 2
2027:FreeRTOS/Source/tasks.c **** 	vPortEndScheduler();
 1083               	.LM112:
 1084               	/* #NOAPP */
 1085 040c 1092 0000 		sts xSchedulerRunning,__zero_reg__
2028:FreeRTOS/Source/tasks.c **** }
 1087               	.LM113:
 1088 0410 0C94 0000 		jmp vPortEndScheduler
 1090               	.Lscope7:
 1092               		.stabd	78,0,0
 1094               	.global	vTaskSuspendAll
 1096               	vTaskSuspendAll:
 1097               		.stabd	46,0,0
2033:FreeRTOS/Source/tasks.c **** 	/* A critical section is not required as the variable is of type
 1099               	.LM114:
 1100               	.LFBB8:
 1101               	/* prologue: function */
 1102               	/* frame size = 0 */
 1103               	/* stack size = 0 */
 1104               	.L__stack_usage = 0
2038:FreeRTOS/Source/tasks.c **** }
 1106               	.LM115:
 1107 0414 8091 0000 		lds r24,uxSchedulerSuspended
 1108 0418 8F5F      		subi r24,lo8(-(1))
 1109 041a 8093 0000 		sts uxSchedulerSuspended,r24
 1110 041e 0895      		ret
 1112               	.Lscope8:
 1114               		.stabd	78,0,0
 1116               	.global	xTaskGetTickCount
 1118               	xTaskGetTickCount:
 1119               		.stabd	46,0,0
2216:FreeRTOS/Source/tasks.c **** TickType_t xTicks;
 1121               	.LM116:
 1122               	.LFBB9:
 1123               	/* prologue: function */
 1124               	/* frame size = 0 */
 1125               	/* stack size = 0 */
 1126               	.L__stack_usage = 0
2220:FreeRTOS/Source/tasks.c **** 	{
 1128               	.LM117:
 1129               	/* #APP */
 1130               	 ;  2220 "FreeRTOS/Source/tasks.c" 1
 1131 0420 0FB6      		in		__tmp_reg__, __SREG__
 1132               	 ;  0 "" 2
 1133               	 ;  2220 "FreeRTOS/Source/tasks.c" 1
 1134 0422 F894      		cli
 1135               	 ;  0 "" 2
 1136               	 ;  2220 "FreeRTOS/Source/tasks.c" 1
 1137 0424 0F92      		push	__tmp_reg__
 1138               	 ;  0 "" 2
2222:FreeRTOS/Source/tasks.c **** 	}
 1140               	.LM118:
 1141               	/* #NOAPP */
 1142 0426 8091 0000 		lds r24,xTickCount
 1143 042a 9091 0000 		lds r25,xTickCount+1
2224:FreeRTOS/Source/tasks.c **** 
 1145               	.LM119:
 1146               	/* #APP */
 1147               	 ;  2224 "FreeRTOS/Source/tasks.c" 1
 1148 042e 0F90      		pop		__tmp_reg__
 1149               	 ;  0 "" 2
 1150               	 ;  2224 "FreeRTOS/Source/tasks.c" 1
 1151 0430 0FBE      		out		__SREG__, __tmp_reg__
 1152               	 ;  0 "" 2
2227:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 1154               	.LM120:
 1155               	/* #NOAPP */
 1156 0432 0895      		ret
 1161               	.Lscope9:
 1163               		.stabd	78,0,0
 1165               	.global	xTaskGetTickCountFromISR
 1167               	xTaskGetTickCountFromISR:
 1168               		.stabd	46,0,0
2231:FreeRTOS/Source/tasks.c **** TickType_t xReturn;
 1170               	.LM121:
 1171               	.LFBB10:
 1172               	/* prologue: function */
 1173               	/* frame size = 0 */
 1174               	/* stack size = 0 */
 1175               	.L__stack_usage = 0
2253:FreeRTOS/Source/tasks.c **** 	}
 1177               	.LM122:
 1178 0434 8091 0000 		lds r24,xTickCount
 1179 0438 9091 0000 		lds r25,xTickCount+1
2258:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 1181               	.LM123:
 1182 043c 0895      		ret
 1187               	.Lscope10:
 1189               		.stabd	78,0,0
 1191               	.global	uxTaskGetNumberOfTasks
 1193               	uxTaskGetNumberOfTasks:
 1194               		.stabd	46,0,0
2262:FreeRTOS/Source/tasks.c **** 	/* A critical section is not required because the variables are of type
 1196               	.LM124:
 1197               	.LFBB11:
 1198               	/* prologue: function */
 1199               	/* frame size = 0 */
 1200               	/* stack size = 0 */
 1201               	.L__stack_usage = 0
2265:FreeRTOS/Source/tasks.c **** }
 1203               	.LM125:
 1204 043e 8091 0000 		lds r24,uxCurrentNumberOfTasks
2266:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 1206               	.LM126:
 1207 0442 0895      		ret
 1209               	.Lscope11:
 1211               		.stabd	78,0,0
 1214               	.global	pcTaskGetName
 1216               	pcTaskGetName:
 1217               		.stabd	46,0,0
2270:FreeRTOS/Source/tasks.c **** TCB_t *pxTCB;
 1219               	.LM127:
 1220               	.LFBB12:
 1221               	/* prologue: function */
 1222               	/* frame size = 0 */
 1223               	/* stack size = 0 */
 1224               	.L__stack_usage = 0
2275:FreeRTOS/Source/tasks.c **** 	configASSERT( pxTCB );
 1226               	.LM128:
 1227 0444 0097      		sbiw r24,0
 1228 0446 01F4      		brne .L62
2275:FreeRTOS/Source/tasks.c **** 	configASSERT( pxTCB );
 1230               	.LM129:
 1231 0448 8091 0000 		lds r24,pxCurrentTCB
 1232 044c 9091 0000 		lds r25,pxCurrentTCB+1
 1233               	.L62:
2278:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 1235               	.LM130:
 1236 0450 4996      		adiw r24,25
 1237 0452 0895      		ret
 1239               	.Lscope12:
 1241               		.stabd	78,0,0
 1243               	.global	xTaskIncrementTick
 1245               	xTaskIncrementTick:
 1246               		.stabd	46,0,0
2590:FreeRTOS/Source/tasks.c **** TCB_t * pxTCB;
 1248               	.LM131:
 1249               	.LFBB13:
 1250 0454 CF92      		push r12
 1251 0456 DF92      		push r13
 1252 0458 EF92      		push r14
 1253 045a FF92      		push r15
 1254 045c 0F93      		push r16
 1255 045e 1F93      		push r17
 1256 0460 CF93      		push r28
 1257 0462 DF93      		push r29
 1258               	/* prologue: function */
 1259               	/* frame size = 0 */
 1260               	/* stack size = 8 */
 1261               	.L__stack_usage = 8
2599:FreeRTOS/Source/tasks.c **** 	{
 1263               	.LM132:
 1264 0464 8091 0000 		lds r24,uxSchedulerSuspended
 1265 0468 8111      		cpse r24,__zero_reg__
 1266 046a 00C0      		rjmp .L64
 1267               	.LBB46:
2603:FreeRTOS/Source/tasks.c **** 
 1269               	.LM133:
 1270 046c 0091 0000 		lds r16,xTickCount
 1271 0470 1091 0000 		lds r17,xTickCount+1
 1272 0474 0F5F      		subi r16,-1
 1273 0476 1F4F      		sbci r17,-1
2607:FreeRTOS/Source/tasks.c **** 
 1275               	.LM134:
 1276 0478 1093 0000 		sts xTickCount+1,r17
 1277 047c 0093 0000 		sts xTickCount,r16
2609:FreeRTOS/Source/tasks.c **** 		{
 1279               	.LM135:
 1280 0480 0115      		cp r16,__zero_reg__
 1281 0482 1105      		cpc r17,__zero_reg__
 1282 0484 01F4      		brne .L65
 1283               	.LBB47:
2611:FreeRTOS/Source/tasks.c **** 		}
 1285               	.LM136:
 1286 0486 8091 0000 		lds r24,pxDelayedTaskList
 1287 048a 9091 0000 		lds r25,pxDelayedTaskList+1
 1288 048e 2091 0000 		lds r18,pxOverflowDelayedTaskList
 1289 0492 3091 0000 		lds r19,pxOverflowDelayedTaskList+1
 1290 0496 3093 0000 		sts pxDelayedTaskList+1,r19
 1291 049a 2093 0000 		sts pxDelayedTaskList,r18
 1292 049e 9093 0000 		sts pxOverflowDelayedTaskList+1,r25
 1293 04a2 8093 0000 		sts pxOverflowDelayedTaskList,r24
 1294 04a6 8091 0000 		lds r24,xNumOfOverflows
 1295 04aa 8F5F      		subi r24,lo8(-(1))
 1296 04ac 8093 0000 		sts xNumOfOverflows,r24
 1297 04b0 0E94 0000 		call prvResetNextTaskUnblockTime
 1298               	.L65:
 1299               	.LBE47:
2622:FreeRTOS/Source/tasks.c **** 		{
 1301               	.LM137:
 1302 04b4 8091 0000 		lds r24,xNextTaskUnblockTime
 1303 04b8 9091 0000 		lds r25,xNextTaskUnblockTime+1
 1304 04bc C0E0      		ldi r28,0
 1305 04be 0817      		cp r16,r24
 1306 04c0 1907      		cpc r17,r25
 1307 04c2 00F4      		brsh .+2
 1308 04c4 00C0      		rjmp .L67
2676:FreeRTOS/Source/tasks.c **** 
 1310               	.LM138:
 1311 04c6 D9E0      		ldi r29,lo8(9)
 1312               	.L66:
2626:FreeRTOS/Source/tasks.c **** 				{
 1314               	.LM139:
 1315 04c8 E091 0000 		lds r30,pxDelayedTaskList
 1316 04cc F091 0000 		lds r31,pxDelayedTaskList+1
 1317 04d0 8081      		ld r24,Z
 1318 04d2 8111      		cpse r24,__zero_reg__
 1319 04d4 00C0      		rjmp .L68
2633:FreeRTOS/Source/tasks.c **** 					break;
 1321               	.LM140:
 1322 04d6 8FEF      		ldi r24,lo8(-1)
 1323 04d8 9FEF      		ldi r25,lo8(-1)
 1324 04da 00C0      		rjmp .L82
 1325               	.L68:
2642:FreeRTOS/Source/tasks.c **** 					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
 1327               	.LM141:
 1328 04dc E091 0000 		lds r30,pxDelayedTaskList
 1329 04e0 F091 0000 		lds r31,pxDelayedTaskList+1
 1330 04e4 0580      		ldd __tmp_reg__,Z+5
 1331 04e6 F681      		ldd r31,Z+6
 1332 04e8 E02D      		mov r30,__tmp_reg__
 1333 04ea E680      		ldd r14,Z+6
 1334 04ec F780      		ldd r15,Z+7
2643:FreeRTOS/Source/tasks.c **** 
 1336               	.LM142:
 1337 04ee D701      		movw r26,r14
 1338 04f0 1296      		adiw r26,2
 1339 04f2 8D91      		ld r24,X+
 1340 04f4 9C91      		ld r25,X
 1341 04f6 1397      		sbiw r26,2+1
2645:FreeRTOS/Source/tasks.c **** 					{
 1343               	.LM143:
 1344 04f8 0817      		cp r16,r24
 1345 04fa 1907      		cpc r17,r25
 1346 04fc 00F4      		brsh .L69
 1347               	.L82:
2652:FreeRTOS/Source/tasks.c **** 						break;
 1349               	.LM144:
 1350 04fe 9093 0000 		sts xNextTaskUnblockTime+1,r25
 1351 0502 8093 0000 		sts xNextTaskUnblockTime,r24
2653:FreeRTOS/Source/tasks.c **** 					}
 1353               	.LM145:
 1354 0506 00C0      		rjmp .L67
 1355               	.L69:
2661:FreeRTOS/Source/tasks.c **** 
 1357               	.LM146:
 1358 0508 6701      		movw r12,r14
 1359 050a B2E0      		ldi r27,2
 1360 050c CB0E      		add r12,r27
 1361 050e D11C      		adc r13,__zero_reg__
 1362 0510 C601      		movw r24,r12
 1363 0512 0E94 0000 		call uxListRemove
2665:FreeRTOS/Source/tasks.c **** 					{
 1365               	.LM147:
 1366 0516 F701      		movw r30,r14
 1367 0518 8489      		ldd r24,Z+20
 1368 051a 9589      		ldd r25,Z+21
 1369 051c 892B      		or r24,r25
 1370 051e 01F0      		breq .L70
2667:FreeRTOS/Source/tasks.c **** 					}
 1372               	.LM148:
 1373 0520 C701      		movw r24,r14
 1374 0522 0C96      		adiw r24,12
 1375 0524 0E94 0000 		call uxListRemove
 1376               	.L70:
2676:FreeRTOS/Source/tasks.c **** 
 1378               	.LM149:
 1379 0528 D701      		movw r26,r14
 1380 052a 5696      		adiw r26,22
 1381 052c 9C91      		ld r25,X
 1382 052e 8091 0000 		lds r24,uxTopReadyPriority
 1383 0532 8917      		cp r24,r25
 1384 0534 00F4      		brsh .L71
2676:FreeRTOS/Source/tasks.c **** 
 1386               	.LM150:
 1387 0536 9093 0000 		sts uxTopReadyPriority,r25
 1388               	.L71:
2676:FreeRTOS/Source/tasks.c **** 
 1390               	.LM151:
 1391 053a D99F      		mul r29,r25
 1392 053c C001      		movw r24,r0
 1393 053e 1124      		clr __zero_reg__
 1394 0540 B601      		movw r22,r12
 1395 0542 8050      		subi r24,lo8(-(pxReadyTasksLists))
 1396 0544 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 1397 0546 0E94 0000 		call vListInsertEnd
2686:FreeRTOS/Source/tasks.c **** 						{
 1399               	.LM152:
 1400 054a E091 0000 		lds r30,pxCurrentTCB
 1401 054e F091 0000 		lds r31,pxCurrentTCB+1
 1402 0552 D701      		movw r26,r14
 1403 0554 5696      		adiw r26,22
 1404 0556 9C91      		ld r25,X
 1405 0558 8689      		ldd r24,Z+22
 1406 055a 9817      		cp r25,r24
 1407 055c 00F4      		brsh .+2
 1408 055e 00C0      		rjmp .L66
2688:FreeRTOS/Source/tasks.c **** 						}
 1410               	.LM153:
 1411 0560 C1E0      		ldi r28,lo8(1)
 1412 0562 00C0      		rjmp .L66
 1413               	.L67:
2705:FreeRTOS/Source/tasks.c **** 			{
 1415               	.LM154:
 1416 0564 E091 0000 		lds r30,pxCurrentTCB
 1417 0568 F091 0000 		lds r31,pxCurrentTCB+1
 1418 056c E689      		ldd r30,Z+22
 1419 056e B9E0      		ldi r27,lo8(9)
 1420 0570 EB9F      		mul r30,r27
 1421 0572 F001      		movw r30,r0
 1422 0574 1124      		clr __zero_reg__
 1423 0576 E050      		subi r30,lo8(-(pxReadyTasksLists))
 1424 0578 F040      		sbci r31,hi8(-(pxReadyTasksLists))
 1425 057a 8081      		ld r24,Z
 1426 057c 8230      		cpi r24,lo8(2)
 1427 057e 00F0      		brlo .L73
2707:FreeRTOS/Source/tasks.c **** 			}
 1429               	.LM155:
 1430 0580 C1E0      		ldi r28,lo8(1)
 1431 0582 00C0      		rjmp .L73
 1432               	.L64:
 1433               	.LBE46:
2733:FreeRTOS/Source/tasks.c **** 
 1435               	.LM156:
 1436 0584 8091 0000 		lds r24,uxPendedTicks
 1437 0588 8F5F      		subi r24,lo8(-(1))
 1438 058a 8093 0000 		sts uxPendedTicks,r24
2593:FreeRTOS/Source/tasks.c **** 
 1440               	.LM157:
 1441 058e C0E0      		ldi r28,0
 1442               	.L73:
2746:FreeRTOS/Source/tasks.c **** 		{
 1444               	.LM158:
 1445 0590 8091 0000 		lds r24,xYieldPending
 1446 0594 8111      		cpse r24,__zero_reg__
2748:FreeRTOS/Source/tasks.c **** 		}
 1448               	.LM159:
 1449 0596 C1E0      		ldi r28,lo8(1)
 1450               	.L74:
2758:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 1452               	.LM160:
 1453 0598 8C2F      		mov r24,r28
 1454               	/* epilogue start */
 1455 059a DF91      		pop r29
 1456 059c CF91      		pop r28
 1457 059e 1F91      		pop r17
 1458 05a0 0F91      		pop r16
 1459 05a2 FF90      		pop r15
 1460 05a4 EF90      		pop r14
 1461 05a6 DF90      		pop r13
 1462 05a8 CF90      		pop r12
 1463 05aa 0895      		ret
 1476               	.Lscope13:
 1478               		.stabd	78,0,0
 1480               	.global	xTaskResumeAll
 1482               	xTaskResumeAll:
 1483               		.stabd	46,0,0
2106:FreeRTOS/Source/tasks.c **** TCB_t *pxTCB = NULL;
 1485               	.LM161:
 1486               	.LFBB14:
 1487 05ac EF92      		push r14
 1488 05ae FF92      		push r15
 1489 05b0 0F93      		push r16
 1490 05b2 1F93      		push r17
 1491 05b4 CF93      		push r28
 1492 05b6 DF93      		push r29
 1493               	/* prologue: function */
 1494               	/* frame size = 0 */
 1495               	/* stack size = 6 */
 1496               	.L__stack_usage = 6
2119:FreeRTOS/Source/tasks.c **** 	{
 1498               	.LM162:
 1499               	/* #APP */
 1500               	 ;  2119 "FreeRTOS/Source/tasks.c" 1
 1501 05b8 0FB6      		in		__tmp_reg__, __SREG__
 1502               	 ;  0 "" 2
 1503               	 ;  2119 "FreeRTOS/Source/tasks.c" 1
 1504 05ba F894      		cli
 1505               	 ;  0 "" 2
 1506               	 ;  2119 "FreeRTOS/Source/tasks.c" 1
 1507 05bc 0F92      		push	__tmp_reg__
 1508               	 ;  0 "" 2
2121:FreeRTOS/Source/tasks.c **** 
 1510               	.LM163:
 1511               	/* #NOAPP */
 1512 05be 8091 0000 		lds r24,uxSchedulerSuspended
 1513 05c2 8150      		subi r24,lo8(-(-1))
 1514 05c4 8093 0000 		sts uxSchedulerSuspended,r24
2123:FreeRTOS/Source/tasks.c **** 		{
 1516               	.LM164:
 1517 05c8 8091 0000 		lds r24,uxSchedulerSuspended
 1518 05cc 8823      		tst r24
 1519 05ce 01F0      		breq .L84
 1520               	.L87:
2108:FreeRTOS/Source/tasks.c **** 
 1522               	.LM165:
 1523 05d0 80E0      		ldi r24,0
 1524 05d2 00C0      		rjmp .L85
 1525               	.L84:
2125:FreeRTOS/Source/tasks.c **** 			{
 1527               	.LM166:
 1528 05d4 8091 0000 		lds r24,uxCurrentNumberOfTasks
 1529 05d8 8823      		tst r24
 1530 05da 01F0      		breq .L87
 1531 05dc C0E0      		ldi r28,0
 1532 05de D0E0      		ldi r29,0
2134:FreeRTOS/Source/tasks.c **** 
 1534               	.LM167:
 1535 05e0 89E0      		ldi r24,lo8(9)
 1536 05e2 F82E      		mov r15,r24
2140:FreeRTOS/Source/tasks.c **** 					}
 1538               	.LM168:
 1539 05e4 EE24      		clr r14
 1540 05e6 E394      		inc r14
 1541               	.L86:
2129:FreeRTOS/Source/tasks.c **** 				{
 1543               	.LM169:
 1544 05e8 8091 0000 		lds r24,xPendingReadyList
 1545 05ec 8823      		tst r24
 1546 05ee 01F0      		breq .L109
2131:FreeRTOS/Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 1548               	.LM170:
 1549 05f0 E091 0000 		lds r30,xPendingReadyList+5
 1550 05f4 F091 0000 		lds r31,xPendingReadyList+5+1
 1551 05f8 C681      		ldd r28,Z+6
 1552 05fa D781      		ldd r29,Z+7
2132:FreeRTOS/Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 1554               	.LM171:
 1555 05fc CE01      		movw r24,r28
 1556 05fe 0C96      		adiw r24,12
 1557 0600 0E94 0000 		call uxListRemove
2133:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 1559               	.LM172:
 1560 0604 8E01      		movw r16,r28
 1561 0606 0E5F      		subi r16,-2
 1562 0608 1F4F      		sbci r17,-1
 1563 060a C801      		movw r24,r16
 1564 060c 0E94 0000 		call uxListRemove
2134:FreeRTOS/Source/tasks.c **** 
 1566               	.LM173:
 1567 0610 9E89      		ldd r25,Y+22
 1568 0612 8091 0000 		lds r24,uxTopReadyPriority
 1569 0616 8917      		cp r24,r25
 1570 0618 00F4      		brsh .L88
2134:FreeRTOS/Source/tasks.c **** 
 1572               	.LM174:
 1573 061a 9093 0000 		sts uxTopReadyPriority,r25
 1574               	.L88:
2134:FreeRTOS/Source/tasks.c **** 
 1576               	.LM175:
 1577 061e F99E      		mul r15,r25
 1578 0620 C001      		movw r24,r0
 1579 0622 1124      		clr __zero_reg__
 1580 0624 B801      		movw r22,r16
 1581 0626 8050      		subi r24,lo8(-(pxReadyTasksLists))
 1582 0628 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 1583 062a 0E94 0000 		call vListInsertEnd
2138:FreeRTOS/Source/tasks.c **** 					{
 1585               	.LM176:
 1586 062e E091 0000 		lds r30,pxCurrentTCB
 1587 0632 F091 0000 		lds r31,pxCurrentTCB+1
 1588 0636 9E89      		ldd r25,Y+22
 1589 0638 8689      		ldd r24,Z+22
 1590 063a 9817      		cp r25,r24
 1591 063c 00F0      		brlo .L86
2140:FreeRTOS/Source/tasks.c **** 					}
 1593               	.LM177:
 1594 063e E092 0000 		sts xYieldPending,r14
 1595 0642 00C0      		rjmp .L86
 1596               	.L109:
2148:FreeRTOS/Source/tasks.c **** 				{
 1598               	.LM178:
 1599 0644 CD2B      		or r28,r29
 1600 0646 01F0      		breq .L91
2156:FreeRTOS/Source/tasks.c **** 				}
 1602               	.LM179:
 1603 0648 0E94 0000 		call prvResetNextTaskUnblockTime
 1604               	.L91:
 1605               	.LBB48:
2164:FreeRTOS/Source/tasks.c **** 
 1607               	.LM180:
 1608 064c C091 0000 		lds r28,uxPendedTicks
2166:FreeRTOS/Source/tasks.c **** 					{
 1610               	.LM181:
 1611 0650 CC23      		tst r28
 1612 0652 01F0      		breq .L92
2172:FreeRTOS/Source/tasks.c **** 							}
 1614               	.LM182:
 1615 0654 D1E0      		ldi r29,lo8(1)
 1616               	.L94:
2170:FreeRTOS/Source/tasks.c **** 							{
 1618               	.LM183:
 1619 0656 0E94 0000 		call xTaskIncrementTick
 1620 065a 8111      		cpse r24,__zero_reg__
2172:FreeRTOS/Source/tasks.c **** 							}
 1622               	.LM184:
 1623 065c D093 0000 		sts xYieldPending,r29
 1624               	.L93:
2178:FreeRTOS/Source/tasks.c **** 						} while( uxPendedCounts > ( UBaseType_t ) 0U );
 1626               	.LM185:
 1627 0660 C150      		subi r28,lo8(-(-1))
2179:FreeRTOS/Source/tasks.c **** 
 1629               	.LM186:
 1630 0662 01F4      		brne .L94
2181:FreeRTOS/Source/tasks.c **** 					}
 1632               	.LM187:
 1633 0664 1092 0000 		sts uxPendedTicks,__zero_reg__
 1634               	.L92:
 1635               	.LBE48:
2189:FreeRTOS/Source/tasks.c **** 				{
 1637               	.LM188:
 1638 0668 8091 0000 		lds r24,xYieldPending
 1639 066c 8823      		tst r24
 1640 066e 01F4      		brne .+2
 1641 0670 00C0      		rjmp .L87
2196:FreeRTOS/Source/tasks.c **** 				}
 1643               	.LM189:
 1644 0672 0E94 0000 		call vPortYield
2193:FreeRTOS/Source/tasks.c **** 					}
 1646               	.LM190:
 1647 0676 81E0      		ldi r24,lo8(1)
 1648               	.L85:
2209:FreeRTOS/Source/tasks.c **** 
 1650               	.LM191:
 1651               	/* #APP */
 1652               	 ;  2209 "FreeRTOS/Source/tasks.c" 1
 1653 0678 0F90      		pop		__tmp_reg__
 1654               	 ;  0 "" 2
 1655               	 ;  2209 "FreeRTOS/Source/tasks.c" 1
 1656 067a 0FBE      		out		__SREG__, __tmp_reg__
 1657               	 ;  0 "" 2
 1658               	/* epilogue start */
2212:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 1660               	.LM192:
 1661               	/* #NOAPP */
 1662 067c DF91      		pop r29
 1663 067e CF91      		pop r28
 1664 0680 1F91      		pop r17
 1665 0682 0F91      		pop r16
 1666 0684 FF90      		pop r15
 1667 0686 EF90      		pop r14
 1668 0688 0895      		ret
 1677               	.Lscope14:
 1679               		.stabd	78,0,0
 1683               	.global	vTaskDelayUntil
 1685               	vTaskDelayUntil:
 1686               		.stabd	46,0,0
1205:FreeRTOS/Source/tasks.c **** 	TickType_t xTimeToWake;
 1688               	.LM193:
 1689               	.LFBB15:
 1690 068a 0F93      		push r16
 1691 068c 1F93      		push r17
 1692 068e CF93      		push r28
 1693 0690 DF93      		push r29
 1694               	/* prologue: function */
 1695               	/* frame size = 0 */
 1696               	/* stack size = 4 */
 1697               	.L__stack_usage = 4
 1698 0692 8C01      		movw r16,r24
 1699 0694 EB01      		movw r28,r22
1213:FreeRTOS/Source/tasks.c **** 		{
 1701               	.LM194:
 1702 0696 0E94 0000 		call vTaskSuspendAll
 1703               	.LBB49:
1217:FreeRTOS/Source/tasks.c **** 
 1705               	.LM195:
 1706 069a 2091 0000 		lds r18,xTickCount
 1707 069e 3091 0000 		lds r19,xTickCount+1
1220:FreeRTOS/Source/tasks.c **** 
 1709               	.LM196:
 1710 06a2 F801      		movw r30,r16
 1711 06a4 4081      		ld r20,Z
 1712 06a6 5181      		ldd r21,Z+1
 1713 06a8 BA01      		movw r22,r20
 1714 06aa 6C0F      		add r22,r28
 1715 06ac 7D1F      		adc r23,r29
1222:FreeRTOS/Source/tasks.c **** 			{
 1717               	.LM197:
 1718 06ae 2417      		cp r18,r20
 1719 06b0 3507      		cpc r19,r21
 1720 06b2 00F4      		brsh .L111
1229:FreeRTOS/Source/tasks.c **** 				{
 1722               	.LM198:
 1723 06b4 6417      		cp r22,r20
 1724 06b6 7507      		cpc r23,r21
 1725 06b8 00F4      		brsh .L117
1229:FreeRTOS/Source/tasks.c **** 				{
 1727               	.LM199:
 1728 06ba 91E0      		ldi r25,lo8(1)
 1729 06bc 00C0      		rjmp .L124
 1730               	.L111:
1245:FreeRTOS/Source/tasks.c **** 				}
 1732               	.LM200:
 1733 06be 91E0      		ldi r25,lo8(1)
1243:FreeRTOS/Source/tasks.c **** 				{
 1735               	.LM201:
 1736 06c0 6417      		cp r22,r20
 1737 06c2 7507      		cpc r23,r21
 1738 06c4 00F0      		brlo .L112
 1739               	.L124:
1243:FreeRTOS/Source/tasks.c **** 				{
 1741               	.LM202:
 1742 06c6 2617      		cp r18,r22
 1743 06c8 3707      		cpc r19,r23
 1744 06ca 00F0      		brlo .L112
 1745               	.L117:
 1746               	.LBE49:
1207:FreeRTOS/Source/tasks.c **** 
 1748               	.LM203:
 1749 06cc 90E0      		ldi r25,0
 1750               	.L112:
 1751               	.LBB50:
1254:FreeRTOS/Source/tasks.c **** 
 1753               	.LM204:
 1754 06ce F801      		movw r30,r16
 1755 06d0 7183      		std Z+1,r23
 1756 06d2 6083      		st Z,r22
1256:FreeRTOS/Source/tasks.c **** 			{
 1758               	.LM205:
 1759 06d4 9923      		tst r25
 1760 06d6 01F0      		breq .L115
1262:FreeRTOS/Source/tasks.c **** 			}
 1762               	.LM206:
 1763 06d8 CB01      		movw r24,r22
 1764 06da 821B      		sub r24,r18
 1765 06dc 930B      		sbc r25,r19
 1766 06de 0E94 0000 		call prvAddCurrentTaskToDelayedList.isra.2
 1767               	.L115:
 1768               	.LBE50:
1269:FreeRTOS/Source/tasks.c **** 
 1770               	.LM207:
 1771 06e2 0E94 0000 		call xTaskResumeAll
1273:FreeRTOS/Source/tasks.c **** 		{
 1773               	.LM208:
 1774 06e6 8111      		cpse r24,__zero_reg__
 1775 06e8 00C0      		rjmp .L110
1275:FreeRTOS/Source/tasks.c **** 		}
 1777               	.LM209:
 1778 06ea 0E94 0000 		call vPortYield
 1779               	.L110:
 1780               	/* epilogue start */
1281:FreeRTOS/Source/tasks.c **** 
 1782               	.LM210:
 1783 06ee DF91      		pop r29
 1784 06f0 CF91      		pop r28
 1785 06f2 1F91      		pop r17
 1786 06f4 0F91      		pop r16
 1787 06f6 0895      		ret
 1799               	.Lscope15:
 1801               		.stabd	78,0,0
 1804               	.global	vTaskDelay
 1806               	vTaskDelay:
 1807               		.stabd	46,0,0
1289:FreeRTOS/Source/tasks.c **** 	BaseType_t xAlreadyYielded = pdFALSE;
 1809               	.LM211:
 1810               	.LFBB16:
 1811 06f8 CF93      		push r28
 1812 06fa DF93      		push r29
 1813 06fc 00D0      		rcall .
 1814 06fe CDB7      		in r28,__SP_L__
 1815 0700 DEB7      		in r29,__SP_H__
 1816               	/* prologue: function */
 1817               	/* frame size = 2 */
 1818               	/* stack size = 4 */
 1819               	.L__stack_usage = 4
1293:FreeRTOS/Source/tasks.c **** 		{
 1821               	.LM212:
 1822 0702 0097      		sbiw r24,0
 1823 0704 01F4      		brne .L126
 1824               	.L128:
1320:FreeRTOS/Source/tasks.c **** 		}
 1826               	.LM213:
 1827 0706 0E94 0000 		call vPortYield
 1828 070a 00C0      		rjmp .L125
 1829               	.L126:
1296:FreeRTOS/Source/tasks.c **** 			{
 1831               	.LM214:
 1832 070c 8983      		std Y+1,r24
 1833 070e 9A83      		std Y+2,r25
 1834 0710 0E94 0000 		call vTaskSuspendAll
1307:FreeRTOS/Source/tasks.c **** 			}
 1836               	.LM215:
 1837 0714 8981      		ldd r24,Y+1
 1838 0716 9A81      		ldd r25,Y+2
 1839 0718 0E94 0000 		call prvAddCurrentTaskToDelayedList.isra.2
1309:FreeRTOS/Source/tasks.c **** 		}
 1841               	.LM216:
 1842 071c 0E94 0000 		call xTaskResumeAll
1318:FreeRTOS/Source/tasks.c **** 		{
 1844               	.LM217:
 1845 0720 8823      		tst r24
 1846 0722 01F0      		breq .L128
 1847               	.L125:
 1848               	/* epilogue start */
1326:FreeRTOS/Source/tasks.c **** 
 1850               	.LM218:
 1851 0724 0F90      		pop __tmp_reg__
 1852 0726 0F90      		pop __tmp_reg__
 1853 0728 DF91      		pop r29
 1854 072a CF91      		pop r28
 1855 072c 0895      		ret
 1857               	.Lscope16:
 1859               		.stabd	78,0,0
 1861               	.global	vTaskSwitchContext
 1863               	vTaskSwitchContext:
 1864               		.stabd	46,0,0
2852:FreeRTOS/Source/tasks.c **** 	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 1866               	.LM219:
 1867               	.LFBB17:
 1868               	/* prologue: function */
 1869               	/* frame size = 0 */
 1870               	/* stack size = 0 */
 1871               	.L__stack_usage = 0
2853:FreeRTOS/Source/tasks.c **** 	{
 1873               	.LM220:
 1874 072e 8091 0000 		lds r24,uxSchedulerSuspended
 1875 0732 8823      		tst r24
 1876 0734 01F0      		breq .L133
2857:FreeRTOS/Source/tasks.c **** 	}
 1878               	.LM221:
 1879 0736 81E0      		ldi r24,lo8(1)
 1880 0738 8093 0000 		sts xYieldPending,r24
 1881 073c 0895      		ret
 1882               	.L133:
2861:FreeRTOS/Source/tasks.c **** 		traceTASK_SWITCHED_OUT();
 1884               	.LM222:
 1885 073e 1092 0000 		sts xYieldPending,__zero_reg__
 1886               	.LBB51:
2896:FreeRTOS/Source/tasks.c **** 		traceTASK_SWITCHED_IN();
 1888               	.LM223:
 1889 0742 8091 0000 		lds r24,uxTopReadyPriority
 1890 0746 69E0      		ldi r22,lo8(9)
 1891               	.L135:
2896:FreeRTOS/Source/tasks.c **** 		traceTASK_SWITCHED_IN();
 1893               	.LM224:
 1894 0748 482F      		mov r20,r24
 1895 074a 50E0      		ldi r21,0
 1896 074c 649F      		mul r22,r20
 1897 074e 9001      		movw r18,r0
 1898 0750 659F      		mul r22,r21
 1899 0752 300D      		add r19,r0
 1900 0754 1124      		clr __zero_reg__
 1901 0756 F901      		movw r30,r18
 1902 0758 E050      		subi r30,lo8(-(pxReadyTasksLists))
 1903 075a F040      		sbci r31,hi8(-(pxReadyTasksLists))
 1904 075c 9081      		ld r25,Z
 1905 075e 9111      		cpse r25,__zero_reg__
 1906 0760 00C0      		rjmp .L138
2896:FreeRTOS/Source/tasks.c **** 		traceTASK_SWITCHED_IN();
 1908               	.LM225:
 1909 0762 8150      		subi r24,lo8(-(-1))
 1910 0764 00C0      		rjmp .L135
 1911               	.L138:
 1912               	.LBB52:
2896:FreeRTOS/Source/tasks.c **** 		traceTASK_SWITCHED_IN();
 1914               	.LM226:
 1915 0766 A181      		ldd r26,Z+1
 1916 0768 B281      		ldd r27,Z+2
 1917 076a 1296      		adiw r26,2
 1918 076c 0D90      		ld __tmp_reg__,X+
 1919 076e BC91      		ld r27,X
 1920 0770 A02D      		mov r26,__tmp_reg__
 1921 0772 B283      		std Z+2,r27
 1922 0774 A183      		std Z+1,r26
 1923 0776 2050      		subi r18,lo8(-(pxReadyTasksLists+3))
 1924 0778 3040      		sbci r19,hi8(-(pxReadyTasksLists+3))
 1925 077a A217      		cp r26,r18
 1926 077c B307      		cpc r27,r19
 1927 077e 01F4      		brne .L137
2896:FreeRTOS/Source/tasks.c **** 		traceTASK_SWITCHED_IN();
 1929               	.LM227:
 1930 0780 1296      		adiw r26,2
 1931 0782 2D91      		ld r18,X+
 1932 0784 3C91      		ld r19,X
 1933 0786 1397      		sbiw r26,2+1
 1934 0788 3283      		std Z+2,r19
 1935 078a 2183      		std Z+1,r18
 1936               	.L137:
2896:FreeRTOS/Source/tasks.c **** 		traceTASK_SWITCHED_IN();
 1938               	.LM228:
 1939 078c 99E0      		ldi r25,lo8(9)
 1940 078e 949F      		mul r25,r20
 1941 0790 F001      		movw r30,r0
 1942 0792 959F      		mul r25,r21
 1943 0794 F00D      		add r31,r0
 1944 0796 1124      		clr __zero_reg__
 1945 0798 E050      		subi r30,lo8(-(pxReadyTasksLists))
 1946 079a F040      		sbci r31,hi8(-(pxReadyTasksLists))
 1947 079c 0180      		ldd __tmp_reg__,Z+1
 1948 079e F281      		ldd r31,Z+2
 1949 07a0 E02D      		mov r30,__tmp_reg__
 1950 07a2 2681      		ldd r18,Z+6
 1951 07a4 3781      		ldd r19,Z+7
 1952 07a6 3093 0000 		sts pxCurrentTCB+1,r19
 1953 07aa 2093 0000 		sts pxCurrentTCB,r18
 1954               	.LBE52:
 1955 07ae 8093 0000 		sts uxTopReadyPriority,r24
 1956 07b2 0895      		ret
 1957               	.LBE51:
 1962               	.Lscope17:
 1964               		.stabd	78,0,0
 1968               	.global	vTaskPlaceOnEventList
 1970               	vTaskPlaceOnEventList:
 1971               		.stabd	46,0,0
2911:FreeRTOS/Source/tasks.c **** 	configASSERT( pxEventList );
 1973               	.LM229:
 1974               	.LFBB18:
 1975 07b4 CF93      		push r28
 1976 07b6 DF93      		push r29
 1977               	/* prologue: function */
 1978               	/* frame size = 0 */
 1979               	/* stack size = 2 */
 1980               	.L__stack_usage = 2
 1981 07b8 EB01      		movw r28,r22
2921:FreeRTOS/Source/tasks.c **** 
 1983               	.LM230:
 1984 07ba 2091 0000 		lds r18,pxCurrentTCB
 1985 07be 3091 0000 		lds r19,pxCurrentTCB+1
 1986 07c2 B901      		movw r22,r18
 1987 07c4 645F      		subi r22,-12
 1988 07c6 7F4F      		sbci r23,-1
 1989 07c8 0E94 0000 		call vListInsert
2923:FreeRTOS/Source/tasks.c **** }
 1991               	.LM231:
 1992 07cc CE01      		movw r24,r28
 1993               	/* epilogue start */
2924:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 1995               	.LM232:
 1996 07ce DF91      		pop r29
 1997 07d0 CF91      		pop r28
2923:FreeRTOS/Source/tasks.c **** }
 1999               	.LM233:
 2000 07d2 0C94 0000 		jmp prvAddCurrentTaskToDelayedList.isra.2
 2002               	.Lscope18:
 2004               		.stabd	78,0,0
 2009               	.global	vTaskPlaceOnUnorderedEventList
 2011               	vTaskPlaceOnUnorderedEventList:
 2012               		.stabd	46,0,0
2928:FreeRTOS/Source/tasks.c **** 	configASSERT( pxEventList );
 2014               	.LM234:
 2015               	.LFBB19:
 2016 07d6 CF93      		push r28
 2017 07d8 DF93      		push r29
 2018               	/* prologue: function */
 2019               	/* frame size = 0 */
 2020               	/* stack size = 2 */
 2021               	.L__stack_usage = 2
 2022 07da EA01      		movw r28,r20
2938:FreeRTOS/Source/tasks.c **** 
 2024               	.LM235:
 2025 07dc E091 0000 		lds r30,pxCurrentTCB
 2026 07e0 F091 0000 		lds r31,pxCurrentTCB+1
 2027 07e4 7068      		ori r23,128
 2028 07e6 7587      		std Z+13,r23
 2029 07e8 6487      		std Z+12,r22
2945:FreeRTOS/Source/tasks.c **** 
 2031               	.LM236:
 2032 07ea 6091 0000 		lds r22,pxCurrentTCB
 2033 07ee 7091 0000 		lds r23,pxCurrentTCB+1
 2034 07f2 645F      		subi r22,-12
 2035 07f4 7F4F      		sbci r23,-1
 2036 07f6 0E94 0000 		call vListInsertEnd
2947:FreeRTOS/Source/tasks.c **** }
 2038               	.LM237:
 2039 07fa CE01      		movw r24,r28
 2040               	/* epilogue start */
2948:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 2042               	.LM238:
 2043 07fc DF91      		pop r29
 2044 07fe CF91      		pop r28
2947:FreeRTOS/Source/tasks.c **** }
 2046               	.LM239:
 2047 0800 0C94 0000 		jmp prvAddCurrentTaskToDelayedList.isra.2
 2049               	.Lscope19:
 2051               		.stabd	78,0,0
 2054               	.global	xTaskRemoveFromEventList
 2056               	xTaskRemoveFromEventList:
 2057               		.stabd	46,0,0
2985:FreeRTOS/Source/tasks.c **** TCB_t *pxUnblockedTCB;
 2059               	.LM240:
 2060               	.LFBB20:
 2061 0804 0F93      		push r16
 2062 0806 1F93      		push r17
 2063 0808 CF93      		push r28
 2064 080a DF93      		push r29
 2065               	/* prologue: function */
 2066               	/* frame size = 0 */
 2067               	/* stack size = 4 */
 2068               	.L__stack_usage = 4
3002:FreeRTOS/Source/tasks.c **** 	configASSERT( pxUnblockedTCB );
 2070               	.LM241:
 2071 080c DC01      		movw r26,r24
 2072 080e 1596      		adiw r26,5
 2073 0810 ED91      		ld r30,X+
 2074 0812 FC91      		ld r31,X
 2075 0814 1697      		sbiw r26,5+1
 2076 0816 C681      		ldd r28,Z+6
 2077 0818 D781      		ldd r29,Z+7
3004:FreeRTOS/Source/tasks.c **** 
 2079               	.LM242:
 2080 081a 8E01      		movw r16,r28
 2081 081c 045F      		subi r16,-12
 2082 081e 1F4F      		sbci r17,-1
 2083 0820 C801      		movw r24,r16
 2084 0822 0E94 0000 		call uxListRemove
3006:FreeRTOS/Source/tasks.c **** 	{
 2086               	.LM243:
 2087 0826 8091 0000 		lds r24,uxSchedulerSuspended
 2088 082a 8111      		cpse r24,__zero_reg__
 2089 082c 00C0      		rjmp .L142
3008:FreeRTOS/Source/tasks.c **** 		prvAddTaskToReadyList( pxUnblockedTCB );
 2091               	.LM244:
 2092 082e 0A50      		subi r16,10
 2093 0830 1109      		sbc r17,__zero_reg__
 2094 0832 C801      		movw r24,r16
 2095 0834 0E94 0000 		call uxListRemove
3009:FreeRTOS/Source/tasks.c **** 	}
 2097               	.LM245:
 2098 0838 9E89      		ldd r25,Y+22
 2099 083a 8091 0000 		lds r24,uxTopReadyPriority
 2100 083e 8917      		cp r24,r25
 2101 0840 00F4      		brsh .L143
3009:FreeRTOS/Source/tasks.c **** 	}
 2103               	.LM246:
 2104 0842 9093 0000 		sts uxTopReadyPriority,r25
 2105               	.L143:
3009:FreeRTOS/Source/tasks.c **** 	}
 2107               	.LM247:
 2108 0846 B9E0      		ldi r27,lo8(9)
 2109 0848 9B9F      		mul r25,r27
 2110 084a C001      		movw r24,r0
 2111 084c 1124      		clr __zero_reg__
 2112 084e B801      		movw r22,r16
 2113 0850 8050      		subi r24,lo8(-(pxReadyTasksLists))
 2114 0852 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 2115 0854 00C0      		rjmp .L147
 2116               	.L142:
3015:FreeRTOS/Source/tasks.c **** 	}
 2118               	.LM248:
 2119 0856 B801      		movw r22,r16
 2120 0858 80E0      		ldi r24,lo8(xPendingReadyList)
 2121 085a 90E0      		ldi r25,hi8(xPendingReadyList)
 2122               	.L147:
 2123 085c 0E94 0000 		call vListInsertEnd
3018:FreeRTOS/Source/tasks.c **** 	{
 2125               	.LM249:
 2126 0860 E091 0000 		lds r30,pxCurrentTCB
 2127 0864 F091 0000 		lds r31,pxCurrentTCB+1
 2128 0868 9E89      		ldd r25,Y+22
 2129 086a 8689      		ldd r24,Z+22
 2130 086c 8917      		cp r24,r25
 2131 086e 00F4      		brsh .L146
3027:FreeRTOS/Source/tasks.c **** 	}
 2133               	.LM250:
 2134 0870 81E0      		ldi r24,lo8(1)
 2135 0872 8093 0000 		sts xYieldPending,r24
 2136 0876 00C0      		rjmp .L145
 2137               	.L146:
3031:FreeRTOS/Source/tasks.c **** 	}
 2139               	.LM251:
 2140 0878 80E0      		ldi r24,0
 2141               	.L145:
 2142               	/* epilogue start */
3049:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 2144               	.LM252:
 2145 087a DF91      		pop r29
 2146 087c CF91      		pop r28
 2147 087e 1F91      		pop r17
 2148 0880 0F91      		pop r16
 2149 0882 0895      		ret
 2155               	.Lscope20:
 2157               		.stabd	78,0,0
 2161               	.global	vTaskRemoveFromUnorderedEventList
 2163               	vTaskRemoveFromUnorderedEventList:
 2164               		.stabd	46,0,0
3053:FreeRTOS/Source/tasks.c **** TCB_t *pxUnblockedTCB;
 2166               	.LM253:
 2167               	.LFBB21:
 2168 0884 0F93      		push r16
 2169 0886 1F93      		push r17
 2170 0888 CF93      		push r28
 2171 088a DF93      		push r29
 2172               	/* prologue: function */
 2173               	/* frame size = 0 */
 2174               	/* stack size = 4 */
 2175               	.L__stack_usage = 4
3061:FreeRTOS/Source/tasks.c **** 
 2177               	.LM254:
 2178 088c 7068      		ori r23,128
 2179 088e FC01      		movw r30,r24
 2180 0890 7183      		std Z+1,r23
 2181 0892 6083      		st Z,r22
3065:FreeRTOS/Source/tasks.c **** 	configASSERT( pxUnblockedTCB );
 2183               	.LM255:
 2184 0894 C681      		ldd r28,Z+6
 2185 0896 D781      		ldd r29,Z+7
3067:FreeRTOS/Source/tasks.c **** 
 2187               	.LM256:
 2188 0898 0E94 0000 		call uxListRemove
3072:FreeRTOS/Source/tasks.c **** 	prvAddTaskToReadyList( pxUnblockedTCB );
 2190               	.LM257:
 2191 089c 8E01      		movw r16,r28
 2192 089e 0E5F      		subi r16,-2
 2193 08a0 1F4F      		sbci r17,-1
 2194 08a2 C801      		movw r24,r16
 2195 08a4 0E94 0000 		call uxListRemove
3073:FreeRTOS/Source/tasks.c **** 
 2197               	.LM258:
 2198 08a8 9E89      		ldd r25,Y+22
 2199 08aa 8091 0000 		lds r24,uxTopReadyPriority
 2200 08ae 8917      		cp r24,r25
 2201 08b0 00F4      		brsh .L149
3073:FreeRTOS/Source/tasks.c **** 
 2203               	.LM259:
 2204 08b2 9093 0000 		sts uxTopReadyPriority,r25
 2205               	.L149:
3073:FreeRTOS/Source/tasks.c **** 
 2207               	.LM260:
 2208 08b6 F9E0      		ldi r31,lo8(9)
 2209 08b8 9F9F      		mul r25,r31
 2210 08ba C001      		movw r24,r0
 2211 08bc 1124      		clr __zero_reg__
 2212 08be B801      		movw r22,r16
 2213 08c0 8050      		subi r24,lo8(-(pxReadyTasksLists))
 2214 08c2 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 2215 08c4 0E94 0000 		call vListInsertEnd
3075:FreeRTOS/Source/tasks.c **** 	{
 2217               	.LM261:
 2218 08c8 E091 0000 		lds r30,pxCurrentTCB
 2219 08cc F091 0000 		lds r31,pxCurrentTCB+1
 2220 08d0 9E89      		ldd r25,Y+22
 2221 08d2 8689      		ldd r24,Z+22
 2222 08d4 8917      		cp r24,r25
 2223 08d6 00F4      		brsh .L148
3081:FreeRTOS/Source/tasks.c **** 	}
 2225               	.LM262:
 2226 08d8 81E0      		ldi r24,lo8(1)
 2227 08da 8093 0000 		sts xYieldPending,r24
 2228               	.L148:
 2229               	/* epilogue start */
3083:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 2231               	.LM263:
 2232 08de DF91      		pop r29
 2233 08e0 CF91      		pop r28
 2234 08e2 1F91      		pop r17
 2235 08e4 0F91      		pop r16
 2236 08e6 0895      		ret
 2241               	.Lscope21:
 2243               		.stabd	78,0,0
 2246               	.global	vTaskSetTimeOutState
 2248               	vTaskSetTimeOutState:
 2249               		.stabd	46,0,0
3087:FreeRTOS/Source/tasks.c **** 	configASSERT( pxTimeOut );
 2251               	.LM264:
 2252               	.LFBB22:
 2253               	/* prologue: function */
 2254               	/* frame size = 0 */
 2255               	/* stack size = 0 */
 2256               	.L__stack_usage = 0
3089:FreeRTOS/Source/tasks.c **** 	{
 2258               	.LM265:
 2259               	/* #APP */
 2260               	 ;  3089 "FreeRTOS/Source/tasks.c" 1
 2261 08e8 0FB6      		in		__tmp_reg__, __SREG__
 2262               	 ;  0 "" 2
 2263               	 ;  3089 "FreeRTOS/Source/tasks.c" 1
 2264 08ea F894      		cli
 2265               	 ;  0 "" 2
 2266               	 ;  3089 "FreeRTOS/Source/tasks.c" 1
 2267 08ec 0F92      		push	__tmp_reg__
 2268               	 ;  0 "" 2
3091:FreeRTOS/Source/tasks.c **** 		pxTimeOut->xTimeOnEntering = xTickCount;
 2270               	.LM266:
 2271               	/* #NOAPP */
 2272 08ee 2091 0000 		lds r18,xNumOfOverflows
 2273 08f2 FC01      		movw r30,r24
 2274 08f4 2083      		st Z,r18
3092:FreeRTOS/Source/tasks.c **** 	}
 2276               	.LM267:
 2277 08f6 2091 0000 		lds r18,xTickCount
 2278 08fa 3091 0000 		lds r19,xTickCount+1
 2279 08fe 3283      		std Z+2,r19
 2280 0900 2183      		std Z+1,r18
3094:FreeRTOS/Source/tasks.c **** }
 2282               	.LM268:
 2283               	/* #APP */
 2284               	 ;  3094 "FreeRTOS/Source/tasks.c" 1
 2285 0902 0F90      		pop		__tmp_reg__
 2286               	 ;  0 "" 2
 2287               	 ;  3094 "FreeRTOS/Source/tasks.c" 1
 2288 0904 0FBE      		out		__SREG__, __tmp_reg__
 2289               	 ;  0 "" 2
 2290               	/* #NOAPP */
 2291 0906 0895      		ret
 2293               	.Lscope22:
 2295               		.stabd	78,0,0
 2298               	.global	vTaskInternalSetTimeOutState
 2300               	vTaskInternalSetTimeOutState:
 2301               		.stabd	46,0,0
3099:FreeRTOS/Source/tasks.c **** 	/* For internal use only as it does not use a critical section. */
 2303               	.LM269:
 2304               	.LFBB23:
 2305               	/* prologue: function */
 2306               	/* frame size = 0 */
 2307               	/* stack size = 0 */
 2308               	.L__stack_usage = 0
3101:FreeRTOS/Source/tasks.c **** 	pxTimeOut->xTimeOnEntering = xTickCount;
 2310               	.LM270:
 2311 0908 2091 0000 		lds r18,xNumOfOverflows
 2312 090c FC01      		movw r30,r24
 2313 090e 2083      		st Z,r18
3102:FreeRTOS/Source/tasks.c **** }
 2315               	.LM271:
 2316 0910 2091 0000 		lds r18,xTickCount
 2317 0914 3091 0000 		lds r19,xTickCount+1
 2318 0918 3283      		std Z+2,r19
 2319 091a 2183      		std Z+1,r18
 2320 091c 0895      		ret
 2322               	.Lscope23:
 2324               		.stabd	78,0,0
 2328               	.global	xTaskCheckForTimeOut
 2330               	xTaskCheckForTimeOut:
 2331               		.stabd	46,0,0
3107:FreeRTOS/Source/tasks.c **** BaseType_t xReturn;
 2333               	.LM272:
 2334               	.LFBB24:
 2335               	/* prologue: function */
 2336               	/* frame size = 0 */
 2337               	/* stack size = 0 */
 2338               	.L__stack_usage = 0
3113:FreeRTOS/Source/tasks.c **** 	{
 2340               	.LM273:
 2341               	/* #APP */
 2342               	 ;  3113 "FreeRTOS/Source/tasks.c" 1
 2343 091e 0FB6      		in		__tmp_reg__, __SREG__
 2344               	 ;  0 "" 2
 2345               	 ;  3113 "FreeRTOS/Source/tasks.c" 1
 2346 0920 F894      		cli
 2347               	 ;  0 "" 2
 2348               	 ;  3113 "FreeRTOS/Source/tasks.c" 1
 2349 0922 0F92      		push	__tmp_reg__
 2350               	 ;  0 "" 2
 2351               	/* #NOAPP */
 2352               	.LBB53:
3116:FreeRTOS/Source/tasks.c **** 		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
 2354               	.LM274:
 2355 0924 2091 0000 		lds r18,xTickCount
 2356 0928 3091 0000 		lds r19,xTickCount+1
3117:FreeRTOS/Source/tasks.c **** 
 2358               	.LM275:
 2359 092c DC01      		movw r26,r24
 2360 092e 1196      		adiw r26,1
 2361 0930 4D91      		ld r20,X+
 2362 0932 5C91      		ld r21,X
 2363 0934 1297      		sbiw r26,1+1
3141:FreeRTOS/Source/tasks.c **** 		{
 2365               	.LM276:
 2366 0936 F091 0000 		lds r31,xNumOfOverflows
 2367 093a EC91      		ld r30,X
 2368 093c FE17      		cp r31,r30
 2369 093e 01F0      		breq .L154
3141:FreeRTOS/Source/tasks.c **** 		{
 2371               	.LM277:
 2372 0940 2417      		cp r18,r20
 2373 0942 3507      		cpc r19,r21
 2374 0944 00F4      		brsh .L157
 2375               	.L154:
3117:FreeRTOS/Source/tasks.c **** 
 2377               	.LM278:
 2378 0946 241B      		sub r18,r20
 2379 0948 350B      		sbc r19,r21
3150:FreeRTOS/Source/tasks.c **** 		{
 2381               	.LM279:
 2382 094a FB01      		movw r30,r22
 2383 094c 4081      		ld r20,Z
 2384 094e 5181      		ldd r21,Z+1
 2385 0950 2417      		cp r18,r20
 2386 0952 3507      		cpc r19,r21
 2387 0954 00F4      		brsh .L156
3153:FreeRTOS/Source/tasks.c **** 			vTaskInternalSetTimeOutState( pxTimeOut );
 2389               	.LM280:
 2390 0956 421B      		sub r20,r18
 2391 0958 530B      		sbc r21,r19
 2392 095a 5183      		std Z+1,r21
 2393 095c 4083      		st Z,r20
3154:FreeRTOS/Source/tasks.c **** 			xReturn = pdFALSE;
 2395               	.LM281:
 2396 095e 0E94 0000 		call vTaskInternalSetTimeOutState
3155:FreeRTOS/Source/tasks.c **** 		}
 2398               	.LM282:
 2399 0962 80E0      		ldi r24,0
 2400 0964 00C0      		rjmp .L155
 2401               	.L156:
3159:FreeRTOS/Source/tasks.c **** 			xReturn = pdTRUE;
 2403               	.LM283:
 2404 0966 1182      		std Z+1,__zero_reg__
 2405 0968 1082      		st Z,__zero_reg__
 2406               	.L157:
3148:FreeRTOS/Source/tasks.c **** 		}
 2408               	.LM284:
 2409 096a 81E0      		ldi r24,lo8(1)
 2410               	.L155:
 2411               	.LBE53:
3163:FreeRTOS/Source/tasks.c **** 
 2413               	.LM285:
 2414               	/* #APP */
 2415               	 ;  3163 "FreeRTOS/Source/tasks.c" 1
 2416 096c 0F90      		pop		__tmp_reg__
 2417               	 ;  0 "" 2
 2418               	 ;  3163 "FreeRTOS/Source/tasks.c" 1
 2419 096e 0FBE      		out		__SREG__, __tmp_reg__
 2420               	 ;  0 "" 2
3166:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 2422               	.LM286:
 2423               	/* #NOAPP */
 2424 0970 0895      		ret
 2433               	.Lscope24:
 2435               		.stabd	78,0,0
 2437               	.global	vTaskMissedYield
 2439               	vTaskMissedYield:
 2440               		.stabd	46,0,0
3170:FreeRTOS/Source/tasks.c **** 	xYieldPending = pdTRUE;
 2442               	.LM287:
 2443               	.LFBB25:
 2444               	/* prologue: function */
 2445               	/* frame size = 0 */
 2446               	/* stack size = 0 */
 2447               	.L__stack_usage = 0
3171:FreeRTOS/Source/tasks.c **** }
 2449               	.LM288:
 2450 0972 81E0      		ldi r24,lo8(1)
 2451 0974 8093 0000 		sts xYieldPending,r24
 2452 0978 0895      		ret
 2454               	.Lscope25:
 2456               		.stabd	78,0,0
 2458               	.global	uxTaskResetEventItemValue
 2460               	uxTaskResetEventItemValue:
 2461               		.stabd	46,0,0
4380:FreeRTOS/Source/tasks.c **** TickType_t uxReturn;
 2463               	.LM289:
 2464               	.LFBB26:
 2465               	/* prologue: function */
 2466               	/* frame size = 0 */
 2467               	/* stack size = 0 */
 2468               	.L__stack_usage = 0
4383:FreeRTOS/Source/tasks.c **** 
 2470               	.LM290:
 2471 097a E091 0000 		lds r30,pxCurrentTCB
 2472 097e F091 0000 		lds r31,pxCurrentTCB+1
 2473 0982 8485      		ldd r24,Z+12
 2474 0984 9585      		ldd r25,Z+13
4387:FreeRTOS/Source/tasks.c **** 
 2476               	.LM291:
 2477 0986 E091 0000 		lds r30,pxCurrentTCB
 2478 098a F091 0000 		lds r31,pxCurrentTCB+1
 2479 098e A091 0000 		lds r26,pxCurrentTCB
 2480 0992 B091 0000 		lds r27,pxCurrentTCB+1
 2481 0996 5696      		adiw r26,22
 2482 0998 4C91      		ld r20,X
 2483 099a 24E0      		ldi r18,lo8(4)
 2484 099c 30E0      		ldi r19,0
 2485 099e 241B      		sub r18,r20
 2486 09a0 3109      		sbc r19,__zero_reg__
 2487 09a2 3587      		std Z+13,r19
 2488 09a4 2487      		std Z+12,r18
4390:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 2490               	.LM292:
 2491 09a6 0895      		ret
 2496               	.Lscope26:
 2498               		.stabd	78,0,0
 2502               	.global	ulTaskNotifyTake
 2504               	ulTaskNotifyTake:
 2505               		.stabd	46,0,0
4413:FreeRTOS/Source/tasks.c **** 	uint32_t ulReturn;
 2507               	.LM293:
 2508               	.LFBB27:
 2509 09a8 0F93      		push r16
 2510 09aa 1F93      		push r17
 2511               	/* prologue: function */
 2512               	/* frame size = 0 */
 2513               	/* stack size = 2 */
 2514               	.L__stack_usage = 2
 2515 09ac 182F      		mov r17,r24
4416:FreeRTOS/Source/tasks.c **** 		{
 2517               	.LM294:
 2518               	/* #APP */
 2519               	 ;  4416 "FreeRTOS/Source/tasks.c" 1
 2520 09ae 0FB6      		in		__tmp_reg__, __SREG__
 2521               	 ;  0 "" 2
 2522               	 ;  4416 "FreeRTOS/Source/tasks.c" 1
 2523 09b0 F894      		cli
 2524               	 ;  0 "" 2
 2525               	 ;  4416 "FreeRTOS/Source/tasks.c" 1
 2526 09b2 0F92      		push	__tmp_reg__
 2527               	 ;  0 "" 2
4419:FreeRTOS/Source/tasks.c **** 			{
 2529               	.LM295:
 2530               	/* #NOAPP */
 2531 09b4 E091 0000 		lds r30,pxCurrentTCB
 2532 09b8 F091 0000 		lds r31,pxCurrentTCB+1
 2533 09bc 81A1      		ldd r24,Z+33
 2534 09be 92A1      		ldd r25,Z+34
 2535 09c0 A3A1      		ldd r26,Z+35
 2536 09c2 B4A1      		ldd r27,Z+36
 2537 09c4 892B      		or r24,r25
 2538 09c6 8A2B      		or r24,r26
 2539 09c8 8B2B      		or r24,r27
 2540 09ca 01F4      		brne .L162
4422:FreeRTOS/Source/tasks.c **** 
 2542               	.LM296:
 2543 09cc E091 0000 		lds r30,pxCurrentTCB
 2544 09d0 F091 0000 		lds r31,pxCurrentTCB+1
 2545 09d4 81E0      		ldi r24,lo8(1)
 2546 09d6 85A3      		std Z+37,r24
4424:FreeRTOS/Source/tasks.c **** 				{
 2548               	.LM297:
 2549 09d8 6115      		cp r22,__zero_reg__
 2550 09da 7105      		cpc r23,__zero_reg__
 2551 09dc 01F0      		breq .L162
4426:FreeRTOS/Source/tasks.c **** 					traceTASK_NOTIFY_TAKE_BLOCK();
 2553               	.LM298:
 2554 09de CB01      		movw r24,r22
 2555 09e0 0E94 0000 		call prvAddCurrentTaskToDelayedList.isra.2
4433:FreeRTOS/Source/tasks.c **** 				}
 2557               	.LM299:
 2558 09e4 0E94 0000 		call vPortYield
 2559               	.L162:
4445:FreeRTOS/Source/tasks.c **** 
 2561               	.LM300:
 2562               	/* #APP */
 2563               	 ;  4445 "FreeRTOS/Source/tasks.c" 1
 2564 09e8 0F90      		pop		__tmp_reg__
 2565               	 ;  0 "" 2
 2566               	 ;  4445 "FreeRTOS/Source/tasks.c" 1
 2567 09ea 0FBE      		out		__SREG__, __tmp_reg__
 2568               	 ;  0 "" 2
4447:FreeRTOS/Source/tasks.c **** 		{
 2570               	.LM301:
 2571               	 ;  4447 "FreeRTOS/Source/tasks.c" 1
 2572 09ec 0FB6      		in		__tmp_reg__, __SREG__
 2573               	 ;  0 "" 2
 2574               	 ;  4447 "FreeRTOS/Source/tasks.c" 1
 2575 09ee F894      		cli
 2576               	 ;  0 "" 2
 2577               	 ;  4447 "FreeRTOS/Source/tasks.c" 1
 2578 09f0 0F92      		push	__tmp_reg__
 2579               	 ;  0 "" 2
4450:FreeRTOS/Source/tasks.c **** 
 2581               	.LM302:
 2582               	/* #NOAPP */
 2583 09f2 E091 0000 		lds r30,pxCurrentTCB
 2584 09f6 F091 0000 		lds r31,pxCurrentTCB+1
 2585 09fa 61A1      		ldd r22,Z+33
 2586 09fc 72A1      		ldd r23,Z+34
 2587 09fe 83A1      		ldd r24,Z+35
 2588 0a00 94A1      		ldd r25,Z+36
4452:FreeRTOS/Source/tasks.c **** 			{
 2590               	.LM303:
 2591 0a02 6115      		cp r22,__zero_reg__
 2592 0a04 7105      		cpc r23,__zero_reg__
 2593 0a06 8105      		cpc r24,__zero_reg__
 2594 0a08 9105      		cpc r25,__zero_reg__
 2595 0a0a 01F0      		breq .L164
4456:FreeRTOS/Source/tasks.c **** 				}
 2597               	.LM304:
 2598 0a0c E091 0000 		lds r30,pxCurrentTCB
 2599 0a10 F091 0000 		lds r31,pxCurrentTCB+1
4454:FreeRTOS/Source/tasks.c **** 				{
 2601               	.LM305:
 2602 0a14 1123      		tst r17
 2603 0a16 01F0      		breq .L165
4456:FreeRTOS/Source/tasks.c **** 				}
 2605               	.LM306:
 2606 0a18 11A2      		std Z+33,__zero_reg__
 2607 0a1a 12A2      		std Z+34,__zero_reg__
 2608 0a1c 13A2      		std Z+35,__zero_reg__
 2609 0a1e 14A2      		std Z+36,__zero_reg__
 2610 0a20 00C0      		rjmp .L164
 2611               	.L165:
4460:FreeRTOS/Source/tasks.c **** 				}
 2613               	.LM307:
 2614 0a22 8B01      		movw r16,r22
 2615 0a24 9C01      		movw r18,r24
 2616 0a26 0150      		subi r16,1
 2617 0a28 1109      		sbc r17,__zero_reg__
 2618 0a2a 2109      		sbc r18,__zero_reg__
 2619 0a2c 3109      		sbc r19,__zero_reg__
 2620 0a2e 01A3      		std Z+33,r16
 2621 0a30 12A3      		std Z+34,r17
 2622 0a32 23A3      		std Z+35,r18
 2623 0a34 34A3      		std Z+36,r19
 2624               	.L164:
4468:FreeRTOS/Source/tasks.c **** 		}
 2626               	.LM308:
 2627 0a36 E091 0000 		lds r30,pxCurrentTCB
 2628 0a3a F091 0000 		lds r31,pxCurrentTCB+1
 2629 0a3e 15A2      		std Z+37,__zero_reg__
4470:FreeRTOS/Source/tasks.c **** 
 2631               	.LM309:
 2632               	/* #APP */
 2633               	 ;  4470 "FreeRTOS/Source/tasks.c" 1
 2634 0a40 0F90      		pop		__tmp_reg__
 2635               	 ;  0 "" 2
 2636               	 ;  4470 "FreeRTOS/Source/tasks.c" 1
 2637 0a42 0FBE      		out		__SREG__, __tmp_reg__
 2638               	 ;  0 "" 2
 2639               	/* epilogue start */
4473:FreeRTOS/Source/tasks.c **** 
 2641               	.LM310:
 2642               	/* #NOAPP */
 2643 0a44 1F91      		pop r17
 2644 0a46 0F91      		pop r16
 2645 0a48 0895      		ret
 2650               	.Lscope27:
 2652               		.stabd	78,0,0
 2658               	.global	xTaskNotifyWait
 2660               	xTaskNotifyWait:
 2661               		.stabd	46,0,0
4481:FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn;
 2663               	.LM311:
 2664               	.LFBB28:
 2665 0a4a 4F92      		push r4
 2666 0a4c 5F92      		push r5
 2667 0a4e 6F92      		push r6
 2668 0a50 7F92      		push r7
 2669 0a52 8F92      		push r8
 2670 0a54 9F92      		push r9
 2671 0a56 AF92      		push r10
 2672 0a58 BF92      		push r11
 2673 0a5a EF92      		push r14
 2674 0a5c FF92      		push r15
 2675 0a5e 0F93      		push r16
 2676 0a60 1F93      		push r17
 2677 0a62 CF93      		push r28
 2678 0a64 DF93      		push r29
 2679 0a66 00D0      		rcall .
 2680 0a68 00D0      		rcall .
 2681 0a6a CDB7      		in r28,__SP_L__
 2682 0a6c DEB7      		in r29,__SP_H__
 2683               	/* prologue: function */
 2684               	/* frame size = 4 */
 2685               	/* stack size = 18 */
 2686               	.L__stack_usage = 18
4484:FreeRTOS/Source/tasks.c **** 		{
 2688               	.LM312:
 2689               	/* #APP */
 2690               	 ;  4484 "FreeRTOS/Source/tasks.c" 1
 2691 0a6e 0FB6      		in		__tmp_reg__, __SREG__
 2692               	 ;  0 "" 2
 2693               	 ;  4484 "FreeRTOS/Source/tasks.c" 1
 2694 0a70 F894      		cli
 2695               	 ;  0 "" 2
 2696               	 ;  4484 "FreeRTOS/Source/tasks.c" 1
 2697 0a72 0F92      		push	__tmp_reg__
 2698               	 ;  0 "" 2
4487:FreeRTOS/Source/tasks.c **** 			{
 2700               	.LM313:
 2701               	/* #NOAPP */
 2702 0a74 E091 0000 		lds r30,pxCurrentTCB
 2703 0a78 F091 0000 		lds r31,pxCurrentTCB+1
 2704 0a7c E5A1      		ldd r30,Z+37
 2705 0a7e E230      		cpi r30,lo8(2)
 2706 0a80 01F0      		breq .L174
4492:FreeRTOS/Source/tasks.c **** 
 2708               	.LM314:
 2709 0a82 E091 0000 		lds r30,pxCurrentTCB
 2710 0a86 F091 0000 		lds r31,pxCurrentTCB+1
 2711 0a8a 81A0      		ldd r8,Z+33
 2712 0a8c 92A0      		ldd r9,Z+34
 2713 0a8e A3A0      		ldd r10,Z+35
 2714 0a90 B4A0      		ldd r11,Z+36
 2715 0a92 2B01      		movw r4,r22
 2716 0a94 3C01      		movw r6,r24
 2717 0a96 4094      		com r4
 2718 0a98 5094      		com r5
 2719 0a9a 6094      		com r6
 2720 0a9c 7094      		com r7
 2721 0a9e D301      		movw r26,r6
 2722 0aa0 C201      		movw r24,r4
 2723 0aa2 8821      		and r24,r8
 2724 0aa4 9921      		and r25,r9
 2725 0aa6 AA21      		and r26,r10
 2726 0aa8 BB21      		and r27,r11
 2727 0aaa 81A3      		std Z+33,r24
 2728 0aac 92A3      		std Z+34,r25
 2729 0aae A3A3      		std Z+35,r26
 2730 0ab0 B4A3      		std Z+36,r27
4495:FreeRTOS/Source/tasks.c **** 
 2732               	.LM315:
 2733 0ab2 E091 0000 		lds r30,pxCurrentTCB
 2734 0ab6 F091 0000 		lds r31,pxCurrentTCB+1
 2735 0aba 81E0      		ldi r24,lo8(1)
 2736 0abc 85A3      		std Z+37,r24
4497:FreeRTOS/Source/tasks.c **** 				{
 2738               	.LM316:
 2739 0abe E114      		cp r14,__zero_reg__
 2740 0ac0 F104      		cpc r15,__zero_reg__
 2741 0ac2 01F0      		breq .L174
4499:FreeRTOS/Source/tasks.c **** 					traceTASK_NOTIFY_WAIT_BLOCK();
 2743               	.LM317:
 2744 0ac4 C701      		movw r24,r14
 2745 0ac6 2983      		std Y+1,r18
 2746 0ac8 3A83      		std Y+2,r19
 2747 0aca 4B83      		std Y+3,r20
 2748 0acc 5C83      		std Y+4,r21
 2749 0ace 0E94 0000 		call prvAddCurrentTaskToDelayedList.isra.2
4506:FreeRTOS/Source/tasks.c **** 				}
 2751               	.LM318:
 2752 0ad2 0E94 0000 		call vPortYield
 2753 0ad6 5C81      		ldd r21,Y+4
 2754 0ad8 4B81      		ldd r20,Y+3
 2755 0ada 3A81      		ldd r19,Y+2
 2756 0adc 2981      		ldd r18,Y+1
 2757               	.L174:
4518:FreeRTOS/Source/tasks.c **** 
 2759               	.LM319:
 2760               	/* #APP */
 2761               	 ;  4518 "FreeRTOS/Source/tasks.c" 1
 2762 0ade 0F90      		pop		__tmp_reg__
 2763               	 ;  0 "" 2
 2764               	 ;  4518 "FreeRTOS/Source/tasks.c" 1
 2765 0ae0 0FBE      		out		__SREG__, __tmp_reg__
 2766               	 ;  0 "" 2
4520:FreeRTOS/Source/tasks.c **** 		{
 2768               	.LM320:
 2769               	 ;  4520 "FreeRTOS/Source/tasks.c" 1
 2770 0ae2 0FB6      		in		__tmp_reg__, __SREG__
 2771               	 ;  0 "" 2
 2772               	 ;  4520 "FreeRTOS/Source/tasks.c" 1
 2773 0ae4 F894      		cli
 2774               	 ;  0 "" 2
 2775               	 ;  4520 "FreeRTOS/Source/tasks.c" 1
 2776 0ae6 0F92      		push	__tmp_reg__
 2777               	 ;  0 "" 2
4524:FreeRTOS/Source/tasks.c **** 			{
 2779               	.LM321:
 2780               	/* #NOAPP */
 2781 0ae8 0115      		cp r16,__zero_reg__
 2782 0aea 1105      		cpc r17,__zero_reg__
 2783 0aec 01F0      		breq .L176
4528:FreeRTOS/Source/tasks.c **** 			}
 2785               	.LM322:
 2786 0aee E091 0000 		lds r30,pxCurrentTCB
 2787 0af2 F091 0000 		lds r31,pxCurrentTCB+1
 2788 0af6 81A1      		ldd r24,Z+33
 2789 0af8 92A1      		ldd r25,Z+34
 2790 0afa A3A1      		ldd r26,Z+35
 2791 0afc B4A1      		ldd r27,Z+36
 2792 0afe F801      		movw r30,r16
 2793 0b00 8083      		st Z,r24
 2794 0b02 9183      		std Z+1,r25
 2795 0b04 A283      		std Z+2,r26
 2796 0b06 B383      		std Z+3,r27
 2797               	.L176:
4535:FreeRTOS/Source/tasks.c **** 			{
 2799               	.LM323:
 2800 0b08 E091 0000 		lds r30,pxCurrentTCB
 2801 0b0c F091 0000 		lds r31,pxCurrentTCB+1
 2802 0b10 85A1      		ldd r24,Z+37
 2803 0b12 8230      		cpi r24,lo8(2)
 2804 0b14 01F4      		brne .L178
4544:FreeRTOS/Source/tasks.c **** 				xReturn = pdTRUE;
 2806               	.LM324:
 2807 0b16 E091 0000 		lds r30,pxCurrentTCB
 2808 0b1a F091 0000 		lds r31,pxCurrentTCB+1
 2809 0b1e 81A0      		ldd r8,Z+33
 2810 0b20 92A0      		ldd r9,Z+34
 2811 0b22 A3A0      		ldd r10,Z+35
 2812 0b24 B4A0      		ldd r11,Z+36
 2813 0b26 DA01      		movw r26,r20
 2814 0b28 C901      		movw r24,r18
 2815 0b2a 8095      		com r24
 2816 0b2c 9095      		com r25
 2817 0b2e A095      		com r26
 2818 0b30 B095      		com r27
 2819 0b32 8821      		and r24,r8
 2820 0b34 9921      		and r25,r9
 2821 0b36 AA21      		and r26,r10
 2822 0b38 BB21      		and r27,r11
 2823 0b3a 81A3      		std Z+33,r24
 2824 0b3c 92A3      		std Z+34,r25
 2825 0b3e A3A3      		std Z+35,r26
 2826 0b40 B4A3      		std Z+36,r27
4545:FreeRTOS/Source/tasks.c **** 			}
 2828               	.LM325:
 2829 0b42 81E0      		ldi r24,lo8(1)
 2830 0b44 00C0      		rjmp .L177
 2831               	.L178:
4538:FreeRTOS/Source/tasks.c **** 			}
 2833               	.LM326:
 2834 0b46 80E0      		ldi r24,0
 2835               	.L177:
4548:FreeRTOS/Source/tasks.c **** 		}
 2837               	.LM327:
 2838 0b48 E091 0000 		lds r30,pxCurrentTCB
 2839 0b4c F091 0000 		lds r31,pxCurrentTCB+1
 2840 0b50 15A2      		std Z+37,__zero_reg__
4550:FreeRTOS/Source/tasks.c **** 
 2842               	.LM328:
 2843               	/* #APP */
 2844               	 ;  4550 "FreeRTOS/Source/tasks.c" 1
 2845 0b52 0F90      		pop		__tmp_reg__
 2846               	 ;  0 "" 2
 2847               	 ;  4550 "FreeRTOS/Source/tasks.c" 1
 2848 0b54 0FBE      		out		__SREG__, __tmp_reg__
 2849               	 ;  0 "" 2
 2850               	/* epilogue start */
4553:FreeRTOS/Source/tasks.c **** 
 2852               	.LM329:
 2853               	/* #NOAPP */
 2854 0b56 0F90      		pop __tmp_reg__
 2855 0b58 0F90      		pop __tmp_reg__
 2856 0b5a 0F90      		pop __tmp_reg__
 2857 0b5c 0F90      		pop __tmp_reg__
 2858 0b5e DF91      		pop r29
 2859 0b60 CF91      		pop r28
 2860 0b62 1F91      		pop r17
 2861 0b64 0F91      		pop r16
 2862 0b66 FF90      		pop r15
 2863 0b68 EF90      		pop r14
 2864 0b6a BF90      		pop r11
 2865 0b6c AF90      		pop r10
 2866 0b6e 9F90      		pop r9
 2867 0b70 8F90      		pop r8
 2868 0b72 7F90      		pop r7
 2869 0b74 6F90      		pop r6
 2870 0b76 5F90      		pop r5
 2871 0b78 4F90      		pop r4
 2872 0b7a 0895      		ret
 2877               	.Lscope28:
 2879               		.stabd	78,0,0
 2885               	.global	xTaskGenericNotify
 2887               	xTaskGenericNotify:
 2888               		.stabd	46,0,0
4561:FreeRTOS/Source/tasks.c **** 	TCB_t * pxTCB;
 2890               	.LM330:
 2891               	.LFBB29:
 2892 0b7c 0F93      		push r16
 2893 0b7e 1F93      		push r17
 2894 0b80 CF93      		push r28
 2895 0b82 DF93      		push r29
 2896               	/* prologue: function */
 2897               	/* frame size = 0 */
 2898               	/* stack size = 4 */
 2899               	.L__stack_usage = 4
 2900 0b84 FC01      		movw r30,r24
4569:FreeRTOS/Source/tasks.c **** 		{
 2902               	.LM331:
 2903               	/* #APP */
 2904               	 ;  4569 "FreeRTOS/Source/tasks.c" 1
 2905 0b86 0FB6      		in		__tmp_reg__, __SREG__
 2906               	 ;  0 "" 2
 2907               	 ;  4569 "FreeRTOS/Source/tasks.c" 1
 2908 0b88 F894      		cli
 2909               	 ;  0 "" 2
 2910               	 ;  4569 "FreeRTOS/Source/tasks.c" 1
 2911 0b8a 0F92      		push	__tmp_reg__
 2912               	 ;  0 "" 2
4571:FreeRTOS/Source/tasks.c **** 			{
 2914               	.LM332:
 2915               	/* #NOAPP */
 2916 0b8c 0115      		cp r16,__zero_reg__
 2917 0b8e 1105      		cpc r17,__zero_reg__
 2918 0b90 01F0      		breq .L186
4573:FreeRTOS/Source/tasks.c **** 			}
 2920               	.LM333:
 2921 0b92 81A1      		ldd r24,Z+33
 2922 0b94 92A1      		ldd r25,Z+34
 2923 0b96 A3A1      		ldd r26,Z+35
 2924 0b98 B4A1      		ldd r27,Z+36
 2925 0b9a E801      		movw r28,r16
 2926 0b9c 8883      		st Y,r24
 2927 0b9e 9983      		std Y+1,r25
 2928 0ba0 AA83      		std Y+2,r26
 2929 0ba2 BB83      		std Y+3,r27
 2930               	.L186:
4576:FreeRTOS/Source/tasks.c **** 
 2932               	.LM334:
 2933 0ba4 35A1      		ldd r19,Z+37
4578:FreeRTOS/Source/tasks.c **** 
 2935               	.LM335:
 2936 0ba6 82E0      		ldi r24,lo8(2)
 2937 0ba8 85A3      		std Z+37,r24
4580:FreeRTOS/Source/tasks.c **** 			{
 2939               	.LM336:
 2940 0baa 2230      		cpi r18,lo8(2)
 2941 0bac 01F0      		breq .L188
 2942 0bae 00F4      		brsh .L189
 2943 0bb0 2130      		cpi r18,lo8(1)
 2944 0bb2 01F4      		brne .L187
4583:FreeRTOS/Source/tasks.c **** 					break;
 2946               	.LM337:
 2947 0bb4 81A1      		ldd r24,Z+33
 2948 0bb6 92A1      		ldd r25,Z+34
 2949 0bb8 A3A1      		ldd r26,Z+35
 2950 0bba B4A1      		ldd r27,Z+36
 2951 0bbc 482B      		or r20,r24
 2952 0bbe 592B      		or r21,r25
 2953 0bc0 6A2B      		or r22,r26
 2954 0bc2 7B2B      		or r23,r27
 2955 0bc4 00C0      		rjmp .L201
 2956               	.L189:
4580:FreeRTOS/Source/tasks.c **** 			{
 2958               	.LM338:
 2959 0bc6 2330      		cpi r18,lo8(3)
 2960 0bc8 01F0      		breq .L201
 2961 0bca 2430      		cpi r18,lo8(4)
 2962 0bcc 01F0      		breq .L192
 2963 0bce 00C0      		rjmp .L187
 2964               	.L188:
4587:FreeRTOS/Source/tasks.c **** 					break;
 2966               	.LM339:
 2967 0bd0 81A1      		ldd r24,Z+33
 2968 0bd2 92A1      		ldd r25,Z+34
 2969 0bd4 A3A1      		ldd r26,Z+35
 2970 0bd6 B4A1      		ldd r27,Z+36
 2971 0bd8 0196      		adiw r24,1
 2972 0bda A11D      		adc r26,__zero_reg__
 2973 0bdc B11D      		adc r27,__zero_reg__
 2974 0bde 81A3      		std Z+33,r24
 2975 0be0 92A3      		std Z+34,r25
 2976 0be2 A3A3      		std Z+35,r26
 2977 0be4 B4A3      		std Z+36,r27
4588:FreeRTOS/Source/tasks.c **** 
 2979               	.LM340:
 2980 0be6 00C0      		rjmp .L187
 2981               	.L192:
4595:FreeRTOS/Source/tasks.c **** 					{
 2983               	.LM341:
 2984 0be8 3230      		cpi r19,lo8(2)
 2985 0bea 01F0      		breq .L197
 2986               	.L201:
4597:FreeRTOS/Source/tasks.c **** 					}
 2988               	.LM342:
 2989 0bec 41A3      		std Z+33,r20
 2990 0bee 52A3      		std Z+34,r21
 2991 0bf0 63A3      		std Z+35,r22
 2992 0bf2 74A3      		std Z+36,r23
 2993               	.L187:
4616:FreeRTOS/Source/tasks.c **** 			{
 2995               	.LM343:
 2996 0bf4 3130      		cpi r19,lo8(1)
 2997 0bf6 01F4      		brne .L202
 2998 0bf8 EF01      		movw r28,r30
4618:FreeRTOS/Source/tasks.c **** 				prvAddTaskToReadyList( pxTCB );
 3000               	.LM344:
 3001 0bfa 8F01      		movw r16,r30
 3002 0bfc 0E5F      		subi r16,-2
 3003 0bfe 1F4F      		sbci r17,-1
 3004 0c00 C801      		movw r24,r16
 3005 0c02 0E94 0000 		call uxListRemove
4619:FreeRTOS/Source/tasks.c **** 
 3007               	.LM345:
 3008 0c06 9E89      		ldd r25,Y+22
 3009 0c08 8091 0000 		lds r24,uxTopReadyPriority
 3010 0c0c 8917      		cp r24,r25
 3011 0c0e 00F4      		brsh .L195
4619:FreeRTOS/Source/tasks.c **** 
 3013               	.LM346:
 3014 0c10 9093 0000 		sts uxTopReadyPriority,r25
 3015               	.L195:
4619:FreeRTOS/Source/tasks.c **** 
 3017               	.LM347:
 3018 0c14 29E0      		ldi r18,lo8(9)
 3019 0c16 929F      		mul r25,r18
 3020 0c18 C001      		movw r24,r0
 3021 0c1a 1124      		clr __zero_reg__
 3022 0c1c B801      		movw r22,r16
 3023 0c1e 8050      		subi r24,lo8(-(pxReadyTasksLists))
 3024 0c20 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 3025 0c22 0E94 0000 		call vListInsertEnd
4640:FreeRTOS/Source/tasks.c **** 				{
 3027               	.LM348:
 3028 0c26 E091 0000 		lds r30,pxCurrentTCB
 3029 0c2a F091 0000 		lds r31,pxCurrentTCB+1
 3030 0c2e 9E89      		ldd r25,Y+22
 3031 0c30 8689      		ldd r24,Z+22
 3032 0c32 8917      		cp r24,r25
 3033 0c34 00F4      		brsh .L202
4644:FreeRTOS/Source/tasks.c **** 				}
 3035               	.LM349:
 3036 0c36 0E94 0000 		call vPortYield
 3037               	.L202:
 3038 0c3a 81E0      		ldi r24,lo8(1)
 3039 0c3c 00C0      		rjmp .L193
 3040               	.L197:
4602:FreeRTOS/Source/tasks.c **** 					}
 3042               	.LM350:
 3043 0c3e 80E0      		ldi r24,0
 3044               	.L193:
4656:FreeRTOS/Source/tasks.c **** 
 3046               	.LM351:
 3047               	/* #APP */
 3048               	 ;  4656 "FreeRTOS/Source/tasks.c" 1
 3049 0c40 0F90      		pop		__tmp_reg__
 3050               	 ;  0 "" 2
 3051               	 ;  4656 "FreeRTOS/Source/tasks.c" 1
 3052 0c42 0FBE      		out		__SREG__, __tmp_reg__
 3053               	 ;  0 "" 2
 3054               	/* epilogue start */
4659:FreeRTOS/Source/tasks.c **** 
 3056               	.LM352:
 3057               	/* #NOAPP */
 3058 0c44 DF91      		pop r29
 3059 0c46 CF91      		pop r28
 3060 0c48 1F91      		pop r17
 3061 0c4a 0F91      		pop r16
 3062 0c4c 0895      		ret
 3068               	.Lscope29:
 3070               		.stabd	78,0,0
 3077               	.global	xTaskGenericNotifyFromISR
 3079               	xTaskGenericNotifyFromISR:
 3080               		.stabd	46,0,0
4667:FreeRTOS/Source/tasks.c **** 	TCB_t * pxTCB;
 3082               	.LM353:
 3083               	.LFBB30:
 3084 0c4e EF92      		push r14
 3085 0c50 FF92      		push r15
 3086 0c52 0F93      		push r16
 3087 0c54 1F93      		push r17
 3088 0c56 CF93      		push r28
 3089 0c58 DF93      		push r29
 3090               	/* prologue: function */
 3091               	/* frame size = 0 */
 3092               	/* stack size = 6 */
 3093               	.L__stack_usage = 6
 3094 0c5a FC01      		movw r30,r24
4697:FreeRTOS/Source/tasks.c **** 			{
 3096               	.LM354:
 3097 0c5c 0115      		cp r16,__zero_reg__
 3098 0c5e 1105      		cpc r17,__zero_reg__
 3099 0c60 01F0      		breq .L204
4699:FreeRTOS/Source/tasks.c **** 			}
 3101               	.LM355:
 3102 0c62 81A1      		ldd r24,Z+33
 3103 0c64 92A1      		ldd r25,Z+34
 3104 0c66 A3A1      		ldd r26,Z+35
 3105 0c68 B4A1      		ldd r27,Z+36
 3106 0c6a E801      		movw r28,r16
 3107 0c6c 8883      		st Y,r24
 3108 0c6e 9983      		std Y+1,r25
 3109 0c70 AA83      		std Y+2,r26
 3110 0c72 BB83      		std Y+3,r27
 3111               	.L204:
4702:FreeRTOS/Source/tasks.c **** 			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
 3113               	.LM356:
 3114 0c74 35A1      		ldd r19,Z+37
4703:FreeRTOS/Source/tasks.c **** 
 3116               	.LM357:
 3117 0c76 82E0      		ldi r24,lo8(2)
 3118 0c78 85A3      		std Z+37,r24
4705:FreeRTOS/Source/tasks.c **** 			{
 3120               	.LM358:
 3121 0c7a 2230      		cpi r18,lo8(2)
 3122 0c7c 01F0      		breq .L206
 3123 0c7e 00F4      		brsh .L207
 3124 0c80 2130      		cpi r18,lo8(1)
 3125 0c82 01F4      		brne .L205
4708:FreeRTOS/Source/tasks.c **** 					break;
 3127               	.LM359:
 3128 0c84 81A1      		ldd r24,Z+33
 3129 0c86 92A1      		ldd r25,Z+34
 3130 0c88 A3A1      		ldd r26,Z+35
 3131 0c8a B4A1      		ldd r27,Z+36
 3132 0c8c 482B      		or r20,r24
 3133 0c8e 592B      		or r21,r25
 3134 0c90 6A2B      		or r22,r26
 3135 0c92 7B2B      		or r23,r27
 3136 0c94 00C0      		rjmp .L222
 3137               	.L207:
4705:FreeRTOS/Source/tasks.c **** 			{
 3139               	.LM360:
 3140 0c96 2330      		cpi r18,lo8(3)
 3141 0c98 01F0      		breq .L222
 3142 0c9a 2430      		cpi r18,lo8(4)
 3143 0c9c 01F0      		breq .L210
 3144 0c9e 00C0      		rjmp .L205
 3145               	.L206:
4712:FreeRTOS/Source/tasks.c **** 					break;
 3147               	.LM361:
 3148 0ca0 81A1      		ldd r24,Z+33
 3149 0ca2 92A1      		ldd r25,Z+34
 3150 0ca4 A3A1      		ldd r26,Z+35
 3151 0ca6 B4A1      		ldd r27,Z+36
 3152 0ca8 0196      		adiw r24,1
 3153 0caa A11D      		adc r26,__zero_reg__
 3154 0cac B11D      		adc r27,__zero_reg__
 3155 0cae 81A3      		std Z+33,r24
 3156 0cb0 92A3      		std Z+34,r25
 3157 0cb2 A3A3      		std Z+35,r26
 3158 0cb4 B4A3      		std Z+36,r27
4713:FreeRTOS/Source/tasks.c **** 
 3160               	.LM362:
 3161 0cb6 00C0      		rjmp .L205
 3162               	.L210:
4720:FreeRTOS/Source/tasks.c **** 					{
 3164               	.LM363:
 3165 0cb8 3230      		cpi r19,lo8(2)
 3166 0cba 01F0      		breq .L218
 3167               	.L222:
4722:FreeRTOS/Source/tasks.c **** 					}
 3169               	.LM364:
 3170 0cbc 41A3      		std Z+33,r20
 3171 0cbe 52A3      		std Z+34,r21
 3172 0cc0 63A3      		std Z+35,r22
 3173 0cc2 74A3      		std Z+36,r23
 3174               	.L205:
4741:FreeRTOS/Source/tasks.c **** 			{
 3176               	.LM365:
 3177 0cc4 3130      		cpi r19,lo8(1)
 3178 0cc6 01F0      		breq .L212
 3179               	.L216:
4667:FreeRTOS/Source/tasks.c **** 	TCB_t * pxTCB;
 3181               	.LM366:
 3182 0cc8 81E0      		ldi r24,lo8(1)
 3183 0cca 00C0      		rjmp .L211
 3184               	.L212:
 3185 0ccc EF01      		movw r28,r30
4746:FreeRTOS/Source/tasks.c **** 				{
 3187               	.LM367:
 3188 0cce 8091 0000 		lds r24,uxSchedulerSuspended
 3189 0cd2 8111      		cpse r24,__zero_reg__
 3190 0cd4 00C0      		rjmp .L213
4748:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 3192               	.LM368:
 3193 0cd6 8F01      		movw r16,r30
 3194 0cd8 0E5F      		subi r16,-2
 3195 0cda 1F4F      		sbci r17,-1
 3196 0cdc C801      		movw r24,r16
 3197 0cde 0E94 0000 		call uxListRemove
4749:FreeRTOS/Source/tasks.c **** 				}
 3199               	.LM369:
 3200 0ce2 2E89      		ldd r18,Y+22
 3201 0ce4 8091 0000 		lds r24,uxTopReadyPriority
 3202 0ce8 8217      		cp r24,r18
 3203 0cea 00F4      		brsh .L214
4749:FreeRTOS/Source/tasks.c **** 				}
 3205               	.LM370:
 3206 0cec 2093 0000 		sts uxTopReadyPriority,r18
 3207               	.L214:
4749:FreeRTOS/Source/tasks.c **** 				}
 3209               	.LM371:
 3210 0cf0 E9E0      		ldi r30,lo8(9)
 3211 0cf2 2E9F      		mul r18,r30
 3212 0cf4 C001      		movw r24,r0
 3213 0cf6 1124      		clr __zero_reg__
 3214 0cf8 B801      		movw r22,r16
 3215 0cfa 8050      		subi r24,lo8(-(pxReadyTasksLists))
 3216 0cfc 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 3217 0cfe 00C0      		rjmp .L223
 3218               	.L213:
4755:FreeRTOS/Source/tasks.c **** 				}
 3220               	.LM372:
 3221 0d00 BF01      		movw r22,r30
 3222 0d02 645F      		subi r22,-12
 3223 0d04 7F4F      		sbci r23,-1
 3224 0d06 80E0      		ldi r24,lo8(xPendingReadyList)
 3225 0d08 90E0      		ldi r25,hi8(xPendingReadyList)
 3226               	.L223:
 3227 0d0a 0E94 0000 		call vListInsertEnd
4758:FreeRTOS/Source/tasks.c **** 				{
 3229               	.LM373:
 3230 0d0e E091 0000 		lds r30,pxCurrentTCB
 3231 0d12 F091 0000 		lds r31,pxCurrentTCB+1
 3232 0d16 9E89      		ldd r25,Y+22
 3233 0d18 8689      		ldd r24,Z+22
 3234 0d1a 8917      		cp r24,r25
 3235 0d1c 00F4      		brsh .L216
4764:FreeRTOS/Source/tasks.c **** 					}
 3237               	.LM374:
 3238 0d1e 81E0      		ldi r24,lo8(1)
4762:FreeRTOS/Source/tasks.c **** 					{
 3240               	.LM375:
 3241 0d20 E114      		cp r14,__zero_reg__
 3242 0d22 F104      		cpc r15,__zero_reg__
 3243 0d24 01F0      		breq .L217
4764:FreeRTOS/Source/tasks.c **** 					}
 3245               	.LM376:
 3246 0d26 E701      		movw r28,r14
 3247 0d28 8883      		st Y,r24
 3248 0d2a 00C0      		rjmp .L211
 3249               	.L217:
4771:FreeRTOS/Source/tasks.c **** 					}
 3251               	.LM377:
 3252 0d2c 8093 0000 		sts xYieldPending,r24
 3253 0d30 00C0      		rjmp .L211
 3254               	.L218:
4727:FreeRTOS/Source/tasks.c **** 					}
 3256               	.LM378:
 3257 0d32 80E0      		ldi r24,0
 3258               	.L211:
 3259               	/* epilogue start */
4783:FreeRTOS/Source/tasks.c **** 
 3261               	.LM379:
 3262 0d34 DF91      		pop r29
 3263 0d36 CF91      		pop r28
 3264 0d38 1F91      		pop r17
 3265 0d3a 0F91      		pop r16
 3266 0d3c FF90      		pop r15
 3267 0d3e EF90      		pop r14
 3268 0d40 0895      		ret
 3274               	.Lscope30:
 3276               		.stabd	78,0,0
 3280               	.global	vTaskNotifyGiveFromISR
 3282               	vTaskNotifyGiveFromISR:
 3283               		.stabd	46,0,0
4791:FreeRTOS/Source/tasks.c **** 	TCB_t * pxTCB;
 3285               	.LM380:
 3286               	.LFBB31:
 3287 0d42 EF92      		push r14
 3288 0d44 FF92      		push r15
 3289 0d46 0F93      		push r16
 3290 0d48 1F93      		push r17
 3291 0d4a CF93      		push r28
 3292 0d4c DF93      		push r29
 3293               	/* prologue: function */
 3294               	/* frame size = 0 */
 3295               	/* stack size = 6 */
 3296               	.L__stack_usage = 6
 3297 0d4e FC01      		movw r30,r24
4820:FreeRTOS/Source/tasks.c **** 			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
 3299               	.LM381:
 3300 0d50 25A1      		ldd r18,Z+37
4821:FreeRTOS/Source/tasks.c **** 
 3302               	.LM382:
 3303 0d52 82E0      		ldi r24,lo8(2)
 3304 0d54 85A3      		std Z+37,r24
4825:FreeRTOS/Source/tasks.c **** 
 3306               	.LM383:
 3307 0d56 81A1      		ldd r24,Z+33
 3308 0d58 92A1      		ldd r25,Z+34
 3309 0d5a A3A1      		ldd r26,Z+35
 3310 0d5c B4A1      		ldd r27,Z+36
 3311 0d5e 0196      		adiw r24,1
 3312 0d60 A11D      		adc r26,__zero_reg__
 3313 0d62 B11D      		adc r27,__zero_reg__
 3314 0d64 81A3      		std Z+33,r24
 3315 0d66 92A3      		std Z+34,r25
 3316 0d68 A3A3      		std Z+35,r26
 3317 0d6a B4A3      		std Z+36,r27
4831:FreeRTOS/Source/tasks.c **** 			{
 3319               	.LM384:
 3320 0d6c 2130      		cpi r18,lo8(1)
 3321 0d6e 01F4      		brne .L224
 3322 0d70 8B01      		movw r16,r22
 3323 0d72 EF01      		movw r28,r30
4836:FreeRTOS/Source/tasks.c **** 				{
 3325               	.LM385:
 3326 0d74 8091 0000 		lds r24,uxSchedulerSuspended
 3327 0d78 8111      		cpse r24,__zero_reg__
 3328 0d7a 00C0      		rjmp .L227
4838:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 3330               	.LM386:
 3331 0d7c 7F01      		movw r14,r30
 3332 0d7e 32E0      		ldi r19,2
 3333 0d80 E30E      		add r14,r19
 3334 0d82 F11C      		adc r15,__zero_reg__
 3335 0d84 C701      		movw r24,r14
 3336 0d86 0E94 0000 		call uxListRemove
4839:FreeRTOS/Source/tasks.c **** 				}
 3338               	.LM387:
 3339 0d8a 2E89      		ldd r18,Y+22
 3340 0d8c 8091 0000 		lds r24,uxTopReadyPriority
 3341 0d90 8217      		cp r24,r18
 3342 0d92 00F4      		brsh .L228
4839:FreeRTOS/Source/tasks.c **** 				}
 3344               	.LM388:
 3345 0d94 2093 0000 		sts uxTopReadyPriority,r18
 3346               	.L228:
4839:FreeRTOS/Source/tasks.c **** 				}
 3348               	.LM389:
 3349 0d98 E9E0      		ldi r30,lo8(9)
 3350 0d9a 2E9F      		mul r18,r30
 3351 0d9c C001      		movw r24,r0
 3352 0d9e 1124      		clr __zero_reg__
 3353 0da0 B701      		movw r22,r14
 3354 0da2 8050      		subi r24,lo8(-(pxReadyTasksLists))
 3355 0da4 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 3356 0da6 00C0      		rjmp .L232
 3357               	.L227:
4845:FreeRTOS/Source/tasks.c **** 				}
 3359               	.LM390:
 3360 0da8 BF01      		movw r22,r30
 3361 0daa 645F      		subi r22,-12
 3362 0dac 7F4F      		sbci r23,-1
 3363 0dae 80E0      		ldi r24,lo8(xPendingReadyList)
 3364 0db0 90E0      		ldi r25,hi8(xPendingReadyList)
 3365               	.L232:
 3366 0db2 0E94 0000 		call vListInsertEnd
4848:FreeRTOS/Source/tasks.c **** 				{
 3368               	.LM391:
 3369 0db6 E091 0000 		lds r30,pxCurrentTCB
 3370 0dba F091 0000 		lds r31,pxCurrentTCB+1
 3371 0dbe 9E89      		ldd r25,Y+22
 3372 0dc0 8689      		ldd r24,Z+22
 3373 0dc2 8917      		cp r24,r25
 3374 0dc4 00F4      		brsh .L224
4854:FreeRTOS/Source/tasks.c **** 					}
 3376               	.LM392:
 3377 0dc6 81E0      		ldi r24,lo8(1)
4852:FreeRTOS/Source/tasks.c **** 					{
 3379               	.LM393:
 3380 0dc8 0115      		cp r16,__zero_reg__
 3381 0dca 1105      		cpc r17,__zero_reg__
 3382 0dcc 01F0      		breq .L231
4854:FreeRTOS/Source/tasks.c **** 					}
 3384               	.LM394:
 3385 0dce F801      		movw r30,r16
 3386 0dd0 8083      		st Z,r24
 3387 0dd2 00C0      		rjmp .L224
 3388               	.L231:
4861:FreeRTOS/Source/tasks.c **** 					}
 3390               	.LM395:
 3391 0dd4 8093 0000 		sts xYieldPending,r24
 3392               	.L224:
 3393               	/* epilogue start */
4871:FreeRTOS/Source/tasks.c **** 
 3395               	.LM396:
 3396 0dd8 DF91      		pop r29
 3397 0dda CF91      		pop r28
 3398 0ddc 1F91      		pop r17
 3399 0dde 0F91      		pop r16
 3400 0de0 FF90      		pop r15
 3401 0de2 EF90      		pop r14
 3402 0de4 0895      		ret
 3407               	.Lscope31:
 3409               		.stabd	78,0,0
 3412               	.global	xTaskNotifyStateClear
 3414               	xTaskNotifyStateClear:
 3415               		.stabd	46,0,0
4880:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
 3417               	.LM397:
 3418               	.LFBB32:
 3419               	/* prologue: function */
 3420               	/* frame size = 0 */
 3421               	/* stack size = 0 */
 3422               	.L__stack_usage = 0
4886:FreeRTOS/Source/tasks.c **** 
 3424               	.LM398:
 3425 0de6 0097      		sbiw r24,0
 3426 0de8 01F4      		brne .L234
4886:FreeRTOS/Source/tasks.c **** 
 3428               	.LM399:
 3429 0dea 8091 0000 		lds r24,pxCurrentTCB
 3430 0dee 9091 0000 		lds r25,pxCurrentTCB+1
 3431               	.L234:
4888:FreeRTOS/Source/tasks.c **** 		{
 3433               	.LM400:
 3434               	/* #APP */
 3435               	 ;  4888 "FreeRTOS/Source/tasks.c" 1
 3436 0df2 0FB6      		in		__tmp_reg__, __SREG__
 3437               	 ;  0 "" 2
 3438               	 ;  4888 "FreeRTOS/Source/tasks.c" 1
 3439 0df4 F894      		cli
 3440               	 ;  0 "" 2
 3441               	 ;  4888 "FreeRTOS/Source/tasks.c" 1
 3442 0df6 0F92      		push	__tmp_reg__
 3443               	 ;  0 "" 2
4890:FreeRTOS/Source/tasks.c **** 			{
 3445               	.LM401:
 3446               	/* #NOAPP */
 3447 0df8 FC01      		movw r30,r24
 3448 0dfa 25A1      		ldd r18,Z+37
 3449 0dfc 2230      		cpi r18,lo8(2)
 3450 0dfe 01F4      		brne .L236
4892:FreeRTOS/Source/tasks.c **** 				xReturn = pdPASS;
 3452               	.LM402:
 3453 0e00 15A2      		std Z+37,__zero_reg__
4893:FreeRTOS/Source/tasks.c **** 			}
 3455               	.LM403:
 3456 0e02 81E0      		ldi r24,lo8(1)
 3457 0e04 00C0      		rjmp .L235
 3458               	.L236:
4897:FreeRTOS/Source/tasks.c **** 			}
 3460               	.LM404:
 3461 0e06 80E0      		ldi r24,0
 3462               	.L235:
4900:FreeRTOS/Source/tasks.c **** 
 3464               	.LM405:
 3465               	/* #APP */
 3466               	 ;  4900 "FreeRTOS/Source/tasks.c" 1
 3467 0e08 0F90      		pop		__tmp_reg__
 3468               	 ;  0 "" 2
 3469               	 ;  4900 "FreeRTOS/Source/tasks.c" 1
 3470 0e0a 0FBE      		out		__SREG__, __tmp_reg__
 3471               	 ;  0 "" 2
4903:FreeRTOS/Source/tasks.c **** 
 3473               	.LM406:
 3474               	/* #NOAPP */
 3475 0e0c 0895      		ret
 3480               	.Lscope32:
 3482               		.stabd	78,0,0
 3483               		.local	uxSchedulerSuspended
 3484               		.comm	uxSchedulerSuspended,1,1
 3485               		.local	xIdleTaskHandle
 3486               		.comm	xIdleTaskHandle,2,1
 3487               		.local	xNextTaskUnblockTime
 3488               		.comm	xNextTaskUnblockTime,2,1
 3489               		.local	uxTaskNumber
 3490               		.comm	uxTaskNumber,1,1
 3491               		.local	xNumOfOverflows
 3492               		.comm	xNumOfOverflows,1,1
 3493               		.local	xYieldPending
 3494               		.comm	xYieldPending,1,1
 3495               		.local	uxPendedTicks
 3496               		.comm	uxPendedTicks,1,1
 3497               		.local	xSchedulerRunning
 3498               		.comm	xSchedulerRunning,1,1
 3499               		.local	uxTopReadyPriority
 3500               		.comm	uxTopReadyPriority,1,1
 3501               		.local	xTickCount
 3502               		.comm	xTickCount,2,1
 3503               		.local	uxCurrentNumberOfTasks
 3504               		.comm	uxCurrentNumberOfTasks,1,1
 3505               		.local	uxDeletedTasksWaitingCleanUp
 3506               		.comm	uxDeletedTasksWaitingCleanUp,1,1
 3507               		.local	xTasksWaitingTermination
 3508               		.comm	xTasksWaitingTermination,9,1
 3509               		.local	xPendingReadyList
 3510               		.comm	xPendingReadyList,9,1
 3511               		.local	pxOverflowDelayedTaskList
 3512               		.comm	pxOverflowDelayedTaskList,2,1
 3513               		.local	pxDelayedTaskList
 3514               		.comm	pxDelayedTaskList,2,1
 3515               		.local	xDelayedTaskList2
 3516               		.comm	xDelayedTaskList2,9,1
 3517               		.local	xDelayedTaskList1
 3518               		.comm	xDelayedTaskList1,9,1
 3519               		.local	pxReadyTasksLists
 3520               		.comm	pxReadyTasksLists,36,1
 3521               	.global	pxCurrentTCB
 3522               		.section .bss
 3525               	pxCurrentTCB:
 3526 0000 0000      		.zero	2
 3547               		.text
 3549               	.Letext0:
 3550               		.ident	"GCC: (GNU) 4.9.2"
 3551               	.global __do_copy_data
 3552               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:0000000000000000 tasks.c
     /tmp/ccumOEV2.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccumOEV2.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccumOEV2.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccumOEV2.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccumOEV2.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccumOEV2.s:187    .text:0000000000000000 prvResetNextTaskUnblockTime
     /tmp/ccumOEV2.s:3512   .bss:0000000000000025 pxDelayedTaskList
     /tmp/ccumOEV2.s:3486   .bss:0000000000000005 xNextTaskUnblockTime
     /tmp/ccumOEV2.s:238    .text:0000000000000036 prvAddCurrentTaskToDelayedList.isra.2
     /tmp/ccumOEV2.s:3500   .bss:000000000000000d xTickCount
     /tmp/ccumOEV2.s:3525   .bss:0000000000000000 pxCurrentTCB
     /tmp/ccumOEV2.s:3510   .bss:0000000000000023 pxOverflowDelayedTaskList
     /tmp/ccumOEV2.s:348    .text:00000000000000bc prvIdleTask
     /tmp/ccumOEV2.s:3504   .bss:0000000000000010 uxDeletedTasksWaitingCleanUp
     /tmp/ccumOEV2.s:3506   .bss:0000000000000011 xTasksWaitingTermination
     /tmp/ccumOEV2.s:3502   .bss:000000000000000f uxCurrentNumberOfTasks
     /tmp/ccumOEV2.s:3518   .bss:0000000000000039 pxReadyTasksLists
     /tmp/ccumOEV2.s:458    .text:0000000000000118 xTaskCreate
     /tmp/ccumOEV2.s:3516   .bss:0000000000000030 xDelayedTaskList1
     /tmp/ccumOEV2.s:3514   .bss:0000000000000027 xDelayedTaskList2
     /tmp/ccumOEV2.s:3508   .bss:000000000000001a xPendingReadyList
     /tmp/ccumOEV2.s:3496   .bss:000000000000000b xSchedulerRunning
     /tmp/ccumOEV2.s:3488   .bss:0000000000000007 uxTaskNumber
     /tmp/ccumOEV2.s:3498   .bss:000000000000000c uxTopReadyPriority
     /tmp/ccumOEV2.s:841    .text:000000000000030c vTaskDelete
     /tmp/ccumOEV2.s:988    .text:00000000000003b6 vTaskStartScheduler
     /tmp/ccumOEV2.s:3484   .bss:0000000000000003 xIdleTaskHandle
     /tmp/ccumOEV2.s:1067   .text:000000000000040a vTaskEndScheduler
     /tmp/ccumOEV2.s:1096   .text:0000000000000414 vTaskSuspendAll
                             .bss:0000000000000002 uxSchedulerSuspended
     /tmp/ccumOEV2.s:1118   .text:0000000000000420 xTaskGetTickCount
     /tmp/ccumOEV2.s:1167   .text:0000000000000434 xTaskGetTickCountFromISR
     /tmp/ccumOEV2.s:1193   .text:000000000000043e uxTaskGetNumberOfTasks
     /tmp/ccumOEV2.s:1216   .text:0000000000000444 pcTaskGetName
     /tmp/ccumOEV2.s:1245   .text:0000000000000454 xTaskIncrementTick
     /tmp/ccumOEV2.s:3490   .bss:0000000000000008 xNumOfOverflows
     /tmp/ccumOEV2.s:3494   .bss:000000000000000a uxPendedTicks
     /tmp/ccumOEV2.s:3492   .bss:0000000000000009 xYieldPending
     /tmp/ccumOEV2.s:1482   .text:00000000000005ac xTaskResumeAll
     /tmp/ccumOEV2.s:1685   .text:000000000000068a vTaskDelayUntil
     /tmp/ccumOEV2.s:1806   .text:00000000000006f8 vTaskDelay
     /tmp/ccumOEV2.s:1863   .text:000000000000072e vTaskSwitchContext
     /tmp/ccumOEV2.s:1970   .text:00000000000007b4 vTaskPlaceOnEventList
     /tmp/ccumOEV2.s:2011   .text:00000000000007d6 vTaskPlaceOnUnorderedEventList
     /tmp/ccumOEV2.s:2056   .text:0000000000000804 xTaskRemoveFromEventList
     /tmp/ccumOEV2.s:2163   .text:0000000000000884 vTaskRemoveFromUnorderedEventList
     /tmp/ccumOEV2.s:2248   .text:00000000000008e8 vTaskSetTimeOutState
     /tmp/ccumOEV2.s:2300   .text:0000000000000908 vTaskInternalSetTimeOutState
     /tmp/ccumOEV2.s:2330   .text:000000000000091e xTaskCheckForTimeOut
     /tmp/ccumOEV2.s:2439   .text:0000000000000972 vTaskMissedYield
     /tmp/ccumOEV2.s:2460   .text:000000000000097a uxTaskResetEventItemValue
     /tmp/ccumOEV2.s:2504   .text:00000000000009a8 ulTaskNotifyTake
     /tmp/ccumOEV2.s:2660   .text:0000000000000a4a xTaskNotifyWait
     /tmp/ccumOEV2.s:2887   .text:0000000000000b7c xTaskGenericNotify
     /tmp/ccumOEV2.s:3079   .text:0000000000000c4e xTaskGenericNotifyFromISR
     /tmp/ccumOEV2.s:3282   .text:0000000000000d42 vTaskNotifyGiveFromISR
     /tmp/ccumOEV2.s:3414   .text:0000000000000de6 xTaskNotifyStateClear

UNDEFINED SYMBOLS
uxListRemove
vListInsert
vPortFree
vPortYield
vApplicationIdleHook
pvPortMalloc
vListInitialiseItem
pxPortInitialiseStack
vListInitialise
vListInsertEnd
xPortStartScheduler
vPortEndScheduler
__do_copy_data
__do_clear_bss
