   1               		.file	"queue.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   9               		.text
  10               	.Ltext0:
 194               	prvIsQueueEmpty:
 195               		.stabd	46,0,0
   1:FreeRTOS/Source/queue.c **** /*
   2:FreeRTOS/Source/queue.c ****  * FreeRTOS Kernel V10.0.0
   3:FreeRTOS/Source/queue.c ****  * Copyright (C) 2017 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
   4:FreeRTOS/Source/queue.c ****  *
   5:FreeRTOS/Source/queue.c ****  * Permission is hereby granted, free of charge, to any person obtaining a copy of
   6:FreeRTOS/Source/queue.c ****  * this software and associated documentation files (the "Software"), to deal in
   7:FreeRTOS/Source/queue.c ****  * the Software without restriction, including without limitation the rights to
   8:FreeRTOS/Source/queue.c ****  * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
   9:FreeRTOS/Source/queue.c ****  * the Software, and to permit persons to whom the Software is furnished to do so,
  10:FreeRTOS/Source/queue.c ****  * subject to the following conditions:
  11:FreeRTOS/Source/queue.c ****  *
  12:FreeRTOS/Source/queue.c ****  * The above copyright notice and this permission notice shall be included in all
  13:FreeRTOS/Source/queue.c ****  * copies or substantial portions of the Software. If you wish to use our Amazon
  14:FreeRTOS/Source/queue.c ****  * FreeRTOS name, please do so in a fair use way that does not cause confusion.
  15:FreeRTOS/Source/queue.c ****  *
  16:FreeRTOS/Source/queue.c ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  17:FreeRTOS/Source/queue.c ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
  18:FreeRTOS/Source/queue.c ****  * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
  19:FreeRTOS/Source/queue.c ****  * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
  20:FreeRTOS/Source/queue.c ****  * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  21:FreeRTOS/Source/queue.c ****  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  22:FreeRTOS/Source/queue.c ****  *
  23:FreeRTOS/Source/queue.c ****  * http://www.FreeRTOS.org
  24:FreeRTOS/Source/queue.c ****  * http://aws.amazon.com/freertos
  25:FreeRTOS/Source/queue.c ****  *
  26:FreeRTOS/Source/queue.c ****  * 1 tab == 4 spaces!
  27:FreeRTOS/Source/queue.c ****  */
  28:FreeRTOS/Source/queue.c **** 
  29:FreeRTOS/Source/queue.c **** #include <stdlib.h>
  30:FreeRTOS/Source/queue.c **** #include <string.h>
  31:FreeRTOS/Source/queue.c **** 
  32:FreeRTOS/Source/queue.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  33:FreeRTOS/Source/queue.c **** all the API functions to use the MPU wrappers.  That should only be done when
  34:FreeRTOS/Source/queue.c **** task.h is included from an application file. */
  35:FreeRTOS/Source/queue.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  36:FreeRTOS/Source/queue.c **** 
  37:FreeRTOS/Source/queue.c **** #include "FreeRTOS.h"
  38:FreeRTOS/Source/queue.c **** #include "task.h"
  39:FreeRTOS/Source/queue.c **** #include "queue.h"
  40:FreeRTOS/Source/queue.c **** 
  41:FreeRTOS/Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
  42:FreeRTOS/Source/queue.c **** 	#include "croutine.h"
  43:FreeRTOS/Source/queue.c **** #endif
  44:FreeRTOS/Source/queue.c **** 
  45:FreeRTOS/Source/queue.c **** /* Lint e961 and e750 are suppressed as a MISRA exception justified because the
  46:FreeRTOS/Source/queue.c **** MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined for the
  47:FreeRTOS/Source/queue.c **** header files above, but not in this file, in order to generate the correct
  48:FreeRTOS/Source/queue.c **** privileged Vs unprivileged linkage and placement. */
  49:FreeRTOS/Source/queue.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750. */
  50:FreeRTOS/Source/queue.c **** 
  51:FreeRTOS/Source/queue.c **** 
  52:FreeRTOS/Source/queue.c **** /* Constants used with the cRxLock and cTxLock structure members. */
  53:FreeRTOS/Source/queue.c **** #define queueUNLOCKED					( ( int8_t ) -1 )
  54:FreeRTOS/Source/queue.c **** #define queueLOCKED_UNMODIFIED			( ( int8_t ) 0 )
  55:FreeRTOS/Source/queue.c **** 
  56:FreeRTOS/Source/queue.c **** /* When the Queue_t structure is used to represent a base queue its pcHead and
  57:FreeRTOS/Source/queue.c **** pcTail members are used as pointers into the queue storage area.  When the
  58:FreeRTOS/Source/queue.c **** Queue_t structure is used to represent a mutex pcHead and pcTail pointers are
  59:FreeRTOS/Source/queue.c **** not necessary, and the pcHead pointer is set to NULL to indicate that the
  60:FreeRTOS/Source/queue.c **** pcTail pointer actually points to the mutex holder (if any).  Map alternative
  61:FreeRTOS/Source/queue.c **** names to the pcHead and pcTail structure members to ensure the readability of
  62:FreeRTOS/Source/queue.c **** the code is maintained despite this dual use of two structure members.  An
  63:FreeRTOS/Source/queue.c **** alternative implementation would be to use a union, but use of a union is
  64:FreeRTOS/Source/queue.c **** against the coding standard (although an exception to the standard has been
  65:FreeRTOS/Source/queue.c **** permitted where the dual use also significantly changes the type of the
  66:FreeRTOS/Source/queue.c **** structure member). */
  67:FreeRTOS/Source/queue.c **** #define pxMutexHolder					pcTail
  68:FreeRTOS/Source/queue.c **** #define uxQueueType						pcHead
  69:FreeRTOS/Source/queue.c **** #define queueQUEUE_IS_MUTEX				NULL
  70:FreeRTOS/Source/queue.c **** 
  71:FreeRTOS/Source/queue.c **** /* Semaphores do not actually store or copy data, so have an item size of
  72:FreeRTOS/Source/queue.c **** zero. */
  73:FreeRTOS/Source/queue.c **** #define queueSEMAPHORE_QUEUE_ITEM_LENGTH ( ( UBaseType_t ) 0 )
  74:FreeRTOS/Source/queue.c **** #define queueMUTEX_GIVE_BLOCK_TIME		 ( ( TickType_t ) 0U )
  75:FreeRTOS/Source/queue.c **** 
  76:FreeRTOS/Source/queue.c **** #if( configUSE_PREEMPTION == 0 )
  77:FreeRTOS/Source/queue.c **** 	/* If the cooperative scheduler is being used then a yield should not be
  78:FreeRTOS/Source/queue.c **** 	performed just because a higher priority task has been woken. */
  79:FreeRTOS/Source/queue.c **** 	#define queueYIELD_IF_USING_PREEMPTION()
  80:FreeRTOS/Source/queue.c **** #else
  81:FreeRTOS/Source/queue.c **** 	#define queueYIELD_IF_USING_PREEMPTION() portYIELD_WITHIN_API()
  82:FreeRTOS/Source/queue.c **** #endif
  83:FreeRTOS/Source/queue.c **** 
  84:FreeRTOS/Source/queue.c **** /*
  85:FreeRTOS/Source/queue.c ****  * Definition of the queue used by the scheduler.
  86:FreeRTOS/Source/queue.c ****  * Items are queued by copy, not reference.  See the following link for the
  87:FreeRTOS/Source/queue.c ****  * rationale: http://www.freertos.org/Embedded-RTOS-Queues.html
  88:FreeRTOS/Source/queue.c ****  */
  89:FreeRTOS/Source/queue.c **** typedef struct QueueDefinition
  90:FreeRTOS/Source/queue.c **** {
  91:FreeRTOS/Source/queue.c **** 	int8_t *pcHead;					/*< Points to the beginning of the queue storage area. */
  92:FreeRTOS/Source/queue.c **** 	int8_t *pcTail;					/*< Points to the byte at the end of the queue storage area.  Once more byte i
  93:FreeRTOS/Source/queue.c **** 	int8_t *pcWriteTo;				/*< Points to the free next place in the storage area. */
  94:FreeRTOS/Source/queue.c **** 
  95:FreeRTOS/Source/queue.c **** 	union							/* Use of a union is an exception to the coding standard to ensure two mutually exclus
  96:FreeRTOS/Source/queue.c **** 	{
  97:FreeRTOS/Source/queue.c **** 		int8_t *pcReadFrom;			/*< Points to the last place that a queued item was read from when the stru
  98:FreeRTOS/Source/queue.c **** 		UBaseType_t uxRecursiveCallCount;/*< Maintains a count of the number of times a recursive mutex h
  99:FreeRTOS/Source/queue.c **** 	} u;
 100:FreeRTOS/Source/queue.c **** 
 101:FreeRTOS/Source/queue.c **** 	List_t xTasksWaitingToSend;		/*< List of tasks that are blocked waiting to post onto this queue.  
 102:FreeRTOS/Source/queue.c **** 	List_t xTasksWaitingToReceive;	/*< List of tasks that are blocked waiting to read from this queue.
 103:FreeRTOS/Source/queue.c **** 
 104:FreeRTOS/Source/queue.c **** 	volatile UBaseType_t uxMessagesWaiting;/*< The number of items currently in the queue. */
 105:FreeRTOS/Source/queue.c **** 	UBaseType_t uxLength;			/*< The length of the queue defined as the number of items it will hold, n
 106:FreeRTOS/Source/queue.c **** 	UBaseType_t uxItemSize;			/*< The size of each items that the queue will hold. */
 107:FreeRTOS/Source/queue.c **** 
 108:FreeRTOS/Source/queue.c **** 	volatile int8_t cRxLock;		/*< Stores the number of items received from the queue (removed from the
 109:FreeRTOS/Source/queue.c **** 	volatile int8_t cTxLock;		/*< Stores the number of items transmitted to the queue (added to the qu
 110:FreeRTOS/Source/queue.c **** 
 111:FreeRTOS/Source/queue.c **** 	#if( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
 112:FreeRTOS/Source/queue.c **** 		uint8_t ucStaticallyAllocated;	/*< Set to pdTRUE if the memory used by the queue was statically a
 113:FreeRTOS/Source/queue.c **** 	#endif
 114:FreeRTOS/Source/queue.c **** 
 115:FreeRTOS/Source/queue.c **** 	#if ( configUSE_QUEUE_SETS == 1 )
 116:FreeRTOS/Source/queue.c **** 		struct QueueDefinition *pxQueueSetContainer;
 117:FreeRTOS/Source/queue.c **** 	#endif
 118:FreeRTOS/Source/queue.c **** 
 119:FreeRTOS/Source/queue.c **** 	#if ( configUSE_TRACE_FACILITY == 1 )
 120:FreeRTOS/Source/queue.c **** 		UBaseType_t uxQueueNumber;
 121:FreeRTOS/Source/queue.c **** 		uint8_t ucQueueType;
 122:FreeRTOS/Source/queue.c **** 	#endif
 123:FreeRTOS/Source/queue.c **** 
 124:FreeRTOS/Source/queue.c **** } xQUEUE;
 125:FreeRTOS/Source/queue.c **** 
 126:FreeRTOS/Source/queue.c **** /* The old xQUEUE name is maintained above then typedefed to the new Queue_t
 127:FreeRTOS/Source/queue.c **** name below to enable the use of older kernel aware debuggers. */
 128:FreeRTOS/Source/queue.c **** typedef xQUEUE Queue_t;
 129:FreeRTOS/Source/queue.c **** 
 130:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 131:FreeRTOS/Source/queue.c **** 
 132:FreeRTOS/Source/queue.c **** /*
 133:FreeRTOS/Source/queue.c ****  * The queue registry is just a means for kernel aware debuggers to locate
 134:FreeRTOS/Source/queue.c ****  * queue structures.  It has no other purpose so is an optional component.
 135:FreeRTOS/Source/queue.c ****  */
 136:FreeRTOS/Source/queue.c **** #if ( configQUEUE_REGISTRY_SIZE > 0 )
 137:FreeRTOS/Source/queue.c **** 
 138:FreeRTOS/Source/queue.c **** 	/* The type stored within the queue registry array.  This allows a name
 139:FreeRTOS/Source/queue.c **** 	to be assigned to each queue making kernel aware debugging a little
 140:FreeRTOS/Source/queue.c **** 	more user friendly. */
 141:FreeRTOS/Source/queue.c **** 	typedef struct QUEUE_REGISTRY_ITEM
 142:FreeRTOS/Source/queue.c **** 	{
 143:FreeRTOS/Source/queue.c **** 		const char *pcQueueName; /*lint !e971 Unqualified char types are allowed for strings and single c
 144:FreeRTOS/Source/queue.c **** 		QueueHandle_t xHandle;
 145:FreeRTOS/Source/queue.c **** 	} xQueueRegistryItem;
 146:FreeRTOS/Source/queue.c **** 
 147:FreeRTOS/Source/queue.c **** 	/* The old xQueueRegistryItem name is maintained above then typedefed to the
 148:FreeRTOS/Source/queue.c **** 	new xQueueRegistryItem name below to enable the use of older kernel aware
 149:FreeRTOS/Source/queue.c **** 	debuggers. */
 150:FreeRTOS/Source/queue.c **** 	typedef xQueueRegistryItem QueueRegistryItem_t;
 151:FreeRTOS/Source/queue.c **** 
 152:FreeRTOS/Source/queue.c **** 	/* The queue registry is simply an array of QueueRegistryItem_t structures.
 153:FreeRTOS/Source/queue.c **** 	The pcQueueName member of a structure being NULL is indicative of the
 154:FreeRTOS/Source/queue.c **** 	array position being vacant. */
 155:FreeRTOS/Source/queue.c **** 	PRIVILEGED_DATA QueueRegistryItem_t xQueueRegistry[ configQUEUE_REGISTRY_SIZE ];
 156:FreeRTOS/Source/queue.c **** 
 157:FreeRTOS/Source/queue.c **** #endif /* configQUEUE_REGISTRY_SIZE */
 158:FreeRTOS/Source/queue.c **** 
 159:FreeRTOS/Source/queue.c **** /*
 160:FreeRTOS/Source/queue.c ****  * Unlocks a queue locked by a call to prvLockQueue.  Locking a queue does not
 161:FreeRTOS/Source/queue.c ****  * prevent an ISR from adding or removing items to the queue, but does prevent
 162:FreeRTOS/Source/queue.c ****  * an ISR from removing tasks from the queue event lists.  If an ISR finds a
 163:FreeRTOS/Source/queue.c ****  * queue is locked it will instead increment the appropriate queue lock count
 164:FreeRTOS/Source/queue.c ****  * to indicate that a task may require unblocking.  When the queue in unlocked
 165:FreeRTOS/Source/queue.c ****  * these lock counts are inspected, and the appropriate action taken.
 166:FreeRTOS/Source/queue.c ****  */
 167:FreeRTOS/Source/queue.c **** static void prvUnlockQueue( Queue_t * const pxQueue ) PRIVILEGED_FUNCTION;
 168:FreeRTOS/Source/queue.c **** 
 169:FreeRTOS/Source/queue.c **** /*
 170:FreeRTOS/Source/queue.c ****  * Uses a critical section to determine if there is any data in a queue.
 171:FreeRTOS/Source/queue.c ****  *
 172:FreeRTOS/Source/queue.c ****  * @return pdTRUE if the queue contains no items, otherwise pdFALSE.
 173:FreeRTOS/Source/queue.c ****  */
 174:FreeRTOS/Source/queue.c **** static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue ) PRIVILEGED_FUNCTION;
 175:FreeRTOS/Source/queue.c **** 
 176:FreeRTOS/Source/queue.c **** /*
 177:FreeRTOS/Source/queue.c ****  * Uses a critical section to determine if there is any space in a queue.
 178:FreeRTOS/Source/queue.c ****  *
 179:FreeRTOS/Source/queue.c ****  * @return pdTRUE if there is no space, otherwise pdFALSE;
 180:FreeRTOS/Source/queue.c ****  */
 181:FreeRTOS/Source/queue.c **** static BaseType_t prvIsQueueFull( const Queue_t *pxQueue ) PRIVILEGED_FUNCTION;
 182:FreeRTOS/Source/queue.c **** 
 183:FreeRTOS/Source/queue.c **** /*
 184:FreeRTOS/Source/queue.c ****  * Copies an item into the queue, either at the front of the queue or the
 185:FreeRTOS/Source/queue.c ****  * back of the queue.
 186:FreeRTOS/Source/queue.c ****  */
 187:FreeRTOS/Source/queue.c **** static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const Bas
 188:FreeRTOS/Source/queue.c **** 
 189:FreeRTOS/Source/queue.c **** /*
 190:FreeRTOS/Source/queue.c ****  * Copies an item out of a queue.
 191:FreeRTOS/Source/queue.c ****  */
 192:FreeRTOS/Source/queue.c **** static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer ) PRIVILEGED_FUNCT
 193:FreeRTOS/Source/queue.c **** 
 194:FreeRTOS/Source/queue.c **** #if ( configUSE_QUEUE_SETS == 1 )
 195:FreeRTOS/Source/queue.c **** 	/*
 196:FreeRTOS/Source/queue.c **** 	 * Checks to see if a queue is a member of a queue set, and if so, notifies
 197:FreeRTOS/Source/queue.c **** 	 * the queue set that the queue contains data.
 198:FreeRTOS/Source/queue.c **** 	 */
 199:FreeRTOS/Source/queue.c **** 	static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue, const BaseType_t xCop
 200:FreeRTOS/Source/queue.c **** #endif
 201:FreeRTOS/Source/queue.c **** 
 202:FreeRTOS/Source/queue.c **** /*
 203:FreeRTOS/Source/queue.c ****  * Called after a Queue_t structure has been allocated either statically or
 204:FreeRTOS/Source/queue.c ****  * dynamically to fill in the structure's members.
 205:FreeRTOS/Source/queue.c ****  */
 206:FreeRTOS/Source/queue.c **** static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, u
 207:FreeRTOS/Source/queue.c **** 
 208:FreeRTOS/Source/queue.c **** /*
 209:FreeRTOS/Source/queue.c ****  * Mutexes are a special type of queue.  When a mutex is created, first the
 210:FreeRTOS/Source/queue.c ****  * queue is created, then prvInitialiseMutex() is called to configure the queue
 211:FreeRTOS/Source/queue.c ****  * as a mutex.
 212:FreeRTOS/Source/queue.c ****  */
 213:FreeRTOS/Source/queue.c **** #if( configUSE_MUTEXES == 1 )
 214:FreeRTOS/Source/queue.c **** 	static void prvInitialiseMutex( Queue_t *pxNewQueue ) PRIVILEGED_FUNCTION;
 215:FreeRTOS/Source/queue.c **** #endif
 216:FreeRTOS/Source/queue.c **** 
 217:FreeRTOS/Source/queue.c **** #if( configUSE_MUTEXES == 1 )
 218:FreeRTOS/Source/queue.c **** 	/*
 219:FreeRTOS/Source/queue.c **** 	 * If a task waiting for a mutex causes the mutex holder to inherit a
 220:FreeRTOS/Source/queue.c **** 	 * priority, but the waiting task times out, then the holder should
 221:FreeRTOS/Source/queue.c **** 	 * disinherit the priority - but only down to the highest priority of any
 222:FreeRTOS/Source/queue.c **** 	 * other tasks that are waiting for the same mutex.  This function returns
 223:FreeRTOS/Source/queue.c **** 	 * that priority.
 224:FreeRTOS/Source/queue.c **** 	 */
 225:FreeRTOS/Source/queue.c **** 	static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue ) PRIVILEGE
 226:FreeRTOS/Source/queue.c **** #endif
 227:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 228:FreeRTOS/Source/queue.c **** 
 229:FreeRTOS/Source/queue.c **** /*
 230:FreeRTOS/Source/queue.c ****  * Macro to mark a queue as locked.  Locking a queue prevents an ISR from
 231:FreeRTOS/Source/queue.c ****  * accessing the queue event lists.
 232:FreeRTOS/Source/queue.c ****  */
 233:FreeRTOS/Source/queue.c **** #define prvLockQueue( pxQueue )								\
 234:FreeRTOS/Source/queue.c **** 	taskENTER_CRITICAL();									\
 235:FreeRTOS/Source/queue.c **** 	{														\
 236:FreeRTOS/Source/queue.c **** 		if( ( pxQueue )->cRxLock == queueUNLOCKED )			\
 237:FreeRTOS/Source/queue.c **** 		{													\
 238:FreeRTOS/Source/queue.c **** 			( pxQueue )->cRxLock = queueLOCKED_UNMODIFIED;	\
 239:FreeRTOS/Source/queue.c **** 		}													\
 240:FreeRTOS/Source/queue.c **** 		if( ( pxQueue )->cTxLock == queueUNLOCKED )			\
 241:FreeRTOS/Source/queue.c **** 		{													\
 242:FreeRTOS/Source/queue.c **** 			( pxQueue )->cTxLock = queueLOCKED_UNMODIFIED;	\
 243:FreeRTOS/Source/queue.c **** 		}													\
 244:FreeRTOS/Source/queue.c **** 	}														\
 245:FreeRTOS/Source/queue.c **** 	taskEXIT_CRITICAL()
 246:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 247:FreeRTOS/Source/queue.c **** 
 248:FreeRTOS/Source/queue.c **** BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
 249:FreeRTOS/Source/queue.c **** {
 250:FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 251:FreeRTOS/Source/queue.c **** 
 252:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
 253:FreeRTOS/Source/queue.c **** 
 254:FreeRTOS/Source/queue.c **** 	taskENTER_CRITICAL();
 255:FreeRTOS/Source/queue.c **** 	{
 256:FreeRTOS/Source/queue.c **** 		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
 257:FreeRTOS/Source/queue.c **** 		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 258:FreeRTOS/Source/queue.c **** 		pxQueue->pcWriteTo = pxQueue->pcHead;
 259:FreeRTOS/Source/queue.c **** 		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue-
 260:FreeRTOS/Source/queue.c **** 		pxQueue->cRxLock = queueUNLOCKED;
 261:FreeRTOS/Source/queue.c **** 		pxQueue->cTxLock = queueUNLOCKED;
 262:FreeRTOS/Source/queue.c **** 
 263:FreeRTOS/Source/queue.c **** 		if( xNewQueue == pdFALSE )
 264:FreeRTOS/Source/queue.c **** 		{
 265:FreeRTOS/Source/queue.c **** 			/* If there are tasks blocked waiting to read from the queue, then
 266:FreeRTOS/Source/queue.c **** 			the tasks will remain blocked as after this function exits the queue
 267:FreeRTOS/Source/queue.c **** 			will still be empty.  If there are tasks blocked waiting to write to
 268:FreeRTOS/Source/queue.c **** 			the queue, then one should be unblocked as after this function exits
 269:FreeRTOS/Source/queue.c **** 			it will be possible to write to it. */
 270:FreeRTOS/Source/queue.c **** 			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 271:FreeRTOS/Source/queue.c **** 			{
 272:FreeRTOS/Source/queue.c **** 				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 273:FreeRTOS/Source/queue.c **** 				{
 274:FreeRTOS/Source/queue.c **** 					queueYIELD_IF_USING_PREEMPTION();
 275:FreeRTOS/Source/queue.c **** 				}
 276:FreeRTOS/Source/queue.c **** 				else
 277:FreeRTOS/Source/queue.c **** 				{
 278:FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
 279:FreeRTOS/Source/queue.c **** 				}
 280:FreeRTOS/Source/queue.c **** 			}
 281:FreeRTOS/Source/queue.c **** 			else
 282:FreeRTOS/Source/queue.c **** 			{
 283:FreeRTOS/Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
 284:FreeRTOS/Source/queue.c **** 			}
 285:FreeRTOS/Source/queue.c **** 		}
 286:FreeRTOS/Source/queue.c **** 		else
 287:FreeRTOS/Source/queue.c **** 		{
 288:FreeRTOS/Source/queue.c **** 			/* Ensure the event queues start in the correct state. */
 289:FreeRTOS/Source/queue.c **** 			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 290:FreeRTOS/Source/queue.c **** 			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 291:FreeRTOS/Source/queue.c **** 		}
 292:FreeRTOS/Source/queue.c **** 	}
 293:FreeRTOS/Source/queue.c **** 	taskEXIT_CRITICAL();
 294:FreeRTOS/Source/queue.c **** 
 295:FreeRTOS/Source/queue.c **** 	/* A value is returned for calling semantic consistency with previous
 296:FreeRTOS/Source/queue.c **** 	versions. */
 297:FreeRTOS/Source/queue.c **** 	return pdPASS;
 298:FreeRTOS/Source/queue.c **** }
 299:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 300:FreeRTOS/Source/queue.c **** 
 301:FreeRTOS/Source/queue.c **** #if( configSUPPORT_STATIC_ALLOCATION == 1 )
 302:FreeRTOS/Source/queue.c **** 
 303:FreeRTOS/Source/queue.c **** 	QueueHandle_t xQueueGenericCreateStatic( const UBaseType_t uxQueueLength, const UBaseType_t uxItem
 304:FreeRTOS/Source/queue.c **** 	{
 305:FreeRTOS/Source/queue.c **** 	Queue_t *pxNewQueue;
 306:FreeRTOS/Source/queue.c **** 
 307:FreeRTOS/Source/queue.c **** 		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
 308:FreeRTOS/Source/queue.c **** 
 309:FreeRTOS/Source/queue.c **** 		/* The StaticQueue_t structure and the queue storage area must be
 310:FreeRTOS/Source/queue.c **** 		supplied. */
 311:FreeRTOS/Source/queue.c **** 		configASSERT( pxStaticQueue != NULL );
 312:FreeRTOS/Source/queue.c **** 
 313:FreeRTOS/Source/queue.c **** 		/* A queue storage area should be provided if the item size is not 0, and
 314:FreeRTOS/Source/queue.c **** 		should not be provided if the item size is 0. */
 315:FreeRTOS/Source/queue.c **** 		configASSERT( !( ( pucQueueStorage != NULL ) && ( uxItemSize == 0 ) ) );
 316:FreeRTOS/Source/queue.c **** 		configASSERT( !( ( pucQueueStorage == NULL ) && ( uxItemSize != 0 ) ) );
 317:FreeRTOS/Source/queue.c **** 
 318:FreeRTOS/Source/queue.c **** 		#if( configASSERT_DEFINED == 1 )
 319:FreeRTOS/Source/queue.c **** 		{
 320:FreeRTOS/Source/queue.c **** 			/* Sanity check that the size of the structure used to declare a
 321:FreeRTOS/Source/queue.c **** 			variable of type StaticQueue_t or StaticSemaphore_t equals the size of
 322:FreeRTOS/Source/queue.c **** 			the real queue and semaphore structures. */
 323:FreeRTOS/Source/queue.c **** 			volatile size_t xSize = sizeof( StaticQueue_t );
 324:FreeRTOS/Source/queue.c **** 			configASSERT( xSize == sizeof( Queue_t ) );
 325:FreeRTOS/Source/queue.c **** 		}
 326:FreeRTOS/Source/queue.c **** 		#endif /* configASSERT_DEFINED */
 327:FreeRTOS/Source/queue.c **** 
 328:FreeRTOS/Source/queue.c **** 		/* The address of a statically allocated queue was passed in, use it.
 329:FreeRTOS/Source/queue.c **** 		The address of a statically allocated storage area was also passed in
 330:FreeRTOS/Source/queue.c **** 		but is already set. */
 331:FreeRTOS/Source/queue.c **** 		pxNewQueue = ( Queue_t * ) pxStaticQueue; /*lint !e740 Unusual cast is ok as the structures are d
 332:FreeRTOS/Source/queue.c **** 
 333:FreeRTOS/Source/queue.c **** 		if( pxNewQueue != NULL )
 334:FreeRTOS/Source/queue.c **** 		{
 335:FreeRTOS/Source/queue.c **** 			#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
 336:FreeRTOS/Source/queue.c **** 			{
 337:FreeRTOS/Source/queue.c **** 				/* Queues can be allocated wither statically or dynamically, so
 338:FreeRTOS/Source/queue.c **** 				note this queue was allocated statically in case the queue is
 339:FreeRTOS/Source/queue.c **** 				later deleted. */
 340:FreeRTOS/Source/queue.c **** 				pxNewQueue->ucStaticallyAllocated = pdTRUE;
 341:FreeRTOS/Source/queue.c **** 			}
 342:FreeRTOS/Source/queue.c **** 			#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
 343:FreeRTOS/Source/queue.c **** 
 344:FreeRTOS/Source/queue.c **** 			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
 345:FreeRTOS/Source/queue.c **** 		}
 346:FreeRTOS/Source/queue.c **** 		else
 347:FreeRTOS/Source/queue.c **** 		{
 348:FreeRTOS/Source/queue.c **** 			traceQUEUE_CREATE_FAILED( ucQueueType );
 349:FreeRTOS/Source/queue.c **** 		}
 350:FreeRTOS/Source/queue.c **** 
 351:FreeRTOS/Source/queue.c **** 		return pxNewQueue;
 352:FreeRTOS/Source/queue.c **** 	}
 353:FreeRTOS/Source/queue.c **** 
 354:FreeRTOS/Source/queue.c **** #endif /* configSUPPORT_STATIC_ALLOCATION */
 355:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 356:FreeRTOS/Source/queue.c **** 
 357:FreeRTOS/Source/queue.c **** #if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
 358:FreeRTOS/Source/queue.c **** 
 359:FreeRTOS/Source/queue.c **** 	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, 
 360:FreeRTOS/Source/queue.c **** 	{
 361:FreeRTOS/Source/queue.c **** 	Queue_t *pxNewQueue;
 362:FreeRTOS/Source/queue.c **** 	size_t xQueueSizeInBytes;
 363:FreeRTOS/Source/queue.c **** 	uint8_t *pucQueueStorage;
 364:FreeRTOS/Source/queue.c **** 
 365:FreeRTOS/Source/queue.c **** 		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
 366:FreeRTOS/Source/queue.c **** 
 367:FreeRTOS/Source/queue.c **** 		if( uxItemSize == ( UBaseType_t ) 0 )
 368:FreeRTOS/Source/queue.c **** 		{
 369:FreeRTOS/Source/queue.c **** 			/* There is not going to be a queue storage area. */
 370:FreeRTOS/Source/queue.c **** 			xQueueSizeInBytes = ( size_t ) 0;
 371:FreeRTOS/Source/queue.c **** 		}
 372:FreeRTOS/Source/queue.c **** 		else
 373:FreeRTOS/Source/queue.c **** 		{
 374:FreeRTOS/Source/queue.c **** 			/* Allocate enough space to hold the maximum number of items that
 375:FreeRTOS/Source/queue.c **** 			can be in the queue at any time. */
 376:FreeRTOS/Source/queue.c **** 			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as t
 377:FreeRTOS/Source/queue.c **** 		}
 378:FreeRTOS/Source/queue.c **** 
 379:FreeRTOS/Source/queue.c **** 		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
 380:FreeRTOS/Source/queue.c **** 
 381:FreeRTOS/Source/queue.c **** 		if( pxNewQueue != NULL )
 382:FreeRTOS/Source/queue.c **** 		{
 383:FreeRTOS/Source/queue.c **** 			/* Jump past the queue structure to find the location of the queue
 384:FreeRTOS/Source/queue.c **** 			storage area. */
 385:FreeRTOS/Source/queue.c **** 			pucQueueStorage = ( ( uint8_t * ) pxNewQueue ) + sizeof( Queue_t );
 386:FreeRTOS/Source/queue.c **** 
 387:FreeRTOS/Source/queue.c **** 			#if( configSUPPORT_STATIC_ALLOCATION == 1 )
 388:FreeRTOS/Source/queue.c **** 			{
 389:FreeRTOS/Source/queue.c **** 				/* Queues can be created either statically or dynamically, so
 390:FreeRTOS/Source/queue.c **** 				note this task was created dynamically in case it is later
 391:FreeRTOS/Source/queue.c **** 				deleted. */
 392:FreeRTOS/Source/queue.c **** 				pxNewQueue->ucStaticallyAllocated = pdFALSE;
 393:FreeRTOS/Source/queue.c **** 			}
 394:FreeRTOS/Source/queue.c **** 			#endif /* configSUPPORT_STATIC_ALLOCATION */
 395:FreeRTOS/Source/queue.c **** 
 396:FreeRTOS/Source/queue.c **** 			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
 397:FreeRTOS/Source/queue.c **** 		}
 398:FreeRTOS/Source/queue.c **** 		else
 399:FreeRTOS/Source/queue.c **** 		{
 400:FreeRTOS/Source/queue.c **** 			traceQUEUE_CREATE_FAILED( ucQueueType );
 401:FreeRTOS/Source/queue.c **** 		}
 402:FreeRTOS/Source/queue.c **** 
 403:FreeRTOS/Source/queue.c **** 		return pxNewQueue;
 404:FreeRTOS/Source/queue.c **** 	}
 405:FreeRTOS/Source/queue.c **** 
 406:FreeRTOS/Source/queue.c **** #endif /* configSUPPORT_STATIC_ALLOCATION */
 407:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 408:FreeRTOS/Source/queue.c **** 
 409:FreeRTOS/Source/queue.c **** static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, u
 410:FreeRTOS/Source/queue.c **** {
 411:FreeRTOS/Source/queue.c **** 	/* Remove compiler warnings about unused parameters should
 412:FreeRTOS/Source/queue.c **** 	configUSE_TRACE_FACILITY not be set to 1. */
 413:FreeRTOS/Source/queue.c **** 	( void ) ucQueueType;
 414:FreeRTOS/Source/queue.c **** 
 415:FreeRTOS/Source/queue.c **** 	if( uxItemSize == ( UBaseType_t ) 0 )
 416:FreeRTOS/Source/queue.c **** 	{
 417:FreeRTOS/Source/queue.c **** 		/* No RAM was allocated for the queue storage area, but PC head cannot
 418:FreeRTOS/Source/queue.c **** 		be set to NULL because NULL is used as a key to say the queue is used as
 419:FreeRTOS/Source/queue.c **** 		a mutex.  Therefore just set pcHead to point to the queue as a benign
 420:FreeRTOS/Source/queue.c **** 		value that is known to be within the memory map. */
 421:FreeRTOS/Source/queue.c **** 		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 422:FreeRTOS/Source/queue.c **** 	}
 423:FreeRTOS/Source/queue.c **** 	else
 424:FreeRTOS/Source/queue.c **** 	{
 425:FreeRTOS/Source/queue.c **** 		/* Set the head to the start of the queue storage area. */
 426:FreeRTOS/Source/queue.c **** 		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
 427:FreeRTOS/Source/queue.c **** 	}
 428:FreeRTOS/Source/queue.c **** 
 429:FreeRTOS/Source/queue.c **** 	/* Initialise the queue members as described where the queue type is
 430:FreeRTOS/Source/queue.c **** 	defined. */
 431:FreeRTOS/Source/queue.c **** 	pxNewQueue->uxLength = uxQueueLength;
 432:FreeRTOS/Source/queue.c **** 	pxNewQueue->uxItemSize = uxItemSize;
 433:FreeRTOS/Source/queue.c **** 	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 434:FreeRTOS/Source/queue.c **** 
 435:FreeRTOS/Source/queue.c **** 	#if ( configUSE_TRACE_FACILITY == 1 )
 436:FreeRTOS/Source/queue.c **** 	{
 437:FreeRTOS/Source/queue.c **** 		pxNewQueue->ucQueueType = ucQueueType;
 438:FreeRTOS/Source/queue.c **** 	}
 439:FreeRTOS/Source/queue.c **** 	#endif /* configUSE_TRACE_FACILITY */
 440:FreeRTOS/Source/queue.c **** 
 441:FreeRTOS/Source/queue.c **** 	#if( configUSE_QUEUE_SETS == 1 )
 442:FreeRTOS/Source/queue.c **** 	{
 443:FreeRTOS/Source/queue.c **** 		pxNewQueue->pxQueueSetContainer = NULL;
 444:FreeRTOS/Source/queue.c **** 	}
 445:FreeRTOS/Source/queue.c **** 	#endif /* configUSE_QUEUE_SETS */
 446:FreeRTOS/Source/queue.c **** 
 447:FreeRTOS/Source/queue.c **** 	traceQUEUE_CREATE( pxNewQueue );
 448:FreeRTOS/Source/queue.c **** }
 449:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 450:FreeRTOS/Source/queue.c **** 
 451:FreeRTOS/Source/queue.c **** #if( configUSE_MUTEXES == 1 )
 452:FreeRTOS/Source/queue.c **** 
 453:FreeRTOS/Source/queue.c **** 	static void prvInitialiseMutex( Queue_t *pxNewQueue )
 454:FreeRTOS/Source/queue.c **** 	{
 455:FreeRTOS/Source/queue.c **** 		if( pxNewQueue != NULL )
 456:FreeRTOS/Source/queue.c **** 		{
 457:FreeRTOS/Source/queue.c **** 			/* The queue create function will set all the queue structure members
 458:FreeRTOS/Source/queue.c **** 			correctly for a generic queue, but this function is creating a
 459:FreeRTOS/Source/queue.c **** 			mutex.  Overwrite those members that need to be set differently -
 460:FreeRTOS/Source/queue.c **** 			in particular the information required for priority inheritance. */
 461:FreeRTOS/Source/queue.c **** 			pxNewQueue->pxMutexHolder = NULL;
 462:FreeRTOS/Source/queue.c **** 			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
 463:FreeRTOS/Source/queue.c **** 
 464:FreeRTOS/Source/queue.c **** 			/* In case this is a recursive mutex. */
 465:FreeRTOS/Source/queue.c **** 			pxNewQueue->u.uxRecursiveCallCount = 0;
 466:FreeRTOS/Source/queue.c **** 
 467:FreeRTOS/Source/queue.c **** 			traceCREATE_MUTEX( pxNewQueue );
 468:FreeRTOS/Source/queue.c **** 
 469:FreeRTOS/Source/queue.c **** 			/* Start with the semaphore in the expected state. */
 470:FreeRTOS/Source/queue.c **** 			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
 471:FreeRTOS/Source/queue.c **** 		}
 472:FreeRTOS/Source/queue.c **** 		else
 473:FreeRTOS/Source/queue.c **** 		{
 474:FreeRTOS/Source/queue.c **** 			traceCREATE_MUTEX_FAILED();
 475:FreeRTOS/Source/queue.c **** 		}
 476:FreeRTOS/Source/queue.c **** 	}
 477:FreeRTOS/Source/queue.c **** 
 478:FreeRTOS/Source/queue.c **** #endif /* configUSE_MUTEXES */
 479:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 480:FreeRTOS/Source/queue.c **** 
 481:FreeRTOS/Source/queue.c **** #if( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
 482:FreeRTOS/Source/queue.c **** 
 483:FreeRTOS/Source/queue.c **** 	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
 484:FreeRTOS/Source/queue.c **** 	{
 485:FreeRTOS/Source/queue.c **** 	Queue_t *pxNewQueue;
 486:FreeRTOS/Source/queue.c **** 	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
 487:FreeRTOS/Source/queue.c **** 
 488:FreeRTOS/Source/queue.c **** 		pxNewQueue = ( Queue_t * ) xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
 489:FreeRTOS/Source/queue.c **** 		prvInitialiseMutex( pxNewQueue );
 490:FreeRTOS/Source/queue.c **** 
 491:FreeRTOS/Source/queue.c **** 		return pxNewQueue;
 492:FreeRTOS/Source/queue.c **** 	}
 493:FreeRTOS/Source/queue.c **** 
 494:FreeRTOS/Source/queue.c **** #endif /* configUSE_MUTEXES */
 495:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 496:FreeRTOS/Source/queue.c **** 
 497:FreeRTOS/Source/queue.c **** #if( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
 498:FreeRTOS/Source/queue.c **** 
 499:FreeRTOS/Source/queue.c **** 	QueueHandle_t xQueueCreateMutexStatic( const uint8_t ucQueueType, StaticQueue_t *pxStaticQueue )
 500:FreeRTOS/Source/queue.c **** 	{
 501:FreeRTOS/Source/queue.c **** 	Queue_t *pxNewQueue;
 502:FreeRTOS/Source/queue.c **** 	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
 503:FreeRTOS/Source/queue.c **** 
 504:FreeRTOS/Source/queue.c **** 		/* Prevent compiler warnings about unused parameters if
 505:FreeRTOS/Source/queue.c **** 		configUSE_TRACE_FACILITY does not equal 1. */
 506:FreeRTOS/Source/queue.c **** 		( void ) ucQueueType;
 507:FreeRTOS/Source/queue.c **** 
 508:FreeRTOS/Source/queue.c **** 		pxNewQueue = ( Queue_t * ) xQueueGenericCreateStatic( uxMutexLength, uxMutexSize, NULL, pxStaticQ
 509:FreeRTOS/Source/queue.c **** 		prvInitialiseMutex( pxNewQueue );
 510:FreeRTOS/Source/queue.c **** 
 511:FreeRTOS/Source/queue.c **** 		return pxNewQueue;
 512:FreeRTOS/Source/queue.c **** 	}
 513:FreeRTOS/Source/queue.c **** 
 514:FreeRTOS/Source/queue.c **** #endif /* configUSE_MUTEXES */
 515:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 516:FreeRTOS/Source/queue.c **** 
 517:FreeRTOS/Source/queue.c **** #if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) )
 518:FreeRTOS/Source/queue.c **** 
 519:FreeRTOS/Source/queue.c **** 	void* xQueueGetMutexHolder( QueueHandle_t xSemaphore )
 520:FreeRTOS/Source/queue.c **** 	{
 521:FreeRTOS/Source/queue.c **** 	void *pxReturn;
 522:FreeRTOS/Source/queue.c **** 
 523:FreeRTOS/Source/queue.c **** 		/* This function is called by xSemaphoreGetMutexHolder(), and should not
 524:FreeRTOS/Source/queue.c **** 		be called directly.  Note:  This is a good way of determining if the
 525:FreeRTOS/Source/queue.c **** 		calling task is the mutex holder, but not a good way of determining the
 526:FreeRTOS/Source/queue.c **** 		identity of the mutex holder, as the holder may change between the
 527:FreeRTOS/Source/queue.c **** 		following critical section exiting and the function returning. */
 528:FreeRTOS/Source/queue.c **** 		taskENTER_CRITICAL();
 529:FreeRTOS/Source/queue.c **** 		{
 530:FreeRTOS/Source/queue.c **** 			if( ( ( Queue_t * ) xSemaphore )->uxQueueType == queueQUEUE_IS_MUTEX )
 531:FreeRTOS/Source/queue.c **** 			{
 532:FreeRTOS/Source/queue.c **** 				pxReturn = ( void * ) ( ( Queue_t * ) xSemaphore )->pxMutexHolder;
 533:FreeRTOS/Source/queue.c **** 			}
 534:FreeRTOS/Source/queue.c **** 			else
 535:FreeRTOS/Source/queue.c **** 			{
 536:FreeRTOS/Source/queue.c **** 				pxReturn = NULL;
 537:FreeRTOS/Source/queue.c **** 			}
 538:FreeRTOS/Source/queue.c **** 		}
 539:FreeRTOS/Source/queue.c **** 		taskEXIT_CRITICAL();
 540:FreeRTOS/Source/queue.c **** 
 541:FreeRTOS/Source/queue.c **** 		return pxReturn;
 542:FreeRTOS/Source/queue.c **** 	} /*lint !e818 xSemaphore cannot be a pointer to const because it is a typedef. */
 543:FreeRTOS/Source/queue.c **** 
 544:FreeRTOS/Source/queue.c **** #endif
 545:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 546:FreeRTOS/Source/queue.c **** 
 547:FreeRTOS/Source/queue.c **** #if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) )
 548:FreeRTOS/Source/queue.c **** 
 549:FreeRTOS/Source/queue.c **** 	void* xQueueGetMutexHolderFromISR( QueueHandle_t xSemaphore )
 550:FreeRTOS/Source/queue.c **** 	{
 551:FreeRTOS/Source/queue.c **** 	void *pxReturn;
 552:FreeRTOS/Source/queue.c **** 
 553:FreeRTOS/Source/queue.c **** 		configASSERT( xSemaphore );
 554:FreeRTOS/Source/queue.c **** 
 555:FreeRTOS/Source/queue.c **** 		/* Mutexes cannot be used in interrupt service routines, so the mutex
 556:FreeRTOS/Source/queue.c **** 		holder should not change in an ISR, and therefore a critical section is
 557:FreeRTOS/Source/queue.c **** 		not required here. */
 558:FreeRTOS/Source/queue.c **** 		if( ( ( Queue_t * ) xSemaphore )->uxQueueType == queueQUEUE_IS_MUTEX )
 559:FreeRTOS/Source/queue.c **** 		{
 560:FreeRTOS/Source/queue.c **** 			pxReturn = ( void * ) ( ( Queue_t * ) xSemaphore )->pxMutexHolder;
 561:FreeRTOS/Source/queue.c **** 		}
 562:FreeRTOS/Source/queue.c **** 		else
 563:FreeRTOS/Source/queue.c **** 		{
 564:FreeRTOS/Source/queue.c **** 			pxReturn = NULL;
 565:FreeRTOS/Source/queue.c **** 		}
 566:FreeRTOS/Source/queue.c **** 
 567:FreeRTOS/Source/queue.c **** 		return pxReturn;
 568:FreeRTOS/Source/queue.c **** 	} /*lint !e818 xSemaphore cannot be a pointer to const because it is a typedef. */
 569:FreeRTOS/Source/queue.c **** 
 570:FreeRTOS/Source/queue.c **** #endif
 571:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 572:FreeRTOS/Source/queue.c **** 
 573:FreeRTOS/Source/queue.c **** #if ( configUSE_RECURSIVE_MUTEXES == 1 )
 574:FreeRTOS/Source/queue.c **** 
 575:FreeRTOS/Source/queue.c **** 	BaseType_t xQueueGiveMutexRecursive( QueueHandle_t xMutex )
 576:FreeRTOS/Source/queue.c **** 	{
 577:FreeRTOS/Source/queue.c **** 	BaseType_t xReturn;
 578:FreeRTOS/Source/queue.c **** 	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
 579:FreeRTOS/Source/queue.c **** 
 580:FreeRTOS/Source/queue.c **** 		configASSERT( pxMutex );
 581:FreeRTOS/Source/queue.c **** 
 582:FreeRTOS/Source/queue.c **** 		/* If this is the task that holds the mutex then pxMutexHolder will not
 583:FreeRTOS/Source/queue.c **** 		change outside of this task.  If this task does not hold the mutex then
 584:FreeRTOS/Source/queue.c **** 		pxMutexHolder can never coincidentally equal the tasks handle, and as
 585:FreeRTOS/Source/queue.c **** 		this is the only condition we are interested in it does not matter if
 586:FreeRTOS/Source/queue.c **** 		pxMutexHolder is accessed simultaneously by another task.  Therefore no
 587:FreeRTOS/Source/queue.c **** 		mutual exclusion is required to test the pxMutexHolder variable. */
 588:FreeRTOS/Source/queue.c **** 		if( pxMutex->pxMutexHolder == ( void * ) xTaskGetCurrentTaskHandle() ) /*lint !e961 Not a redunda
 589:FreeRTOS/Source/queue.c **** 		{
 590:FreeRTOS/Source/queue.c **** 			traceGIVE_MUTEX_RECURSIVE( pxMutex );
 591:FreeRTOS/Source/queue.c **** 
 592:FreeRTOS/Source/queue.c **** 			/* uxRecursiveCallCount cannot be zero if pxMutexHolder is equal to
 593:FreeRTOS/Source/queue.c **** 			the task handle, therefore no underflow check is required.  Also,
 594:FreeRTOS/Source/queue.c **** 			uxRecursiveCallCount is only modified by the mutex holder, and as
 595:FreeRTOS/Source/queue.c **** 			there can only be one, no mutual exclusion is required to modify the
 596:FreeRTOS/Source/queue.c **** 			uxRecursiveCallCount member. */
 597:FreeRTOS/Source/queue.c **** 			( pxMutex->u.uxRecursiveCallCount )--;
 598:FreeRTOS/Source/queue.c **** 
 599:FreeRTOS/Source/queue.c **** 			/* Has the recursive call count unwound to 0? */
 600:FreeRTOS/Source/queue.c **** 			if( pxMutex->u.uxRecursiveCallCount == ( UBaseType_t ) 0 )
 601:FreeRTOS/Source/queue.c **** 			{
 602:FreeRTOS/Source/queue.c **** 				/* Return the mutex.  This will automatically unblock any other
 603:FreeRTOS/Source/queue.c **** 				task that might be waiting to access the mutex. */
 604:FreeRTOS/Source/queue.c **** 				( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
 605:FreeRTOS/Source/queue.c **** 			}
 606:FreeRTOS/Source/queue.c **** 			else
 607:FreeRTOS/Source/queue.c **** 			{
 608:FreeRTOS/Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
 609:FreeRTOS/Source/queue.c **** 			}
 610:FreeRTOS/Source/queue.c **** 
 611:FreeRTOS/Source/queue.c **** 			xReturn = pdPASS;
 612:FreeRTOS/Source/queue.c **** 		}
 613:FreeRTOS/Source/queue.c **** 		else
 614:FreeRTOS/Source/queue.c **** 		{
 615:FreeRTOS/Source/queue.c **** 			/* The mutex cannot be given because the calling task is not the
 616:FreeRTOS/Source/queue.c **** 			holder. */
 617:FreeRTOS/Source/queue.c **** 			xReturn = pdFAIL;
 618:FreeRTOS/Source/queue.c **** 
 619:FreeRTOS/Source/queue.c **** 			traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );
 620:FreeRTOS/Source/queue.c **** 		}
 621:FreeRTOS/Source/queue.c **** 
 622:FreeRTOS/Source/queue.c **** 		return xReturn;
 623:FreeRTOS/Source/queue.c **** 	}
 624:FreeRTOS/Source/queue.c **** 
 625:FreeRTOS/Source/queue.c **** #endif /* configUSE_RECURSIVE_MUTEXES */
 626:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 627:FreeRTOS/Source/queue.c **** 
 628:FreeRTOS/Source/queue.c **** #if ( configUSE_RECURSIVE_MUTEXES == 1 )
 629:FreeRTOS/Source/queue.c **** 
 630:FreeRTOS/Source/queue.c **** 	BaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex, TickType_t xTicksToWait )
 631:FreeRTOS/Source/queue.c **** 	{
 632:FreeRTOS/Source/queue.c **** 	BaseType_t xReturn;
 633:FreeRTOS/Source/queue.c **** 	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
 634:FreeRTOS/Source/queue.c **** 
 635:FreeRTOS/Source/queue.c **** 		configASSERT( pxMutex );
 636:FreeRTOS/Source/queue.c **** 
 637:FreeRTOS/Source/queue.c **** 		/* Comments regarding mutual exclusion as per those within
 638:FreeRTOS/Source/queue.c **** 		xQueueGiveMutexRecursive(). */
 639:FreeRTOS/Source/queue.c **** 
 640:FreeRTOS/Source/queue.c **** 		traceTAKE_MUTEX_RECURSIVE( pxMutex );
 641:FreeRTOS/Source/queue.c **** 
 642:FreeRTOS/Source/queue.c **** 		if( pxMutex->pxMutexHolder == ( void * ) xTaskGetCurrentTaskHandle() ) /*lint !e961 Cast is not r
 643:FreeRTOS/Source/queue.c **** 		{
 644:FreeRTOS/Source/queue.c **** 			( pxMutex->u.uxRecursiveCallCount )++;
 645:FreeRTOS/Source/queue.c **** 			xReturn = pdPASS;
 646:FreeRTOS/Source/queue.c **** 		}
 647:FreeRTOS/Source/queue.c **** 		else
 648:FreeRTOS/Source/queue.c **** 		{
 649:FreeRTOS/Source/queue.c **** 			xReturn = xQueueSemaphoreTake( pxMutex, xTicksToWait );
 650:FreeRTOS/Source/queue.c **** 
 651:FreeRTOS/Source/queue.c **** 			/* pdPASS will only be returned if the mutex was successfully
 652:FreeRTOS/Source/queue.c **** 			obtained.  The calling task may have entered the Blocked state
 653:FreeRTOS/Source/queue.c **** 			before reaching here. */
 654:FreeRTOS/Source/queue.c **** 			if( xReturn != pdFAIL )
 655:FreeRTOS/Source/queue.c **** 			{
 656:FreeRTOS/Source/queue.c **** 				( pxMutex->u.uxRecursiveCallCount )++;
 657:FreeRTOS/Source/queue.c **** 			}
 658:FreeRTOS/Source/queue.c **** 			else
 659:FreeRTOS/Source/queue.c **** 			{
 660:FreeRTOS/Source/queue.c **** 				traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex );
 661:FreeRTOS/Source/queue.c **** 			}
 662:FreeRTOS/Source/queue.c **** 		}
 663:FreeRTOS/Source/queue.c **** 
 664:FreeRTOS/Source/queue.c **** 		return xReturn;
 665:FreeRTOS/Source/queue.c **** 	}
 666:FreeRTOS/Source/queue.c **** 
 667:FreeRTOS/Source/queue.c **** #endif /* configUSE_RECURSIVE_MUTEXES */
 668:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 669:FreeRTOS/Source/queue.c **** 
 670:FreeRTOS/Source/queue.c **** #if( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
 671:FreeRTOS/Source/queue.c **** 
 672:FreeRTOS/Source/queue.c **** 	QueueHandle_t xQueueCreateCountingSemaphoreStatic( const UBaseType_t uxMaxCount, const UBaseType_t
 673:FreeRTOS/Source/queue.c **** 	{
 674:FreeRTOS/Source/queue.c **** 	QueueHandle_t xHandle;
 675:FreeRTOS/Source/queue.c **** 
 676:FreeRTOS/Source/queue.c **** 		configASSERT( uxMaxCount != 0 );
 677:FreeRTOS/Source/queue.c **** 		configASSERT( uxInitialCount <= uxMaxCount );
 678:FreeRTOS/Source/queue.c **** 
 679:FreeRTOS/Source/queue.c **** 		xHandle = xQueueGenericCreateStatic( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, NULL, pxStatic
 680:FreeRTOS/Source/queue.c **** 
 681:FreeRTOS/Source/queue.c **** 		if( xHandle != NULL )
 682:FreeRTOS/Source/queue.c **** 		{
 683:FreeRTOS/Source/queue.c **** 			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
 684:FreeRTOS/Source/queue.c **** 
 685:FreeRTOS/Source/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE();
 686:FreeRTOS/Source/queue.c **** 		}
 687:FreeRTOS/Source/queue.c **** 		else
 688:FreeRTOS/Source/queue.c **** 		{
 689:FreeRTOS/Source/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE_FAILED();
 690:FreeRTOS/Source/queue.c **** 		}
 691:FreeRTOS/Source/queue.c **** 
 692:FreeRTOS/Source/queue.c **** 		return xHandle;
 693:FreeRTOS/Source/queue.c **** 	}
 694:FreeRTOS/Source/queue.c **** 
 695:FreeRTOS/Source/queue.c **** #endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) *
 696:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 697:FreeRTOS/Source/queue.c **** 
 698:FreeRTOS/Source/queue.c **** #if( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
 699:FreeRTOS/Source/queue.c **** 
 700:FreeRTOS/Source/queue.c **** 	QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxIni
 701:FreeRTOS/Source/queue.c **** 	{
 702:FreeRTOS/Source/queue.c **** 	QueueHandle_t xHandle;
 703:FreeRTOS/Source/queue.c **** 
 704:FreeRTOS/Source/queue.c **** 		configASSERT( uxMaxCount != 0 );
 705:FreeRTOS/Source/queue.c **** 		configASSERT( uxInitialCount <= uxMaxCount );
 706:FreeRTOS/Source/queue.c **** 
 707:FreeRTOS/Source/queue.c **** 		xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUN
 708:FreeRTOS/Source/queue.c **** 
 709:FreeRTOS/Source/queue.c **** 		if( xHandle != NULL )
 710:FreeRTOS/Source/queue.c **** 		{
 711:FreeRTOS/Source/queue.c **** 			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
 712:FreeRTOS/Source/queue.c **** 
 713:FreeRTOS/Source/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE();
 714:FreeRTOS/Source/queue.c **** 		}
 715:FreeRTOS/Source/queue.c **** 		else
 716:FreeRTOS/Source/queue.c **** 		{
 717:FreeRTOS/Source/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE_FAILED();
 718:FreeRTOS/Source/queue.c **** 		}
 719:FreeRTOS/Source/queue.c **** 
 720:FreeRTOS/Source/queue.c **** 		return xHandle;
 721:FreeRTOS/Source/queue.c **** 	}
 722:FreeRTOS/Source/queue.c **** 
 723:FreeRTOS/Source/queue.c **** #endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) *
 724:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 725:FreeRTOS/Source/queue.c **** 
 726:FreeRTOS/Source/queue.c **** BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xT
 727:FreeRTOS/Source/queue.c **** {
 728:FreeRTOS/Source/queue.c **** BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
 729:FreeRTOS/Source/queue.c **** TimeOut_t xTimeOut;
 730:FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 731:FreeRTOS/Source/queue.c **** 
 732:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
 733:FreeRTOS/Source/queue.c **** 	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 734:FreeRTOS/Source/queue.c **** 	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 735:FreeRTOS/Source/queue.c **** 	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
 736:FreeRTOS/Source/queue.c **** 	{
 737:FreeRTOS/Source/queue.c **** 		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 )
 738:FreeRTOS/Source/queue.c **** 	}
 739:FreeRTOS/Source/queue.c **** 	#endif
 740:FreeRTOS/Source/queue.c **** 
 741:FreeRTOS/Source/queue.c **** 
 742:FreeRTOS/Source/queue.c **** 	/* This function relaxes the coding standard somewhat to allow return
 743:FreeRTOS/Source/queue.c **** 	statements within the function itself.  This is done in the interest
 744:FreeRTOS/Source/queue.c **** 	of execution time efficiency. */
 745:FreeRTOS/Source/queue.c **** 	for( ;; )
 746:FreeRTOS/Source/queue.c **** 	{
 747:FreeRTOS/Source/queue.c **** 		taskENTER_CRITICAL();
 748:FreeRTOS/Source/queue.c **** 		{
 749:FreeRTOS/Source/queue.c **** 			/* Is there room on the queue now?  The running task must be the
 750:FreeRTOS/Source/queue.c **** 			highest priority task wanting to access the queue.  If the head item
 751:FreeRTOS/Source/queue.c **** 			in the queue is to be overwritten then it does not matter if the
 752:FreeRTOS/Source/queue.c **** 			queue is full. */
 753:FreeRTOS/Source/queue.c **** 			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 754:FreeRTOS/Source/queue.c **** 			{
 755:FreeRTOS/Source/queue.c **** 				traceQUEUE_SEND( pxQueue );
 756:FreeRTOS/Source/queue.c **** 				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 757:FreeRTOS/Source/queue.c **** 
 758:FreeRTOS/Source/queue.c **** 				#if ( configUSE_QUEUE_SETS == 1 )
 759:FreeRTOS/Source/queue.c **** 				{
 760:FreeRTOS/Source/queue.c **** 					if( pxQueue->pxQueueSetContainer != NULL )
 761:FreeRTOS/Source/queue.c **** 					{
 762:FreeRTOS/Source/queue.c **** 						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) != pdFALSE )
 763:FreeRTOS/Source/queue.c **** 						{
 764:FreeRTOS/Source/queue.c **** 							/* The queue is a member of a queue set, and posting
 765:FreeRTOS/Source/queue.c **** 							to the queue set caused a higher priority task to
 766:FreeRTOS/Source/queue.c **** 							unblock. A context switch is required. */
 767:FreeRTOS/Source/queue.c **** 							queueYIELD_IF_USING_PREEMPTION();
 768:FreeRTOS/Source/queue.c **** 						}
 769:FreeRTOS/Source/queue.c **** 						else
 770:FreeRTOS/Source/queue.c **** 						{
 771:FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
 772:FreeRTOS/Source/queue.c **** 						}
 773:FreeRTOS/Source/queue.c **** 					}
 774:FreeRTOS/Source/queue.c **** 					else
 775:FreeRTOS/Source/queue.c **** 					{
 776:FreeRTOS/Source/queue.c **** 						/* If there was a task waiting for data to arrive on the
 777:FreeRTOS/Source/queue.c **** 						queue then unblock it now. */
 778:FreeRTOS/Source/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 779:FreeRTOS/Source/queue.c **** 						{
 780:FreeRTOS/Source/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 781:FreeRTOS/Source/queue.c **** 							{
 782:FreeRTOS/Source/queue.c **** 								/* The unblocked task has a priority higher than
 783:FreeRTOS/Source/queue.c **** 								our own so yield immediately.  Yes it is ok to
 784:FreeRTOS/Source/queue.c **** 								do this from within the critical section - the
 785:FreeRTOS/Source/queue.c **** 								kernel takes care of that. */
 786:FreeRTOS/Source/queue.c **** 								queueYIELD_IF_USING_PREEMPTION();
 787:FreeRTOS/Source/queue.c **** 							}
 788:FreeRTOS/Source/queue.c **** 							else
 789:FreeRTOS/Source/queue.c **** 							{
 790:FreeRTOS/Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
 791:FreeRTOS/Source/queue.c **** 							}
 792:FreeRTOS/Source/queue.c **** 						}
 793:FreeRTOS/Source/queue.c **** 						else if( xYieldRequired != pdFALSE )
 794:FreeRTOS/Source/queue.c **** 						{
 795:FreeRTOS/Source/queue.c **** 							/* This path is a special case that will only get
 796:FreeRTOS/Source/queue.c **** 							executed if the task was holding multiple mutexes
 797:FreeRTOS/Source/queue.c **** 							and the mutexes were given back in an order that is
 798:FreeRTOS/Source/queue.c **** 							different to that in which they were taken. */
 799:FreeRTOS/Source/queue.c **** 							queueYIELD_IF_USING_PREEMPTION();
 800:FreeRTOS/Source/queue.c **** 						}
 801:FreeRTOS/Source/queue.c **** 						else
 802:FreeRTOS/Source/queue.c **** 						{
 803:FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
 804:FreeRTOS/Source/queue.c **** 						}
 805:FreeRTOS/Source/queue.c **** 					}
 806:FreeRTOS/Source/queue.c **** 				}
 807:FreeRTOS/Source/queue.c **** 				#else /* configUSE_QUEUE_SETS */
 808:FreeRTOS/Source/queue.c **** 				{
 809:FreeRTOS/Source/queue.c **** 					/* If there was a task waiting for data to arrive on the
 810:FreeRTOS/Source/queue.c **** 					queue then unblock it now. */
 811:FreeRTOS/Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 812:FreeRTOS/Source/queue.c **** 					{
 813:FreeRTOS/Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 814:FreeRTOS/Source/queue.c **** 						{
 815:FreeRTOS/Source/queue.c **** 							/* The unblocked task has a priority higher than
 816:FreeRTOS/Source/queue.c **** 							our own so yield immediately.  Yes it is ok to do
 817:FreeRTOS/Source/queue.c **** 							this from within the critical section - the kernel
 818:FreeRTOS/Source/queue.c **** 							takes care of that. */
 819:FreeRTOS/Source/queue.c **** 							queueYIELD_IF_USING_PREEMPTION();
 820:FreeRTOS/Source/queue.c **** 						}
 821:FreeRTOS/Source/queue.c **** 						else
 822:FreeRTOS/Source/queue.c **** 						{
 823:FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
 824:FreeRTOS/Source/queue.c **** 						}
 825:FreeRTOS/Source/queue.c **** 					}
 826:FreeRTOS/Source/queue.c **** 					else if( xYieldRequired != pdFALSE )
 827:FreeRTOS/Source/queue.c **** 					{
 828:FreeRTOS/Source/queue.c **** 						/* This path is a special case that will only get
 829:FreeRTOS/Source/queue.c **** 						executed if the task was holding multiple mutexes and
 830:FreeRTOS/Source/queue.c **** 						the mutexes were given back in an order that is
 831:FreeRTOS/Source/queue.c **** 						different to that in which they were taken. */
 832:FreeRTOS/Source/queue.c **** 						queueYIELD_IF_USING_PREEMPTION();
 833:FreeRTOS/Source/queue.c **** 					}
 834:FreeRTOS/Source/queue.c **** 					else
 835:FreeRTOS/Source/queue.c **** 					{
 836:FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
 837:FreeRTOS/Source/queue.c **** 					}
 838:FreeRTOS/Source/queue.c **** 				}
 839:FreeRTOS/Source/queue.c **** 				#endif /* configUSE_QUEUE_SETS */
 840:FreeRTOS/Source/queue.c **** 
 841:FreeRTOS/Source/queue.c **** 				taskEXIT_CRITICAL();
 842:FreeRTOS/Source/queue.c **** 				return pdPASS;
 843:FreeRTOS/Source/queue.c **** 			}
 844:FreeRTOS/Source/queue.c **** 			else
 845:FreeRTOS/Source/queue.c **** 			{
 846:FreeRTOS/Source/queue.c **** 				if( xTicksToWait == ( TickType_t ) 0 )
 847:FreeRTOS/Source/queue.c **** 				{
 848:FreeRTOS/Source/queue.c **** 					/* The queue was full and no block time is specified (or
 849:FreeRTOS/Source/queue.c **** 					the block time has expired) so leave now. */
 850:FreeRTOS/Source/queue.c **** 					taskEXIT_CRITICAL();
 851:FreeRTOS/Source/queue.c **** 
 852:FreeRTOS/Source/queue.c **** 					/* Return to the original privilege level before exiting
 853:FreeRTOS/Source/queue.c **** 					the function. */
 854:FreeRTOS/Source/queue.c **** 					traceQUEUE_SEND_FAILED( pxQueue );
 855:FreeRTOS/Source/queue.c **** 					return errQUEUE_FULL;
 856:FreeRTOS/Source/queue.c **** 				}
 857:FreeRTOS/Source/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 858:FreeRTOS/Source/queue.c **** 				{
 859:FreeRTOS/Source/queue.c **** 					/* The queue was full and a block time was specified so
 860:FreeRTOS/Source/queue.c **** 					configure the timeout structure. */
 861:FreeRTOS/Source/queue.c **** 					vTaskInternalSetTimeOutState( &xTimeOut );
 862:FreeRTOS/Source/queue.c **** 					xEntryTimeSet = pdTRUE;
 863:FreeRTOS/Source/queue.c **** 				}
 864:FreeRTOS/Source/queue.c **** 				else
 865:FreeRTOS/Source/queue.c **** 				{
 866:FreeRTOS/Source/queue.c **** 					/* Entry time was already set. */
 867:FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
 868:FreeRTOS/Source/queue.c **** 				}
 869:FreeRTOS/Source/queue.c **** 			}
 870:FreeRTOS/Source/queue.c **** 		}
 871:FreeRTOS/Source/queue.c **** 		taskEXIT_CRITICAL();
 872:FreeRTOS/Source/queue.c **** 
 873:FreeRTOS/Source/queue.c **** 		/* Interrupts and other tasks can send to and receive from the queue
 874:FreeRTOS/Source/queue.c **** 		now the critical section has been exited. */
 875:FreeRTOS/Source/queue.c **** 
 876:FreeRTOS/Source/queue.c **** 		vTaskSuspendAll();
 877:FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
 878:FreeRTOS/Source/queue.c **** 
 879:FreeRTOS/Source/queue.c **** 		/* Update the timeout state to see if it has expired yet. */
 880:FreeRTOS/Source/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 881:FreeRTOS/Source/queue.c **** 		{
 882:FreeRTOS/Source/queue.c **** 			if( prvIsQueueFull( pxQueue ) != pdFALSE )
 883:FreeRTOS/Source/queue.c **** 			{
 884:FreeRTOS/Source/queue.c **** 				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
 885:FreeRTOS/Source/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 886:FreeRTOS/Source/queue.c **** 
 887:FreeRTOS/Source/queue.c **** 				/* Unlocking the queue means queue events can effect the
 888:FreeRTOS/Source/queue.c **** 				event list.  It is possible that interrupts occurring now
 889:FreeRTOS/Source/queue.c **** 				remove this task from the event list again - but as the
 890:FreeRTOS/Source/queue.c **** 				scheduler is suspended the task will go onto the pending
 891:FreeRTOS/Source/queue.c **** 				ready last instead of the actual ready list. */
 892:FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 893:FreeRTOS/Source/queue.c **** 
 894:FreeRTOS/Source/queue.c **** 				/* Resuming the scheduler will move tasks from the pending
 895:FreeRTOS/Source/queue.c **** 				ready list into the ready list - so it is feasible that this
 896:FreeRTOS/Source/queue.c **** 				task is already in a ready list before it yields - in which
 897:FreeRTOS/Source/queue.c **** 				case the yield will not cause a context switch unless there
 898:FreeRTOS/Source/queue.c **** 				is also a higher priority task in the pending ready list. */
 899:FreeRTOS/Source/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 900:FreeRTOS/Source/queue.c **** 				{
 901:FreeRTOS/Source/queue.c **** 					portYIELD_WITHIN_API();
 902:FreeRTOS/Source/queue.c **** 				}
 903:FreeRTOS/Source/queue.c **** 			}
 904:FreeRTOS/Source/queue.c **** 			else
 905:FreeRTOS/Source/queue.c **** 			{
 906:FreeRTOS/Source/queue.c **** 				/* Try again. */
 907:FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 908:FreeRTOS/Source/queue.c **** 				( void ) xTaskResumeAll();
 909:FreeRTOS/Source/queue.c **** 			}
 910:FreeRTOS/Source/queue.c **** 		}
 911:FreeRTOS/Source/queue.c **** 		else
 912:FreeRTOS/Source/queue.c **** 		{
 913:FreeRTOS/Source/queue.c **** 			/* The timeout has expired. */
 914:FreeRTOS/Source/queue.c **** 			prvUnlockQueue( pxQueue );
 915:FreeRTOS/Source/queue.c **** 			( void ) xTaskResumeAll();
 916:FreeRTOS/Source/queue.c **** 
 917:FreeRTOS/Source/queue.c **** 			traceQUEUE_SEND_FAILED( pxQueue );
 918:FreeRTOS/Source/queue.c **** 			return errQUEUE_FULL;
 919:FreeRTOS/Source/queue.c **** 		}
 920:FreeRTOS/Source/queue.c **** 	}
 921:FreeRTOS/Source/queue.c **** }
 922:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 923:FreeRTOS/Source/queue.c **** 
 924:FreeRTOS/Source/queue.c **** BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseTy
 925:FreeRTOS/Source/queue.c **** {
 926:FreeRTOS/Source/queue.c **** BaseType_t xReturn;
 927:FreeRTOS/Source/queue.c **** UBaseType_t uxSavedInterruptStatus;
 928:FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 929:FreeRTOS/Source/queue.c **** 
 930:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
 931:FreeRTOS/Source/queue.c **** 	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 932:FreeRTOS/Source/queue.c **** 	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 933:FreeRTOS/Source/queue.c **** 
 934:FreeRTOS/Source/queue.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
 935:FreeRTOS/Source/queue.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
 936:FreeRTOS/Source/queue.c **** 	above the maximum system call priority are kept permanently enabled, even
 937:FreeRTOS/Source/queue.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
 938:FreeRTOS/Source/queue.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
 939:FreeRTOS/Source/queue.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
 940:FreeRTOS/Source/queue.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
 941:FreeRTOS/Source/queue.c **** 	assigned a priority above the configured maximum system call priority.
 942:FreeRTOS/Source/queue.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
 943:FreeRTOS/Source/queue.c **** 	that have been assigned a priority at or (logically) below the maximum
 944:FreeRTOS/Source/queue.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
 945:FreeRTOS/Source/queue.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
 946:FreeRTOS/Source/queue.c **** 	More information (albeit Cortex-M specific) is provided on the following
 947:FreeRTOS/Source/queue.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
 948:FreeRTOS/Source/queue.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 949:FreeRTOS/Source/queue.c **** 
 950:FreeRTOS/Source/queue.c **** 	/* Similar to xQueueGenericSend, except without blocking if there is no room
 951:FreeRTOS/Source/queue.c **** 	in the queue.  Also don't directly wake a task that was blocked on a queue
 952:FreeRTOS/Source/queue.c **** 	read, instead return a flag to say whether a context switch is required or
 953:FreeRTOS/Source/queue.c **** 	not (i.e. has a task with a higher priority than us been woken by this
 954:FreeRTOS/Source/queue.c **** 	post). */
 955:FreeRTOS/Source/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 956:FreeRTOS/Source/queue.c **** 	{
 957:FreeRTOS/Source/queue.c **** 		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 958:FreeRTOS/Source/queue.c **** 		{
 959:FreeRTOS/Source/queue.c **** 			const int8_t cTxLock = pxQueue->cTxLock;
 960:FreeRTOS/Source/queue.c **** 
 961:FreeRTOS/Source/queue.c **** 			traceQUEUE_SEND_FROM_ISR( pxQueue );
 962:FreeRTOS/Source/queue.c **** 
 963:FreeRTOS/Source/queue.c **** 			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
 964:FreeRTOS/Source/queue.c **** 			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
 965:FreeRTOS/Source/queue.c **** 			in a task disinheriting a priority and prvCopyDataToQueue() can be
 966:FreeRTOS/Source/queue.c **** 			called here even though the disinherit function does not check if
 967:FreeRTOS/Source/queue.c **** 			the scheduler is suspended before accessing the ready lists. */
 968:FreeRTOS/Source/queue.c **** 			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 969:FreeRTOS/Source/queue.c **** 
 970:FreeRTOS/Source/queue.c **** 			/* The event list is not altered if the queue is locked.  This will
 971:FreeRTOS/Source/queue.c **** 			be done when the queue is unlocked later. */
 972:FreeRTOS/Source/queue.c **** 			if( cTxLock == queueUNLOCKED )
 973:FreeRTOS/Source/queue.c **** 			{
 974:FreeRTOS/Source/queue.c **** 				#if ( configUSE_QUEUE_SETS == 1 )
 975:FreeRTOS/Source/queue.c **** 				{
 976:FreeRTOS/Source/queue.c **** 					if( pxQueue->pxQueueSetContainer != NULL )
 977:FreeRTOS/Source/queue.c **** 					{
 978:FreeRTOS/Source/queue.c **** 						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) != pdFALSE )
 979:FreeRTOS/Source/queue.c **** 						{
 980:FreeRTOS/Source/queue.c **** 							/* The queue is a member of a queue set, and posting
 981:FreeRTOS/Source/queue.c **** 							to the queue set caused a higher priority task to
 982:FreeRTOS/Source/queue.c **** 							unblock.  A context switch is required. */
 983:FreeRTOS/Source/queue.c **** 							if( pxHigherPriorityTaskWoken != NULL )
 984:FreeRTOS/Source/queue.c **** 							{
 985:FreeRTOS/Source/queue.c **** 								*pxHigherPriorityTaskWoken = pdTRUE;
 986:FreeRTOS/Source/queue.c **** 							}
 987:FreeRTOS/Source/queue.c **** 							else
 988:FreeRTOS/Source/queue.c **** 							{
 989:FreeRTOS/Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
 990:FreeRTOS/Source/queue.c **** 							}
 991:FreeRTOS/Source/queue.c **** 						}
 992:FreeRTOS/Source/queue.c **** 						else
 993:FreeRTOS/Source/queue.c **** 						{
 994:FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
 995:FreeRTOS/Source/queue.c **** 						}
 996:FreeRTOS/Source/queue.c **** 					}
 997:FreeRTOS/Source/queue.c **** 					else
 998:FreeRTOS/Source/queue.c **** 					{
 999:FreeRTOS/Source/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1000:FreeRTOS/Source/queue.c **** 						{
1001:FreeRTOS/Source/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1002:FreeRTOS/Source/queue.c **** 							{
1003:FreeRTOS/Source/queue.c **** 								/* The task waiting has a higher priority so
1004:FreeRTOS/Source/queue.c **** 								record that a context switch is required. */
1005:FreeRTOS/Source/queue.c **** 								if( pxHigherPriorityTaskWoken != NULL )
1006:FreeRTOS/Source/queue.c **** 								{
1007:FreeRTOS/Source/queue.c **** 									*pxHigherPriorityTaskWoken = pdTRUE;
1008:FreeRTOS/Source/queue.c **** 								}
1009:FreeRTOS/Source/queue.c **** 								else
1010:FreeRTOS/Source/queue.c **** 								{
1011:FreeRTOS/Source/queue.c **** 									mtCOVERAGE_TEST_MARKER();
1012:FreeRTOS/Source/queue.c **** 								}
1013:FreeRTOS/Source/queue.c **** 							}
1014:FreeRTOS/Source/queue.c **** 							else
1015:FreeRTOS/Source/queue.c **** 							{
1016:FreeRTOS/Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1017:FreeRTOS/Source/queue.c **** 							}
1018:FreeRTOS/Source/queue.c **** 						}
1019:FreeRTOS/Source/queue.c **** 						else
1020:FreeRTOS/Source/queue.c **** 						{
1021:FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1022:FreeRTOS/Source/queue.c **** 						}
1023:FreeRTOS/Source/queue.c **** 					}
1024:FreeRTOS/Source/queue.c **** 				}
1025:FreeRTOS/Source/queue.c **** 				#else /* configUSE_QUEUE_SETS */
1026:FreeRTOS/Source/queue.c **** 				{
1027:FreeRTOS/Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1028:FreeRTOS/Source/queue.c **** 					{
1029:FreeRTOS/Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1030:FreeRTOS/Source/queue.c **** 						{
1031:FreeRTOS/Source/queue.c **** 							/* The task waiting has a higher priority so record that a
1032:FreeRTOS/Source/queue.c **** 							context	switch is required. */
1033:FreeRTOS/Source/queue.c **** 							if( pxHigherPriorityTaskWoken != NULL )
1034:FreeRTOS/Source/queue.c **** 							{
1035:FreeRTOS/Source/queue.c **** 								*pxHigherPriorityTaskWoken = pdTRUE;
1036:FreeRTOS/Source/queue.c **** 							}
1037:FreeRTOS/Source/queue.c **** 							else
1038:FreeRTOS/Source/queue.c **** 							{
1039:FreeRTOS/Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1040:FreeRTOS/Source/queue.c **** 							}
1041:FreeRTOS/Source/queue.c **** 						}
1042:FreeRTOS/Source/queue.c **** 						else
1043:FreeRTOS/Source/queue.c **** 						{
1044:FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1045:FreeRTOS/Source/queue.c **** 						}
1046:FreeRTOS/Source/queue.c **** 					}
1047:FreeRTOS/Source/queue.c **** 					else
1048:FreeRTOS/Source/queue.c **** 					{
1049:FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1050:FreeRTOS/Source/queue.c **** 					}
1051:FreeRTOS/Source/queue.c **** 				}
1052:FreeRTOS/Source/queue.c **** 				#endif /* configUSE_QUEUE_SETS */
1053:FreeRTOS/Source/queue.c **** 			}
1054:FreeRTOS/Source/queue.c **** 			else
1055:FreeRTOS/Source/queue.c **** 			{
1056:FreeRTOS/Source/queue.c **** 				/* Increment the lock count so the task that unlocks the queue
1057:FreeRTOS/Source/queue.c **** 				knows that data was posted while it was locked. */
1058:FreeRTOS/Source/queue.c **** 				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
1059:FreeRTOS/Source/queue.c **** 			}
1060:FreeRTOS/Source/queue.c **** 
1061:FreeRTOS/Source/queue.c **** 			xReturn = pdPASS;
1062:FreeRTOS/Source/queue.c **** 		}
1063:FreeRTOS/Source/queue.c **** 		else
1064:FreeRTOS/Source/queue.c **** 		{
1065:FreeRTOS/Source/queue.c **** 			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
1066:FreeRTOS/Source/queue.c **** 			xReturn = errQUEUE_FULL;
1067:FreeRTOS/Source/queue.c **** 		}
1068:FreeRTOS/Source/queue.c **** 	}
1069:FreeRTOS/Source/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1070:FreeRTOS/Source/queue.c **** 
1071:FreeRTOS/Source/queue.c **** 	return xReturn;
1072:FreeRTOS/Source/queue.c **** }
1073:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1074:FreeRTOS/Source/queue.c **** 
1075:FreeRTOS/Source/queue.c **** BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
1076:FreeRTOS/Source/queue.c **** {
1077:FreeRTOS/Source/queue.c **** BaseType_t xReturn;
1078:FreeRTOS/Source/queue.c **** UBaseType_t uxSavedInterruptStatus;
1079:FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
1080:FreeRTOS/Source/queue.c **** 
1081:FreeRTOS/Source/queue.c **** 	/* Similar to xQueueGenericSendFromISR() but used with semaphores where the
1082:FreeRTOS/Source/queue.c **** 	item size is 0.  Don't directly wake a task that was blocked on a queue
1083:FreeRTOS/Source/queue.c **** 	read, instead return a flag to say whether a context switch is required or
1084:FreeRTOS/Source/queue.c **** 	not (i.e. has a task with a higher priority than us been woken by this
1085:FreeRTOS/Source/queue.c **** 	post). */
1086:FreeRTOS/Source/queue.c **** 
1087:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
1088:FreeRTOS/Source/queue.c **** 
1089:FreeRTOS/Source/queue.c **** 	/* xQueueGenericSendFromISR() should be used instead of xQueueGiveFromISR()
1090:FreeRTOS/Source/queue.c **** 	if the item size is not 0. */
1091:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue->uxItemSize == 0 );
1092:FreeRTOS/Source/queue.c **** 
1093:FreeRTOS/Source/queue.c **** 	/* Normally a mutex would not be given from an interrupt, especially if
1094:FreeRTOS/Source/queue.c **** 	there is a mutex holder, as priority inheritance makes no sense for an
1095:FreeRTOS/Source/queue.c **** 	interrupts, only tasks. */
1096:FreeRTOS/Source/queue.c **** 	configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->pxMutexHolder != NU
1097:FreeRTOS/Source/queue.c **** 
1098:FreeRTOS/Source/queue.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
1099:FreeRTOS/Source/queue.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
1100:FreeRTOS/Source/queue.c **** 	above the maximum system call priority are kept permanently enabled, even
1101:FreeRTOS/Source/queue.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
1102:FreeRTOS/Source/queue.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1103:FreeRTOS/Source/queue.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1104:FreeRTOS/Source/queue.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
1105:FreeRTOS/Source/queue.c **** 	assigned a priority above the configured maximum system call priority.
1106:FreeRTOS/Source/queue.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
1107:FreeRTOS/Source/queue.c **** 	that have been assigned a priority at or (logically) below the maximum
1108:FreeRTOS/Source/queue.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1109:FreeRTOS/Source/queue.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
1110:FreeRTOS/Source/queue.c **** 	More information (albeit Cortex-M specific) is provided on the following
1111:FreeRTOS/Source/queue.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1112:FreeRTOS/Source/queue.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1113:FreeRTOS/Source/queue.c **** 
1114:FreeRTOS/Source/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
1115:FreeRTOS/Source/queue.c **** 	{
1116:FreeRTOS/Source/queue.c **** 		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
1117:FreeRTOS/Source/queue.c **** 
1118:FreeRTOS/Source/queue.c **** 		/* When the queue is used to implement a semaphore no data is ever
1119:FreeRTOS/Source/queue.c **** 		moved through the queue but it is still valid to see if the queue 'has
1120:FreeRTOS/Source/queue.c **** 		space'. */
1121:FreeRTOS/Source/queue.c **** 		if( uxMessagesWaiting < pxQueue->uxLength )
1122:FreeRTOS/Source/queue.c **** 		{
1123:FreeRTOS/Source/queue.c **** 			const int8_t cTxLock = pxQueue->cTxLock;
1124:FreeRTOS/Source/queue.c **** 
1125:FreeRTOS/Source/queue.c **** 			traceQUEUE_SEND_FROM_ISR( pxQueue );
1126:FreeRTOS/Source/queue.c **** 
1127:FreeRTOS/Source/queue.c **** 			/* A task can only have an inherited priority if it is a mutex
1128:FreeRTOS/Source/queue.c **** 			holder - and if there is a mutex holder then the mutex cannot be
1129:FreeRTOS/Source/queue.c **** 			given from an ISR.  As this is the ISR version of the function it
1130:FreeRTOS/Source/queue.c **** 			can be assumed there is no mutex holder and no need to determine if
1131:FreeRTOS/Source/queue.c **** 			priority disinheritance is needed.  Simply increase the count of
1132:FreeRTOS/Source/queue.c **** 			messages (semaphores) available. */
1133:FreeRTOS/Source/queue.c **** 			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
1134:FreeRTOS/Source/queue.c **** 
1135:FreeRTOS/Source/queue.c **** 			/* The event list is not altered if the queue is locked.  This will
1136:FreeRTOS/Source/queue.c **** 			be done when the queue is unlocked later. */
1137:FreeRTOS/Source/queue.c **** 			if( cTxLock == queueUNLOCKED )
1138:FreeRTOS/Source/queue.c **** 			{
1139:FreeRTOS/Source/queue.c **** 				#if ( configUSE_QUEUE_SETS == 1 )
1140:FreeRTOS/Source/queue.c **** 				{
1141:FreeRTOS/Source/queue.c **** 					if( pxQueue->pxQueueSetContainer != NULL )
1142:FreeRTOS/Source/queue.c **** 					{
1143:FreeRTOS/Source/queue.c **** 						if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) != pdFALSE )
1144:FreeRTOS/Source/queue.c **** 						{
1145:FreeRTOS/Source/queue.c **** 							/* The semaphore is a member of a queue set, and
1146:FreeRTOS/Source/queue.c **** 							posting	to the queue set caused a higher priority
1147:FreeRTOS/Source/queue.c **** 							task to	unblock.  A context switch is required. */
1148:FreeRTOS/Source/queue.c **** 							if( pxHigherPriorityTaskWoken != NULL )
1149:FreeRTOS/Source/queue.c **** 							{
1150:FreeRTOS/Source/queue.c **** 								*pxHigherPriorityTaskWoken = pdTRUE;
1151:FreeRTOS/Source/queue.c **** 							}
1152:FreeRTOS/Source/queue.c **** 							else
1153:FreeRTOS/Source/queue.c **** 							{
1154:FreeRTOS/Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1155:FreeRTOS/Source/queue.c **** 							}
1156:FreeRTOS/Source/queue.c **** 						}
1157:FreeRTOS/Source/queue.c **** 						else
1158:FreeRTOS/Source/queue.c **** 						{
1159:FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1160:FreeRTOS/Source/queue.c **** 						}
1161:FreeRTOS/Source/queue.c **** 					}
1162:FreeRTOS/Source/queue.c **** 					else
1163:FreeRTOS/Source/queue.c **** 					{
1164:FreeRTOS/Source/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1165:FreeRTOS/Source/queue.c **** 						{
1166:FreeRTOS/Source/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1167:FreeRTOS/Source/queue.c **** 							{
1168:FreeRTOS/Source/queue.c **** 								/* The task waiting has a higher priority so
1169:FreeRTOS/Source/queue.c **** 								record that a context switch is required. */
1170:FreeRTOS/Source/queue.c **** 								if( pxHigherPriorityTaskWoken != NULL )
1171:FreeRTOS/Source/queue.c **** 								{
1172:FreeRTOS/Source/queue.c **** 									*pxHigherPriorityTaskWoken = pdTRUE;
1173:FreeRTOS/Source/queue.c **** 								}
1174:FreeRTOS/Source/queue.c **** 								else
1175:FreeRTOS/Source/queue.c **** 								{
1176:FreeRTOS/Source/queue.c **** 									mtCOVERAGE_TEST_MARKER();
1177:FreeRTOS/Source/queue.c **** 								}
1178:FreeRTOS/Source/queue.c **** 							}
1179:FreeRTOS/Source/queue.c **** 							else
1180:FreeRTOS/Source/queue.c **** 							{
1181:FreeRTOS/Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1182:FreeRTOS/Source/queue.c **** 							}
1183:FreeRTOS/Source/queue.c **** 						}
1184:FreeRTOS/Source/queue.c **** 						else
1185:FreeRTOS/Source/queue.c **** 						{
1186:FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1187:FreeRTOS/Source/queue.c **** 						}
1188:FreeRTOS/Source/queue.c **** 					}
1189:FreeRTOS/Source/queue.c **** 				}
1190:FreeRTOS/Source/queue.c **** 				#else /* configUSE_QUEUE_SETS */
1191:FreeRTOS/Source/queue.c **** 				{
1192:FreeRTOS/Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1193:FreeRTOS/Source/queue.c **** 					{
1194:FreeRTOS/Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1195:FreeRTOS/Source/queue.c **** 						{
1196:FreeRTOS/Source/queue.c **** 							/* The task waiting has a higher priority so record that a
1197:FreeRTOS/Source/queue.c **** 							context	switch is required. */
1198:FreeRTOS/Source/queue.c **** 							if( pxHigherPriorityTaskWoken != NULL )
1199:FreeRTOS/Source/queue.c **** 							{
1200:FreeRTOS/Source/queue.c **** 								*pxHigherPriorityTaskWoken = pdTRUE;
1201:FreeRTOS/Source/queue.c **** 							}
1202:FreeRTOS/Source/queue.c **** 							else
1203:FreeRTOS/Source/queue.c **** 							{
1204:FreeRTOS/Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1205:FreeRTOS/Source/queue.c **** 							}
1206:FreeRTOS/Source/queue.c **** 						}
1207:FreeRTOS/Source/queue.c **** 						else
1208:FreeRTOS/Source/queue.c **** 						{
1209:FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1210:FreeRTOS/Source/queue.c **** 						}
1211:FreeRTOS/Source/queue.c **** 					}
1212:FreeRTOS/Source/queue.c **** 					else
1213:FreeRTOS/Source/queue.c **** 					{
1214:FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1215:FreeRTOS/Source/queue.c **** 					}
1216:FreeRTOS/Source/queue.c **** 				}
1217:FreeRTOS/Source/queue.c **** 				#endif /* configUSE_QUEUE_SETS */
1218:FreeRTOS/Source/queue.c **** 			}
1219:FreeRTOS/Source/queue.c **** 			else
1220:FreeRTOS/Source/queue.c **** 			{
1221:FreeRTOS/Source/queue.c **** 				/* Increment the lock count so the task that unlocks the queue
1222:FreeRTOS/Source/queue.c **** 				knows that data was posted while it was locked. */
1223:FreeRTOS/Source/queue.c **** 				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
1224:FreeRTOS/Source/queue.c **** 			}
1225:FreeRTOS/Source/queue.c **** 
1226:FreeRTOS/Source/queue.c **** 			xReturn = pdPASS;
1227:FreeRTOS/Source/queue.c **** 		}
1228:FreeRTOS/Source/queue.c **** 		else
1229:FreeRTOS/Source/queue.c **** 		{
1230:FreeRTOS/Source/queue.c **** 			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
1231:FreeRTOS/Source/queue.c **** 			xReturn = errQUEUE_FULL;
1232:FreeRTOS/Source/queue.c **** 		}
1233:FreeRTOS/Source/queue.c **** 	}
1234:FreeRTOS/Source/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1235:FreeRTOS/Source/queue.c **** 
1236:FreeRTOS/Source/queue.c **** 	return xReturn;
1237:FreeRTOS/Source/queue.c **** }
1238:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1239:FreeRTOS/Source/queue.c **** 
1240:FreeRTOS/Source/queue.c **** BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
1241:FreeRTOS/Source/queue.c **** {
1242:FreeRTOS/Source/queue.c **** BaseType_t xEntryTimeSet = pdFALSE;
1243:FreeRTOS/Source/queue.c **** TimeOut_t xTimeOut;
1244:FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
1245:FreeRTOS/Source/queue.c **** 
1246:FreeRTOS/Source/queue.c **** 	/* Check the pointer is not NULL. */
1247:FreeRTOS/Source/queue.c **** 	configASSERT( ( pxQueue ) );
1248:FreeRTOS/Source/queue.c **** 
1249:FreeRTOS/Source/queue.c **** 	/* The buffer into which data is received can only be NULL if the data size
1250:FreeRTOS/Source/queue.c **** 	is zero (so no data is copied into the buffer. */
1251:FreeRTOS/Source/queue.c **** 	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) )
1252:FreeRTOS/Source/queue.c **** 
1253:FreeRTOS/Source/queue.c **** 	/* Cannot block if the scheduler is suspended. */
1254:FreeRTOS/Source/queue.c **** 	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
1255:FreeRTOS/Source/queue.c **** 	{
1256:FreeRTOS/Source/queue.c **** 		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 )
1257:FreeRTOS/Source/queue.c **** 	}
1258:FreeRTOS/Source/queue.c **** 	#endif
1259:FreeRTOS/Source/queue.c **** 
1260:FreeRTOS/Source/queue.c **** 
1261:FreeRTOS/Source/queue.c **** 	/* This function relaxes the coding standard somewhat to allow return
1262:FreeRTOS/Source/queue.c **** 	statements within the function itself.  This is done in the interest
1263:FreeRTOS/Source/queue.c **** 	of execution time efficiency. */
1264:FreeRTOS/Source/queue.c **** 
1265:FreeRTOS/Source/queue.c **** 	for( ;; )
1266:FreeRTOS/Source/queue.c **** 	{
1267:FreeRTOS/Source/queue.c **** 		taskENTER_CRITICAL();
1268:FreeRTOS/Source/queue.c **** 		{
1269:FreeRTOS/Source/queue.c **** 			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
1270:FreeRTOS/Source/queue.c **** 
1271:FreeRTOS/Source/queue.c **** 			/* Is there data in the queue now?  To be running the calling task
1272:FreeRTOS/Source/queue.c **** 			must be the highest priority task wanting to access the queue. */
1273:FreeRTOS/Source/queue.c **** 			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
1274:FreeRTOS/Source/queue.c **** 			{
1275:FreeRTOS/Source/queue.c **** 				/* Data available, remove one item. */
1276:FreeRTOS/Source/queue.c **** 				prvCopyDataFromQueue( pxQueue, pvBuffer );
1277:FreeRTOS/Source/queue.c **** 				traceQUEUE_RECEIVE( pxQueue );
1278:FreeRTOS/Source/queue.c **** 				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
1279:FreeRTOS/Source/queue.c **** 
1280:FreeRTOS/Source/queue.c **** 				/* There is now space in the queue, were any tasks waiting to
1281:FreeRTOS/Source/queue.c **** 				post to the queue?  If so, unblock the highest priority waiting
1282:FreeRTOS/Source/queue.c **** 				task. */
1283:FreeRTOS/Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
1284:FreeRTOS/Source/queue.c **** 				{
1285:FreeRTOS/Source/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
1286:FreeRTOS/Source/queue.c **** 					{
1287:FreeRTOS/Source/queue.c **** 						queueYIELD_IF_USING_PREEMPTION();
1288:FreeRTOS/Source/queue.c **** 					}
1289:FreeRTOS/Source/queue.c **** 					else
1290:FreeRTOS/Source/queue.c **** 					{
1291:FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1292:FreeRTOS/Source/queue.c **** 					}
1293:FreeRTOS/Source/queue.c **** 				}
1294:FreeRTOS/Source/queue.c **** 				else
1295:FreeRTOS/Source/queue.c **** 				{
1296:FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1297:FreeRTOS/Source/queue.c **** 				}
1298:FreeRTOS/Source/queue.c **** 
1299:FreeRTOS/Source/queue.c **** 				taskEXIT_CRITICAL();
1300:FreeRTOS/Source/queue.c **** 				return pdPASS;
1301:FreeRTOS/Source/queue.c **** 			}
1302:FreeRTOS/Source/queue.c **** 			else
1303:FreeRTOS/Source/queue.c **** 			{
1304:FreeRTOS/Source/queue.c **** 				if( xTicksToWait == ( TickType_t ) 0 )
1305:FreeRTOS/Source/queue.c **** 				{
1306:FreeRTOS/Source/queue.c **** 					/* The queue was empty and no block time is specified (or
1307:FreeRTOS/Source/queue.c **** 					the block time has expired) so leave now. */
1308:FreeRTOS/Source/queue.c **** 					taskEXIT_CRITICAL();
1309:FreeRTOS/Source/queue.c **** 					traceQUEUE_RECEIVE_FAILED( pxQueue );
1310:FreeRTOS/Source/queue.c **** 					return errQUEUE_EMPTY;
1311:FreeRTOS/Source/queue.c **** 				}
1312:FreeRTOS/Source/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
1313:FreeRTOS/Source/queue.c **** 				{
1314:FreeRTOS/Source/queue.c **** 					/* The queue was empty and a block time was specified so
1315:FreeRTOS/Source/queue.c **** 					configure the timeout structure. */
1316:FreeRTOS/Source/queue.c **** 					vTaskInternalSetTimeOutState( &xTimeOut );
1317:FreeRTOS/Source/queue.c **** 					xEntryTimeSet = pdTRUE;
1318:FreeRTOS/Source/queue.c **** 				}
1319:FreeRTOS/Source/queue.c **** 				else
1320:FreeRTOS/Source/queue.c **** 				{
1321:FreeRTOS/Source/queue.c **** 					/* Entry time was already set. */
1322:FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1323:FreeRTOS/Source/queue.c **** 				}
1324:FreeRTOS/Source/queue.c **** 			}
1325:FreeRTOS/Source/queue.c **** 		}
1326:FreeRTOS/Source/queue.c **** 		taskEXIT_CRITICAL();
1327:FreeRTOS/Source/queue.c **** 
1328:FreeRTOS/Source/queue.c **** 		/* Interrupts and other tasks can send to and receive from the queue
1329:FreeRTOS/Source/queue.c **** 		now the critical section has been exited. */
1330:FreeRTOS/Source/queue.c **** 
1331:FreeRTOS/Source/queue.c **** 		vTaskSuspendAll();
1332:FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
1333:FreeRTOS/Source/queue.c **** 
1334:FreeRTOS/Source/queue.c **** 		/* Update the timeout state to see if it has expired yet. */
1335:FreeRTOS/Source/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
1336:FreeRTOS/Source/queue.c **** 		{
1337:FreeRTOS/Source/queue.c **** 			/* The timeout has not expired.  If the queue is still empty place
1338:FreeRTOS/Source/queue.c **** 			the task on the list of tasks waiting to receive from the queue. */
1339:FreeRTOS/Source/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
1340:FreeRTOS/Source/queue.c **** 			{
1341:FreeRTOS/Source/queue.c **** 				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
1342:FreeRTOS/Source/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
1343:FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
1344:FreeRTOS/Source/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
1345:FreeRTOS/Source/queue.c **** 				{
1346:FreeRTOS/Source/queue.c **** 					portYIELD_WITHIN_API();
1347:FreeRTOS/Source/queue.c **** 				}
1348:FreeRTOS/Source/queue.c **** 				else
1349:FreeRTOS/Source/queue.c **** 				{
1350:FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1351:FreeRTOS/Source/queue.c **** 				}
1352:FreeRTOS/Source/queue.c **** 			}
1353:FreeRTOS/Source/queue.c **** 			else
1354:FreeRTOS/Source/queue.c **** 			{
1355:FreeRTOS/Source/queue.c **** 				/* The queue contains data again.  Loop back to try and read the
1356:FreeRTOS/Source/queue.c **** 				data. */
1357:FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
1358:FreeRTOS/Source/queue.c **** 				( void ) xTaskResumeAll();
1359:FreeRTOS/Source/queue.c **** 			}
1360:FreeRTOS/Source/queue.c **** 		}
1361:FreeRTOS/Source/queue.c **** 		else
1362:FreeRTOS/Source/queue.c **** 		{
1363:FreeRTOS/Source/queue.c **** 			/* Timed out.  If there is no data in the queue exit, otherwise loop
1364:FreeRTOS/Source/queue.c **** 			back and attempt to read the data. */
1365:FreeRTOS/Source/queue.c **** 			prvUnlockQueue( pxQueue );
1366:FreeRTOS/Source/queue.c **** 			( void ) xTaskResumeAll();
1367:FreeRTOS/Source/queue.c **** 
1368:FreeRTOS/Source/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
1369:FreeRTOS/Source/queue.c **** 			{
1370:FreeRTOS/Source/queue.c **** 				traceQUEUE_RECEIVE_FAILED( pxQueue );
1371:FreeRTOS/Source/queue.c **** 				return errQUEUE_EMPTY;
1372:FreeRTOS/Source/queue.c **** 			}
1373:FreeRTOS/Source/queue.c **** 			else
1374:FreeRTOS/Source/queue.c **** 			{
1375:FreeRTOS/Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
1376:FreeRTOS/Source/queue.c **** 			}
1377:FreeRTOS/Source/queue.c **** 		}
1378:FreeRTOS/Source/queue.c **** 	}
1379:FreeRTOS/Source/queue.c **** }
1380:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1381:FreeRTOS/Source/queue.c **** 
1382:FreeRTOS/Source/queue.c **** BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
1383:FreeRTOS/Source/queue.c **** {
1384:FreeRTOS/Source/queue.c **** BaseType_t xEntryTimeSet = pdFALSE;
1385:FreeRTOS/Source/queue.c **** TimeOut_t xTimeOut;
1386:FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
1387:FreeRTOS/Source/queue.c **** 
1388:FreeRTOS/Source/queue.c **** #if( configUSE_MUTEXES == 1 )
1389:FreeRTOS/Source/queue.c **** 	BaseType_t xInheritanceOccurred = pdFALSE;
1390:FreeRTOS/Source/queue.c **** #endif
1391:FreeRTOS/Source/queue.c **** 
1392:FreeRTOS/Source/queue.c **** 	/* Check the queue pointer is not NULL. */
1393:FreeRTOS/Source/queue.c **** 	configASSERT( ( pxQueue ) );
1394:FreeRTOS/Source/queue.c **** 
1395:FreeRTOS/Source/queue.c **** 	/* Check this really is a semaphore, in which case the item size will be
1396:FreeRTOS/Source/queue.c **** 	0. */
1397:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue->uxItemSize == 0 );
1398:FreeRTOS/Source/queue.c **** 
1399:FreeRTOS/Source/queue.c **** 	/* Cannot block if the scheduler is suspended. */
1400:FreeRTOS/Source/queue.c **** 	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
1401:FreeRTOS/Source/queue.c **** 	{
1402:FreeRTOS/Source/queue.c **** 		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 )
1403:FreeRTOS/Source/queue.c **** 	}
1404:FreeRTOS/Source/queue.c **** 	#endif
1405:FreeRTOS/Source/queue.c **** 
1406:FreeRTOS/Source/queue.c **** 
1407:FreeRTOS/Source/queue.c **** 	/* This function relaxes the coding standard somewhat to allow return
1408:FreeRTOS/Source/queue.c **** 	statements within the function itself.  This is done in the interest
1409:FreeRTOS/Source/queue.c **** 	of execution time efficiency. */
1410:FreeRTOS/Source/queue.c **** 
1411:FreeRTOS/Source/queue.c **** 	for( ;; )
1412:FreeRTOS/Source/queue.c **** 	{
1413:FreeRTOS/Source/queue.c **** 		taskENTER_CRITICAL();
1414:FreeRTOS/Source/queue.c **** 		{
1415:FreeRTOS/Source/queue.c **** 			/* Semaphores are queues with an item size of 0, and where the
1416:FreeRTOS/Source/queue.c **** 			number of messages in the queue is the semaphore's count value. */
1417:FreeRTOS/Source/queue.c **** 			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
1418:FreeRTOS/Source/queue.c **** 
1419:FreeRTOS/Source/queue.c **** 			/* Is there data in the queue now?  To be running the calling task
1420:FreeRTOS/Source/queue.c **** 			must be the highest priority task wanting to access the queue. */
1421:FreeRTOS/Source/queue.c **** 			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
1422:FreeRTOS/Source/queue.c **** 			{
1423:FreeRTOS/Source/queue.c **** 				traceQUEUE_RECEIVE( pxQueue );
1424:FreeRTOS/Source/queue.c **** 
1425:FreeRTOS/Source/queue.c **** 				/* Semaphores are queues with a data size of zero and where the
1426:FreeRTOS/Source/queue.c **** 				messages waiting is the semaphore's count.  Reduce the count. */
1427:FreeRTOS/Source/queue.c **** 				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
1428:FreeRTOS/Source/queue.c **** 
1429:FreeRTOS/Source/queue.c **** 				#if ( configUSE_MUTEXES == 1 )
1430:FreeRTOS/Source/queue.c **** 				{
1431:FreeRTOS/Source/queue.c **** 					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
1432:FreeRTOS/Source/queue.c **** 					{
1433:FreeRTOS/Source/queue.c **** 						/* Record the information required to implement
1434:FreeRTOS/Source/queue.c **** 						priority inheritance should it become necessary. */
1435:FreeRTOS/Source/queue.c **** 						pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is n
1436:FreeRTOS/Source/queue.c **** 					}
1437:FreeRTOS/Source/queue.c **** 					else
1438:FreeRTOS/Source/queue.c **** 					{
1439:FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1440:FreeRTOS/Source/queue.c **** 					}
1441:FreeRTOS/Source/queue.c **** 				}
1442:FreeRTOS/Source/queue.c **** 				#endif /* configUSE_MUTEXES */
1443:FreeRTOS/Source/queue.c **** 
1444:FreeRTOS/Source/queue.c **** 				/* Check to see if other tasks are blocked waiting to give the
1445:FreeRTOS/Source/queue.c **** 				semaphore, and if so, unblock the highest priority such task. */
1446:FreeRTOS/Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
1447:FreeRTOS/Source/queue.c **** 				{
1448:FreeRTOS/Source/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
1449:FreeRTOS/Source/queue.c **** 					{
1450:FreeRTOS/Source/queue.c **** 						queueYIELD_IF_USING_PREEMPTION();
1451:FreeRTOS/Source/queue.c **** 					}
1452:FreeRTOS/Source/queue.c **** 					else
1453:FreeRTOS/Source/queue.c **** 					{
1454:FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1455:FreeRTOS/Source/queue.c **** 					}
1456:FreeRTOS/Source/queue.c **** 				}
1457:FreeRTOS/Source/queue.c **** 				else
1458:FreeRTOS/Source/queue.c **** 				{
1459:FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1460:FreeRTOS/Source/queue.c **** 				}
1461:FreeRTOS/Source/queue.c **** 
1462:FreeRTOS/Source/queue.c **** 				taskEXIT_CRITICAL();
1463:FreeRTOS/Source/queue.c **** 				return pdPASS;
1464:FreeRTOS/Source/queue.c **** 			}
1465:FreeRTOS/Source/queue.c **** 			else
1466:FreeRTOS/Source/queue.c **** 			{
1467:FreeRTOS/Source/queue.c **** 				if( xTicksToWait == ( TickType_t ) 0 )
1468:FreeRTOS/Source/queue.c **** 				{
1469:FreeRTOS/Source/queue.c **** 					/* For inheritance to have occurred there must have been an
1470:FreeRTOS/Source/queue.c **** 					initial timeout, and an adjusted timeout cannot become 0, as
1471:FreeRTOS/Source/queue.c **** 					if it were 0 the function would have exited. */
1472:FreeRTOS/Source/queue.c **** 					#if( configUSE_MUTEXES == 1 )
1473:FreeRTOS/Source/queue.c **** 					{
1474:FreeRTOS/Source/queue.c **** 						configASSERT( xInheritanceOccurred == pdFALSE );
1475:FreeRTOS/Source/queue.c **** 					}
1476:FreeRTOS/Source/queue.c **** 					#endif /* configUSE_MUTEXES */
1477:FreeRTOS/Source/queue.c **** 
1478:FreeRTOS/Source/queue.c **** 					/* The semaphore count was 0 and no block time is specified
1479:FreeRTOS/Source/queue.c **** 					(or the block time has expired) so exit now. */
1480:FreeRTOS/Source/queue.c **** 					taskEXIT_CRITICAL();
1481:FreeRTOS/Source/queue.c **** 					traceQUEUE_RECEIVE_FAILED( pxQueue );
1482:FreeRTOS/Source/queue.c **** 					return errQUEUE_EMPTY;
1483:FreeRTOS/Source/queue.c **** 				}
1484:FreeRTOS/Source/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
1485:FreeRTOS/Source/queue.c **** 				{
1486:FreeRTOS/Source/queue.c **** 					/* The semaphore count was 0 and a block time was specified
1487:FreeRTOS/Source/queue.c **** 					so configure the timeout structure ready to block. */
1488:FreeRTOS/Source/queue.c **** 					vTaskInternalSetTimeOutState( &xTimeOut );
1489:FreeRTOS/Source/queue.c **** 					xEntryTimeSet = pdTRUE;
1490:FreeRTOS/Source/queue.c **** 				}
1491:FreeRTOS/Source/queue.c **** 				else
1492:FreeRTOS/Source/queue.c **** 				{
1493:FreeRTOS/Source/queue.c **** 					/* Entry time was already set. */
1494:FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1495:FreeRTOS/Source/queue.c **** 				}
1496:FreeRTOS/Source/queue.c **** 			}
1497:FreeRTOS/Source/queue.c **** 		}
1498:FreeRTOS/Source/queue.c **** 		taskEXIT_CRITICAL();
1499:FreeRTOS/Source/queue.c **** 
1500:FreeRTOS/Source/queue.c **** 		/* Interrupts and other tasks can give to and take from the semaphore
1501:FreeRTOS/Source/queue.c **** 		now the critical section has been exited. */
1502:FreeRTOS/Source/queue.c **** 
1503:FreeRTOS/Source/queue.c **** 		vTaskSuspendAll();
1504:FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
1505:FreeRTOS/Source/queue.c **** 
1506:FreeRTOS/Source/queue.c **** 		/* Update the timeout state to see if it has expired yet. */
1507:FreeRTOS/Source/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
1508:FreeRTOS/Source/queue.c **** 		{
1509:FreeRTOS/Source/queue.c **** 			/* A block time is specified and not expired.  If the semaphore
1510:FreeRTOS/Source/queue.c **** 			count is 0 then enter the Blocked state to wait for a semaphore to
1511:FreeRTOS/Source/queue.c **** 			become available.  As semaphores are implemented with queues the
1512:FreeRTOS/Source/queue.c **** 			queue being empty is equivalent to the semaphore count being 0. */
1513:FreeRTOS/Source/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
1514:FreeRTOS/Source/queue.c **** 			{
1515:FreeRTOS/Source/queue.c **** 				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
1516:FreeRTOS/Source/queue.c **** 
1517:FreeRTOS/Source/queue.c **** 				#if ( configUSE_MUTEXES == 1 )
1518:FreeRTOS/Source/queue.c **** 				{
1519:FreeRTOS/Source/queue.c **** 					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
1520:FreeRTOS/Source/queue.c **** 					{
1521:FreeRTOS/Source/queue.c **** 						taskENTER_CRITICAL();
1522:FreeRTOS/Source/queue.c **** 						{
1523:FreeRTOS/Source/queue.c **** 							xInheritanceOccurred = xTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
1524:FreeRTOS/Source/queue.c **** 						}
1525:FreeRTOS/Source/queue.c **** 						taskEXIT_CRITICAL();
1526:FreeRTOS/Source/queue.c **** 					}
1527:FreeRTOS/Source/queue.c **** 					else
1528:FreeRTOS/Source/queue.c **** 					{
1529:FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1530:FreeRTOS/Source/queue.c **** 					}
1531:FreeRTOS/Source/queue.c **** 				}
1532:FreeRTOS/Source/queue.c **** 				#endif
1533:FreeRTOS/Source/queue.c **** 
1534:FreeRTOS/Source/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
1535:FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
1536:FreeRTOS/Source/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
1537:FreeRTOS/Source/queue.c **** 				{
1538:FreeRTOS/Source/queue.c **** 					portYIELD_WITHIN_API();
1539:FreeRTOS/Source/queue.c **** 				}
1540:FreeRTOS/Source/queue.c **** 				else
1541:FreeRTOS/Source/queue.c **** 				{
1542:FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1543:FreeRTOS/Source/queue.c **** 				}
1544:FreeRTOS/Source/queue.c **** 			}
1545:FreeRTOS/Source/queue.c **** 			else
1546:FreeRTOS/Source/queue.c **** 			{
1547:FreeRTOS/Source/queue.c **** 				/* There was no timeout and the semaphore count was not 0, so
1548:FreeRTOS/Source/queue.c **** 				attempt to take the semaphore again. */
1549:FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
1550:FreeRTOS/Source/queue.c **** 				( void ) xTaskResumeAll();
1551:FreeRTOS/Source/queue.c **** 			}
1552:FreeRTOS/Source/queue.c **** 		}
1553:FreeRTOS/Source/queue.c **** 		else
1554:FreeRTOS/Source/queue.c **** 		{
1555:FreeRTOS/Source/queue.c **** 			/* Timed out. */
1556:FreeRTOS/Source/queue.c **** 			prvUnlockQueue( pxQueue );
1557:FreeRTOS/Source/queue.c **** 			( void ) xTaskResumeAll();
1558:FreeRTOS/Source/queue.c **** 
1559:FreeRTOS/Source/queue.c **** 			/* If the semaphore count is 0 exit now as the timeout has
1560:FreeRTOS/Source/queue.c **** 			expired.  Otherwise return to attempt to take the semaphore that is
1561:FreeRTOS/Source/queue.c **** 			known to be available.  As semaphores are implemented by queues the
1562:FreeRTOS/Source/queue.c **** 			queue being empty is equivalent to the semaphore count being 0. */
1563:FreeRTOS/Source/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
1564:FreeRTOS/Source/queue.c **** 			{
1565:FreeRTOS/Source/queue.c **** 				#if ( configUSE_MUTEXES == 1 )
1566:FreeRTOS/Source/queue.c **** 				{
1567:FreeRTOS/Source/queue.c **** 					/* xInheritanceOccurred could only have be set if
1568:FreeRTOS/Source/queue.c **** 					pxQueue->uxQueueType == queueQUEUE_IS_MUTEX so no need to
1569:FreeRTOS/Source/queue.c **** 					test the mutex type again to check it is actually a mutex. */
1570:FreeRTOS/Source/queue.c **** 					if( xInheritanceOccurred != pdFALSE )
1571:FreeRTOS/Source/queue.c **** 					{
1572:FreeRTOS/Source/queue.c **** 						taskENTER_CRITICAL();
1573:FreeRTOS/Source/queue.c **** 						{
1574:FreeRTOS/Source/queue.c **** 							UBaseType_t uxHighestWaitingPriority;
1575:FreeRTOS/Source/queue.c **** 
1576:FreeRTOS/Source/queue.c **** 							/* This task blocking on the mutex caused another
1577:FreeRTOS/Source/queue.c **** 							task to inherit this task's priority.  Now this task
1578:FreeRTOS/Source/queue.c **** 							has timed out the priority should be disinherited
1579:FreeRTOS/Source/queue.c **** 							again, but only as low as the next highest priority
1580:FreeRTOS/Source/queue.c **** 							task that is waiting for the same mutex. */
1581:FreeRTOS/Source/queue.c **** 							uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );
1582:FreeRTOS/Source/queue.c **** 							vTaskPriorityDisinheritAfterTimeout( ( void * ) pxQueue->pxMutexHolder, uxHighestWaitingPrio
1583:FreeRTOS/Source/queue.c **** 						}
1584:FreeRTOS/Source/queue.c **** 						taskEXIT_CRITICAL();
1585:FreeRTOS/Source/queue.c **** 					}
1586:FreeRTOS/Source/queue.c **** 				}
1587:FreeRTOS/Source/queue.c **** 				#endif /* configUSE_MUTEXES */
1588:FreeRTOS/Source/queue.c **** 
1589:FreeRTOS/Source/queue.c **** 				traceQUEUE_RECEIVE_FAILED( pxQueue );
1590:FreeRTOS/Source/queue.c **** 				return errQUEUE_EMPTY;
1591:FreeRTOS/Source/queue.c **** 			}
1592:FreeRTOS/Source/queue.c **** 			else
1593:FreeRTOS/Source/queue.c **** 			{
1594:FreeRTOS/Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
1595:FreeRTOS/Source/queue.c **** 			}
1596:FreeRTOS/Source/queue.c **** 		}
1597:FreeRTOS/Source/queue.c **** 	}
1598:FreeRTOS/Source/queue.c **** }
1599:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1600:FreeRTOS/Source/queue.c **** 
1601:FreeRTOS/Source/queue.c **** BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
1602:FreeRTOS/Source/queue.c **** {
1603:FreeRTOS/Source/queue.c **** BaseType_t xEntryTimeSet = pdFALSE;
1604:FreeRTOS/Source/queue.c **** TimeOut_t xTimeOut;
1605:FreeRTOS/Source/queue.c **** int8_t *pcOriginalReadPosition;
1606:FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
1607:FreeRTOS/Source/queue.c **** 
1608:FreeRTOS/Source/queue.c **** 	/* Check the pointer is not NULL. */
1609:FreeRTOS/Source/queue.c **** 	configASSERT( ( pxQueue ) );
1610:FreeRTOS/Source/queue.c **** 
1611:FreeRTOS/Source/queue.c **** 	/* The buffer into which data is received can only be NULL if the data size
1612:FreeRTOS/Source/queue.c **** 	is zero (so no data is copied into the buffer. */
1613:FreeRTOS/Source/queue.c **** 	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) )
1614:FreeRTOS/Source/queue.c **** 
1615:FreeRTOS/Source/queue.c **** 	/* Cannot block if the scheduler is suspended. */
1616:FreeRTOS/Source/queue.c **** 	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
1617:FreeRTOS/Source/queue.c **** 	{
1618:FreeRTOS/Source/queue.c **** 		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 )
1619:FreeRTOS/Source/queue.c **** 	}
1620:FreeRTOS/Source/queue.c **** 	#endif
1621:FreeRTOS/Source/queue.c **** 
1622:FreeRTOS/Source/queue.c **** 
1623:FreeRTOS/Source/queue.c **** 	/* This function relaxes the coding standard somewhat to allow return
1624:FreeRTOS/Source/queue.c **** 	statements within the function itself.  This is done in the interest
1625:FreeRTOS/Source/queue.c **** 	of execution time efficiency. */
1626:FreeRTOS/Source/queue.c **** 
1627:FreeRTOS/Source/queue.c **** 	for( ;; )
1628:FreeRTOS/Source/queue.c **** 	{
1629:FreeRTOS/Source/queue.c **** 		taskENTER_CRITICAL();
1630:FreeRTOS/Source/queue.c **** 		{
1631:FreeRTOS/Source/queue.c **** 			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
1632:FreeRTOS/Source/queue.c **** 
1633:FreeRTOS/Source/queue.c **** 			/* Is there data in the queue now?  To be running the calling task
1634:FreeRTOS/Source/queue.c **** 			must be the highest priority task wanting to access the queue. */
1635:FreeRTOS/Source/queue.c **** 			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
1636:FreeRTOS/Source/queue.c **** 			{
1637:FreeRTOS/Source/queue.c **** 				/* Remember the read position so it can be reset after the data
1638:FreeRTOS/Source/queue.c **** 				is read from the queue as this function is only peeking the
1639:FreeRTOS/Source/queue.c **** 				data, not removing it. */
1640:FreeRTOS/Source/queue.c **** 				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
1641:FreeRTOS/Source/queue.c **** 
1642:FreeRTOS/Source/queue.c **** 				prvCopyDataFromQueue( pxQueue, pvBuffer );
1643:FreeRTOS/Source/queue.c **** 				traceQUEUE_PEEK( pxQueue );
1644:FreeRTOS/Source/queue.c **** 
1645:FreeRTOS/Source/queue.c **** 				/* The data is not being removed, so reset the read pointer. */
1646:FreeRTOS/Source/queue.c **** 				pxQueue->u.pcReadFrom = pcOriginalReadPosition;
1647:FreeRTOS/Source/queue.c **** 
1648:FreeRTOS/Source/queue.c **** 				/* The data is being left in the queue, so see if there are
1649:FreeRTOS/Source/queue.c **** 				any other tasks waiting for the data. */
1650:FreeRTOS/Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1651:FreeRTOS/Source/queue.c **** 				{
1652:FreeRTOS/Source/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1653:FreeRTOS/Source/queue.c **** 					{
1654:FreeRTOS/Source/queue.c **** 						/* The task waiting has a higher priority than this task. */
1655:FreeRTOS/Source/queue.c **** 						queueYIELD_IF_USING_PREEMPTION();
1656:FreeRTOS/Source/queue.c **** 					}
1657:FreeRTOS/Source/queue.c **** 					else
1658:FreeRTOS/Source/queue.c **** 					{
1659:FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1660:FreeRTOS/Source/queue.c **** 					}
1661:FreeRTOS/Source/queue.c **** 				}
1662:FreeRTOS/Source/queue.c **** 				else
1663:FreeRTOS/Source/queue.c **** 				{
1664:FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1665:FreeRTOS/Source/queue.c **** 				}
1666:FreeRTOS/Source/queue.c **** 
1667:FreeRTOS/Source/queue.c **** 				taskEXIT_CRITICAL();
1668:FreeRTOS/Source/queue.c **** 				return pdPASS;
1669:FreeRTOS/Source/queue.c **** 			}
1670:FreeRTOS/Source/queue.c **** 			else
1671:FreeRTOS/Source/queue.c **** 			{
1672:FreeRTOS/Source/queue.c **** 				if( xTicksToWait == ( TickType_t ) 0 )
1673:FreeRTOS/Source/queue.c **** 				{
1674:FreeRTOS/Source/queue.c **** 					/* The queue was empty and no block time is specified (or
1675:FreeRTOS/Source/queue.c **** 					the block time has expired) so leave now. */
1676:FreeRTOS/Source/queue.c **** 					taskEXIT_CRITICAL();
1677:FreeRTOS/Source/queue.c **** 					traceQUEUE_PEEK_FAILED( pxQueue );
1678:FreeRTOS/Source/queue.c **** 					return errQUEUE_EMPTY;
1679:FreeRTOS/Source/queue.c **** 				}
1680:FreeRTOS/Source/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
1681:FreeRTOS/Source/queue.c **** 				{
1682:FreeRTOS/Source/queue.c **** 					/* The queue was empty and a block time was specified so
1683:FreeRTOS/Source/queue.c **** 					configure the timeout structure ready to enter the blocked
1684:FreeRTOS/Source/queue.c **** 					state. */
1685:FreeRTOS/Source/queue.c **** 					vTaskInternalSetTimeOutState( &xTimeOut );
1686:FreeRTOS/Source/queue.c **** 					xEntryTimeSet = pdTRUE;
1687:FreeRTOS/Source/queue.c **** 				}
1688:FreeRTOS/Source/queue.c **** 				else
1689:FreeRTOS/Source/queue.c **** 				{
1690:FreeRTOS/Source/queue.c **** 					/* Entry time was already set. */
1691:FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1692:FreeRTOS/Source/queue.c **** 				}
1693:FreeRTOS/Source/queue.c **** 			}
1694:FreeRTOS/Source/queue.c **** 		}
1695:FreeRTOS/Source/queue.c **** 		taskEXIT_CRITICAL();
1696:FreeRTOS/Source/queue.c **** 
1697:FreeRTOS/Source/queue.c **** 		/* Interrupts and other tasks can send to and receive from the queue
1698:FreeRTOS/Source/queue.c **** 		now the critical section has been exited. */
1699:FreeRTOS/Source/queue.c **** 
1700:FreeRTOS/Source/queue.c **** 		vTaskSuspendAll();
1701:FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
1702:FreeRTOS/Source/queue.c **** 
1703:FreeRTOS/Source/queue.c **** 		/* Update the timeout state to see if it has expired yet. */
1704:FreeRTOS/Source/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
1705:FreeRTOS/Source/queue.c **** 		{
1706:FreeRTOS/Source/queue.c **** 			/* Timeout has not expired yet, check to see if there is data in the
1707:FreeRTOS/Source/queue.c **** 			queue now, and if not enter the Blocked state to wait for data. */
1708:FreeRTOS/Source/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
1709:FreeRTOS/Source/queue.c **** 			{
1710:FreeRTOS/Source/queue.c **** 				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
1711:FreeRTOS/Source/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
1712:FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
1713:FreeRTOS/Source/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
1714:FreeRTOS/Source/queue.c **** 				{
1715:FreeRTOS/Source/queue.c **** 					portYIELD_WITHIN_API();
1716:FreeRTOS/Source/queue.c **** 				}
1717:FreeRTOS/Source/queue.c **** 				else
1718:FreeRTOS/Source/queue.c **** 				{
1719:FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1720:FreeRTOS/Source/queue.c **** 				}
1721:FreeRTOS/Source/queue.c **** 			}
1722:FreeRTOS/Source/queue.c **** 			else
1723:FreeRTOS/Source/queue.c **** 			{
1724:FreeRTOS/Source/queue.c **** 				/* There is data in the queue now, so don't enter the blocked
1725:FreeRTOS/Source/queue.c **** 				state, instead return to try and obtain the data. */
1726:FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
1727:FreeRTOS/Source/queue.c **** 				( void ) xTaskResumeAll();
1728:FreeRTOS/Source/queue.c **** 			}
1729:FreeRTOS/Source/queue.c **** 		}
1730:FreeRTOS/Source/queue.c **** 		else
1731:FreeRTOS/Source/queue.c **** 		{
1732:FreeRTOS/Source/queue.c **** 			/* The timeout has expired.  If there is still no data in the queue
1733:FreeRTOS/Source/queue.c **** 			exit, otherwise go back and try to read the data again. */
1734:FreeRTOS/Source/queue.c **** 			prvUnlockQueue( pxQueue );
1735:FreeRTOS/Source/queue.c **** 			( void ) xTaskResumeAll();
1736:FreeRTOS/Source/queue.c **** 
1737:FreeRTOS/Source/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
1738:FreeRTOS/Source/queue.c **** 			{
1739:FreeRTOS/Source/queue.c **** 				traceQUEUE_PEEK_FAILED( pxQueue );
1740:FreeRTOS/Source/queue.c **** 				return errQUEUE_EMPTY;
1741:FreeRTOS/Source/queue.c **** 			}
1742:FreeRTOS/Source/queue.c **** 			else
1743:FreeRTOS/Source/queue.c **** 			{
1744:FreeRTOS/Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
1745:FreeRTOS/Source/queue.c **** 			}
1746:FreeRTOS/Source/queue.c **** 		}
1747:FreeRTOS/Source/queue.c **** 	}
1748:FreeRTOS/Source/queue.c **** }
1749:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1750:FreeRTOS/Source/queue.c **** 
1751:FreeRTOS/Source/queue.c **** BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const px
1752:FreeRTOS/Source/queue.c **** {
1753:FreeRTOS/Source/queue.c **** BaseType_t xReturn;
1754:FreeRTOS/Source/queue.c **** UBaseType_t uxSavedInterruptStatus;
1755:FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
1756:FreeRTOS/Source/queue.c **** 
1757:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
1758:FreeRTOS/Source/queue.c **** 	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
1759:FreeRTOS/Source/queue.c **** 
1760:FreeRTOS/Source/queue.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
1761:FreeRTOS/Source/queue.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
1762:FreeRTOS/Source/queue.c **** 	above the maximum system call priority are kept permanently enabled, even
1763:FreeRTOS/Source/queue.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
1764:FreeRTOS/Source/queue.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1765:FreeRTOS/Source/queue.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1766:FreeRTOS/Source/queue.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
1767:FreeRTOS/Source/queue.c **** 	assigned a priority above the configured maximum system call priority.
1768:FreeRTOS/Source/queue.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
1769:FreeRTOS/Source/queue.c **** 	that have been assigned a priority at or (logically) below the maximum
1770:FreeRTOS/Source/queue.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1771:FreeRTOS/Source/queue.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
1772:FreeRTOS/Source/queue.c **** 	More information (albeit Cortex-M specific) is provided on the following
1773:FreeRTOS/Source/queue.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1774:FreeRTOS/Source/queue.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1775:FreeRTOS/Source/queue.c **** 
1776:FreeRTOS/Source/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
1777:FreeRTOS/Source/queue.c **** 	{
1778:FreeRTOS/Source/queue.c **** 		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
1779:FreeRTOS/Source/queue.c **** 
1780:FreeRTOS/Source/queue.c **** 		/* Cannot block in an ISR, so check there is data available. */
1781:FreeRTOS/Source/queue.c **** 		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
1782:FreeRTOS/Source/queue.c **** 		{
1783:FreeRTOS/Source/queue.c **** 			const int8_t cRxLock = pxQueue->cRxLock;
1784:FreeRTOS/Source/queue.c **** 
1785:FreeRTOS/Source/queue.c **** 			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );
1786:FreeRTOS/Source/queue.c **** 
1787:FreeRTOS/Source/queue.c **** 			prvCopyDataFromQueue( pxQueue, pvBuffer );
1788:FreeRTOS/Source/queue.c **** 			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
1789:FreeRTOS/Source/queue.c **** 
1790:FreeRTOS/Source/queue.c **** 			/* If the queue is locked the event list will not be modified.
1791:FreeRTOS/Source/queue.c **** 			Instead update the lock count so the task that unlocks the queue
1792:FreeRTOS/Source/queue.c **** 			will know that an ISR has removed data while the queue was
1793:FreeRTOS/Source/queue.c **** 			locked. */
1794:FreeRTOS/Source/queue.c **** 			if( cRxLock == queueUNLOCKED )
1795:FreeRTOS/Source/queue.c **** 			{
1796:FreeRTOS/Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
1797:FreeRTOS/Source/queue.c **** 				{
1798:FreeRTOS/Source/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
1799:FreeRTOS/Source/queue.c **** 					{
1800:FreeRTOS/Source/queue.c **** 						/* The task waiting has a higher priority than us so
1801:FreeRTOS/Source/queue.c **** 						force a context switch. */
1802:FreeRTOS/Source/queue.c **** 						if( pxHigherPriorityTaskWoken != NULL )
1803:FreeRTOS/Source/queue.c **** 						{
1804:FreeRTOS/Source/queue.c **** 							*pxHigherPriorityTaskWoken = pdTRUE;
1805:FreeRTOS/Source/queue.c **** 						}
1806:FreeRTOS/Source/queue.c **** 						else
1807:FreeRTOS/Source/queue.c **** 						{
1808:FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1809:FreeRTOS/Source/queue.c **** 						}
1810:FreeRTOS/Source/queue.c **** 					}
1811:FreeRTOS/Source/queue.c **** 					else
1812:FreeRTOS/Source/queue.c **** 					{
1813:FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1814:FreeRTOS/Source/queue.c **** 					}
1815:FreeRTOS/Source/queue.c **** 				}
1816:FreeRTOS/Source/queue.c **** 				else
1817:FreeRTOS/Source/queue.c **** 				{
1818:FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1819:FreeRTOS/Source/queue.c **** 				}
1820:FreeRTOS/Source/queue.c **** 			}
1821:FreeRTOS/Source/queue.c **** 			else
1822:FreeRTOS/Source/queue.c **** 			{
1823:FreeRTOS/Source/queue.c **** 				/* Increment the lock count so the task that unlocks the queue
1824:FreeRTOS/Source/queue.c **** 				knows that data was removed while it was locked. */
1825:FreeRTOS/Source/queue.c **** 				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
1826:FreeRTOS/Source/queue.c **** 			}
1827:FreeRTOS/Source/queue.c **** 
1828:FreeRTOS/Source/queue.c **** 			xReturn = pdPASS;
1829:FreeRTOS/Source/queue.c **** 		}
1830:FreeRTOS/Source/queue.c **** 		else
1831:FreeRTOS/Source/queue.c **** 		{
1832:FreeRTOS/Source/queue.c **** 			xReturn = pdFAIL;
1833:FreeRTOS/Source/queue.c **** 			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
1834:FreeRTOS/Source/queue.c **** 		}
1835:FreeRTOS/Source/queue.c **** 	}
1836:FreeRTOS/Source/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1837:FreeRTOS/Source/queue.c **** 
1838:FreeRTOS/Source/queue.c **** 	return xReturn;
1839:FreeRTOS/Source/queue.c **** }
1840:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1841:FreeRTOS/Source/queue.c **** 
1842:FreeRTOS/Source/queue.c **** BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
1843:FreeRTOS/Source/queue.c **** {
1844:FreeRTOS/Source/queue.c **** BaseType_t xReturn;
1845:FreeRTOS/Source/queue.c **** UBaseType_t uxSavedInterruptStatus;
1846:FreeRTOS/Source/queue.c **** int8_t *pcOriginalReadPosition;
1847:FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
1848:FreeRTOS/Source/queue.c **** 
1849:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
1850:FreeRTOS/Source/queue.c **** 	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
1851:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue->uxItemSize != 0 ); /* Can't peek a semaphore. */
1852:FreeRTOS/Source/queue.c **** 
1853:FreeRTOS/Source/queue.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
1854:FreeRTOS/Source/queue.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
1855:FreeRTOS/Source/queue.c **** 	above the maximum system call priority are kept permanently enabled, even
1856:FreeRTOS/Source/queue.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
1857:FreeRTOS/Source/queue.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1858:FreeRTOS/Source/queue.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1859:FreeRTOS/Source/queue.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
1860:FreeRTOS/Source/queue.c **** 	assigned a priority above the configured maximum system call priority.
1861:FreeRTOS/Source/queue.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
1862:FreeRTOS/Source/queue.c **** 	that have been assigned a priority at or (logically) below the maximum
1863:FreeRTOS/Source/queue.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1864:FreeRTOS/Source/queue.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
1865:FreeRTOS/Source/queue.c **** 	More information (albeit Cortex-M specific) is provided on the following
1866:FreeRTOS/Source/queue.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1867:FreeRTOS/Source/queue.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1868:FreeRTOS/Source/queue.c **** 
1869:FreeRTOS/Source/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
1870:FreeRTOS/Source/queue.c **** 	{
1871:FreeRTOS/Source/queue.c **** 		/* Cannot block in an ISR, so check there is data available. */
1872:FreeRTOS/Source/queue.c **** 		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
1873:FreeRTOS/Source/queue.c **** 		{
1874:FreeRTOS/Source/queue.c **** 			traceQUEUE_PEEK_FROM_ISR( pxQueue );
1875:FreeRTOS/Source/queue.c **** 
1876:FreeRTOS/Source/queue.c **** 			/* Remember the read position so it can be reset as nothing is
1877:FreeRTOS/Source/queue.c **** 			actually being removed from the queue. */
1878:FreeRTOS/Source/queue.c **** 			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
1879:FreeRTOS/Source/queue.c **** 			prvCopyDataFromQueue( pxQueue, pvBuffer );
1880:FreeRTOS/Source/queue.c **** 			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
1881:FreeRTOS/Source/queue.c **** 
1882:FreeRTOS/Source/queue.c **** 			xReturn = pdPASS;
1883:FreeRTOS/Source/queue.c **** 		}
1884:FreeRTOS/Source/queue.c **** 		else
1885:FreeRTOS/Source/queue.c **** 		{
1886:FreeRTOS/Source/queue.c **** 			xReturn = pdFAIL;
1887:FreeRTOS/Source/queue.c **** 			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
1888:FreeRTOS/Source/queue.c **** 		}
1889:FreeRTOS/Source/queue.c **** 	}
1890:FreeRTOS/Source/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1891:FreeRTOS/Source/queue.c **** 
1892:FreeRTOS/Source/queue.c **** 	return xReturn;
1893:FreeRTOS/Source/queue.c **** }
1894:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1895:FreeRTOS/Source/queue.c **** 
1896:FreeRTOS/Source/queue.c **** UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
1897:FreeRTOS/Source/queue.c **** {
1898:FreeRTOS/Source/queue.c **** UBaseType_t uxReturn;
1899:FreeRTOS/Source/queue.c **** 
1900:FreeRTOS/Source/queue.c **** 	configASSERT( xQueue );
1901:FreeRTOS/Source/queue.c **** 
1902:FreeRTOS/Source/queue.c **** 	taskENTER_CRITICAL();
1903:FreeRTOS/Source/queue.c **** 	{
1904:FreeRTOS/Source/queue.c **** 		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
1905:FreeRTOS/Source/queue.c **** 	}
1906:FreeRTOS/Source/queue.c **** 	taskEXIT_CRITICAL();
1907:FreeRTOS/Source/queue.c **** 
1908:FreeRTOS/Source/queue.c **** 	return uxReturn;
1909:FreeRTOS/Source/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
1910:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1911:FreeRTOS/Source/queue.c **** 
1912:FreeRTOS/Source/queue.c **** UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
1913:FreeRTOS/Source/queue.c **** {
1914:FreeRTOS/Source/queue.c **** UBaseType_t uxReturn;
1915:FreeRTOS/Source/queue.c **** Queue_t *pxQueue;
1916:FreeRTOS/Source/queue.c **** 
1917:FreeRTOS/Source/queue.c **** 	pxQueue = ( Queue_t * ) xQueue;
1918:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
1919:FreeRTOS/Source/queue.c **** 
1920:FreeRTOS/Source/queue.c **** 	taskENTER_CRITICAL();
1921:FreeRTOS/Source/queue.c **** 	{
1922:FreeRTOS/Source/queue.c **** 		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
1923:FreeRTOS/Source/queue.c **** 	}
1924:FreeRTOS/Source/queue.c **** 	taskEXIT_CRITICAL();
1925:FreeRTOS/Source/queue.c **** 
1926:FreeRTOS/Source/queue.c **** 	return uxReturn;
1927:FreeRTOS/Source/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
1928:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1929:FreeRTOS/Source/queue.c **** 
1930:FreeRTOS/Source/queue.c **** UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
1931:FreeRTOS/Source/queue.c **** {
1932:FreeRTOS/Source/queue.c **** UBaseType_t uxReturn;
1933:FreeRTOS/Source/queue.c **** 
1934:FreeRTOS/Source/queue.c **** 	configASSERT( xQueue );
1935:FreeRTOS/Source/queue.c **** 
1936:FreeRTOS/Source/queue.c **** 	uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
1937:FreeRTOS/Source/queue.c **** 
1938:FreeRTOS/Source/queue.c **** 	return uxReturn;
1939:FreeRTOS/Source/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
1940:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1941:FreeRTOS/Source/queue.c **** 
1942:FreeRTOS/Source/queue.c **** void vQueueDelete( QueueHandle_t xQueue )
1943:FreeRTOS/Source/queue.c **** {
1944:FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
1945:FreeRTOS/Source/queue.c **** 
1946:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
1947:FreeRTOS/Source/queue.c **** 	traceQUEUE_DELETE( pxQueue );
1948:FreeRTOS/Source/queue.c **** 
1949:FreeRTOS/Source/queue.c **** 	#if ( configQUEUE_REGISTRY_SIZE > 0 )
1950:FreeRTOS/Source/queue.c **** 	{
1951:FreeRTOS/Source/queue.c **** 		vQueueUnregisterQueue( pxQueue );
1952:FreeRTOS/Source/queue.c **** 	}
1953:FreeRTOS/Source/queue.c **** 	#endif
1954:FreeRTOS/Source/queue.c **** 
1955:FreeRTOS/Source/queue.c **** 	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
1956:FreeRTOS/Source/queue.c **** 	{
1957:FreeRTOS/Source/queue.c **** 		/* The queue can only have been allocated dynamically - free it
1958:FreeRTOS/Source/queue.c **** 		again. */
1959:FreeRTOS/Source/queue.c **** 		vPortFree( pxQueue );
1960:FreeRTOS/Source/queue.c **** 	}
1961:FreeRTOS/Source/queue.c **** 	#elif( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
1962:FreeRTOS/Source/queue.c **** 	{
1963:FreeRTOS/Source/queue.c **** 		/* The queue could have been allocated statically or dynamically, so
1964:FreeRTOS/Source/queue.c **** 		check before attempting to free the memory. */
1965:FreeRTOS/Source/queue.c **** 		if( pxQueue->ucStaticallyAllocated == ( uint8_t ) pdFALSE )
1966:FreeRTOS/Source/queue.c **** 		{
1967:FreeRTOS/Source/queue.c **** 			vPortFree( pxQueue );
1968:FreeRTOS/Source/queue.c **** 		}
1969:FreeRTOS/Source/queue.c **** 		else
1970:FreeRTOS/Source/queue.c **** 		{
1971:FreeRTOS/Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
1972:FreeRTOS/Source/queue.c **** 		}
1973:FreeRTOS/Source/queue.c **** 	}
1974:FreeRTOS/Source/queue.c **** 	#else
1975:FreeRTOS/Source/queue.c **** 	{
1976:FreeRTOS/Source/queue.c **** 		/* The queue must have been statically allocated, so is not going to be
1977:FreeRTOS/Source/queue.c **** 		deleted.  Avoid compiler warnings about the unused parameter. */
1978:FreeRTOS/Source/queue.c **** 		( void ) pxQueue;
1979:FreeRTOS/Source/queue.c **** 	}
1980:FreeRTOS/Source/queue.c **** 	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
1981:FreeRTOS/Source/queue.c **** }
1982:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1983:FreeRTOS/Source/queue.c **** 
1984:FreeRTOS/Source/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1985:FreeRTOS/Source/queue.c **** 
1986:FreeRTOS/Source/queue.c **** 	UBaseType_t uxQueueGetQueueNumber( QueueHandle_t xQueue )
1987:FreeRTOS/Source/queue.c **** 	{
1988:FreeRTOS/Source/queue.c **** 		return ( ( Queue_t * ) xQueue )->uxQueueNumber;
1989:FreeRTOS/Source/queue.c **** 	}
1990:FreeRTOS/Source/queue.c **** 
1991:FreeRTOS/Source/queue.c **** #endif /* configUSE_TRACE_FACILITY */
1992:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1993:FreeRTOS/Source/queue.c **** 
1994:FreeRTOS/Source/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1995:FreeRTOS/Source/queue.c **** 
1996:FreeRTOS/Source/queue.c **** 	void vQueueSetQueueNumber( QueueHandle_t xQueue, UBaseType_t uxQueueNumber )
1997:FreeRTOS/Source/queue.c **** 	{
1998:FreeRTOS/Source/queue.c **** 		( ( Queue_t * ) xQueue )->uxQueueNumber = uxQueueNumber;
1999:FreeRTOS/Source/queue.c **** 	}
2000:FreeRTOS/Source/queue.c **** 
2001:FreeRTOS/Source/queue.c **** #endif /* configUSE_TRACE_FACILITY */
2002:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2003:FreeRTOS/Source/queue.c **** 
2004:FreeRTOS/Source/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2005:FreeRTOS/Source/queue.c **** 
2006:FreeRTOS/Source/queue.c **** 	uint8_t ucQueueGetQueueType( QueueHandle_t xQueue )
2007:FreeRTOS/Source/queue.c **** 	{
2008:FreeRTOS/Source/queue.c **** 		return ( ( Queue_t * ) xQueue )->ucQueueType;
2009:FreeRTOS/Source/queue.c **** 	}
2010:FreeRTOS/Source/queue.c **** 
2011:FreeRTOS/Source/queue.c **** #endif /* configUSE_TRACE_FACILITY */
2012:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2013:FreeRTOS/Source/queue.c **** 
2014:FreeRTOS/Source/queue.c **** #if( configUSE_MUTEXES == 1 )
2015:FreeRTOS/Source/queue.c **** 
2016:FreeRTOS/Source/queue.c **** 	static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue )
2017:FreeRTOS/Source/queue.c **** 	{
2018:FreeRTOS/Source/queue.c **** 	UBaseType_t uxHighestPriorityOfWaitingTasks;
2019:FreeRTOS/Source/queue.c **** 
2020:FreeRTOS/Source/queue.c **** 		/* If a task waiting for a mutex causes the mutex holder to inherit a
2021:FreeRTOS/Source/queue.c **** 		priority, but the waiting task times out, then the holder should
2022:FreeRTOS/Source/queue.c **** 		disinherit the priority - but only down to the highest priority of any
2023:FreeRTOS/Source/queue.c **** 		other tasks that are waiting for the same mutex.  For this purpose,
2024:FreeRTOS/Source/queue.c **** 		return the priority of the highest priority task that is waiting for the
2025:FreeRTOS/Source/queue.c **** 		mutex. */
2026:FreeRTOS/Source/queue.c **** 		if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0 )
2027:FreeRTOS/Source/queue.c **** 		{
2028:FreeRTOS/Source/queue.c **** 			uxHighestPriorityOfWaitingTasks = configMAX_PRIORITIES - listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( px
2029:FreeRTOS/Source/queue.c **** 		}
2030:FreeRTOS/Source/queue.c **** 		else
2031:FreeRTOS/Source/queue.c **** 		{
2032:FreeRTOS/Source/queue.c **** 			uxHighestPriorityOfWaitingTasks = tskIDLE_PRIORITY;
2033:FreeRTOS/Source/queue.c **** 		}
2034:FreeRTOS/Source/queue.c **** 
2035:FreeRTOS/Source/queue.c **** 		return uxHighestPriorityOfWaitingTasks;
2036:FreeRTOS/Source/queue.c **** 	}
2037:FreeRTOS/Source/queue.c **** 
2038:FreeRTOS/Source/queue.c **** #endif /* configUSE_MUTEXES */
2039:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2040:FreeRTOS/Source/queue.c **** 
2041:FreeRTOS/Source/queue.c **** static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const Bas
2042:FreeRTOS/Source/queue.c **** {
2043:FreeRTOS/Source/queue.c **** BaseType_t xReturn = pdFALSE;
2044:FreeRTOS/Source/queue.c **** UBaseType_t uxMessagesWaiting;
2045:FreeRTOS/Source/queue.c **** 
2046:FreeRTOS/Source/queue.c **** 	/* This function is called from a critical section. */
2047:FreeRTOS/Source/queue.c **** 
2048:FreeRTOS/Source/queue.c **** 	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
2049:FreeRTOS/Source/queue.c **** 
2050:FreeRTOS/Source/queue.c **** 	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
2051:FreeRTOS/Source/queue.c **** 	{
2052:FreeRTOS/Source/queue.c **** 		#if ( configUSE_MUTEXES == 1 )
2053:FreeRTOS/Source/queue.c **** 		{
2054:FreeRTOS/Source/queue.c **** 			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
2055:FreeRTOS/Source/queue.c **** 			{
2056:FreeRTOS/Source/queue.c **** 				/* The mutex is no longer being held. */
2057:FreeRTOS/Source/queue.c **** 				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
2058:FreeRTOS/Source/queue.c **** 				pxQueue->pxMutexHolder = NULL;
2059:FreeRTOS/Source/queue.c **** 			}
2060:FreeRTOS/Source/queue.c **** 			else
2061:FreeRTOS/Source/queue.c **** 			{
2062:FreeRTOS/Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2063:FreeRTOS/Source/queue.c **** 			}
2064:FreeRTOS/Source/queue.c **** 		}
2065:FreeRTOS/Source/queue.c **** 		#endif /* configUSE_MUTEXES */
2066:FreeRTOS/Source/queue.c **** 	}
2067:FreeRTOS/Source/queue.c **** 	else if( xPosition == queueSEND_TO_BACK )
2068:FreeRTOS/Source/queue.c **** 	{
2069:FreeRTOS/Source/queue.c **** 		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); 
2070:FreeRTOS/Source/queue.c **** 		pxQueue->pcWriteTo += pxQueue->uxItemSize;
2071:FreeRTOS/Source/queue.c **** 		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison 
2072:FreeRTOS/Source/queue.c **** 		{
2073:FreeRTOS/Source/queue.c **** 			pxQueue->pcWriteTo = pxQueue->pcHead;
2074:FreeRTOS/Source/queue.c **** 		}
2075:FreeRTOS/Source/queue.c **** 		else
2076:FreeRTOS/Source/queue.c **** 		{
2077:FreeRTOS/Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
2078:FreeRTOS/Source/queue.c **** 		}
2079:FreeRTOS/Source/queue.c **** 	}
2080:FreeRTOS/Source/queue.c **** 	else
2081:FreeRTOS/Source/queue.c **** 	{
2082:FreeRTOS/Source/queue.c **** 		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize 
2083:FreeRTOS/Source/queue.c **** 		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
2084:FreeRTOS/Source/queue.c **** 		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as compariso
2085:FreeRTOS/Source/queue.c **** 		{
2086:FreeRTOS/Source/queue.c **** 			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
2087:FreeRTOS/Source/queue.c **** 		}
2088:FreeRTOS/Source/queue.c **** 		else
2089:FreeRTOS/Source/queue.c **** 		{
2090:FreeRTOS/Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
2091:FreeRTOS/Source/queue.c **** 		}
2092:FreeRTOS/Source/queue.c **** 
2093:FreeRTOS/Source/queue.c **** 		if( xPosition == queueOVERWRITE )
2094:FreeRTOS/Source/queue.c **** 		{
2095:FreeRTOS/Source/queue.c **** 			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
2096:FreeRTOS/Source/queue.c **** 			{
2097:FreeRTOS/Source/queue.c **** 				/* An item is not being added but overwritten, so subtract
2098:FreeRTOS/Source/queue.c **** 				one from the recorded number of items in the queue so when
2099:FreeRTOS/Source/queue.c **** 				one is added again below the number of recorded items remains
2100:FreeRTOS/Source/queue.c **** 				correct. */
2101:FreeRTOS/Source/queue.c **** 				--uxMessagesWaiting;
2102:FreeRTOS/Source/queue.c **** 			}
2103:FreeRTOS/Source/queue.c **** 			else
2104:FreeRTOS/Source/queue.c **** 			{
2105:FreeRTOS/Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2106:FreeRTOS/Source/queue.c **** 			}
2107:FreeRTOS/Source/queue.c **** 		}
2108:FreeRTOS/Source/queue.c **** 		else
2109:FreeRTOS/Source/queue.c **** 		{
2110:FreeRTOS/Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
2111:FreeRTOS/Source/queue.c **** 		}
2112:FreeRTOS/Source/queue.c **** 	}
2113:FreeRTOS/Source/queue.c **** 
2114:FreeRTOS/Source/queue.c **** 	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
2115:FreeRTOS/Source/queue.c **** 
2116:FreeRTOS/Source/queue.c **** 	return xReturn;
2117:FreeRTOS/Source/queue.c **** }
2118:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2119:FreeRTOS/Source/queue.c **** 
2120:FreeRTOS/Source/queue.c **** static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
2121:FreeRTOS/Source/queue.c **** {
2122:FreeRTOS/Source/queue.c **** 	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
2123:FreeRTOS/Source/queue.c **** 	{
2124:FreeRTOS/Source/queue.c **** 		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
2125:FreeRTOS/Source/queue.c **** 		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of t
2126:FreeRTOS/Source/queue.c **** 		{
2127:FreeRTOS/Source/queue.c **** 			pxQueue->u.pcReadFrom = pxQueue->pcHead;
2128:FreeRTOS/Source/queue.c **** 		}
2129:FreeRTOS/Source/queue.c **** 		else
2130:FreeRTOS/Source/queue.c **** 		{
2131:FreeRTOS/Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
2132:FreeRTOS/Source/queue.c **** 		}
2133:FreeRTOS/Source/queue.c **** 		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxIte
2134:FreeRTOS/Source/queue.c **** 	}
2135:FreeRTOS/Source/queue.c **** }
2136:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2137:FreeRTOS/Source/queue.c **** 
2138:FreeRTOS/Source/queue.c **** static void prvUnlockQueue( Queue_t * const pxQueue )
2139:FreeRTOS/Source/queue.c **** {
2140:FreeRTOS/Source/queue.c **** 	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */
2141:FreeRTOS/Source/queue.c **** 
2142:FreeRTOS/Source/queue.c **** 	/* The lock counts contains the number of extra data items placed or
2143:FreeRTOS/Source/queue.c **** 	removed from the queue while the queue was locked.  When a queue is
2144:FreeRTOS/Source/queue.c **** 	locked items can be added or removed, but the event lists cannot be
2145:FreeRTOS/Source/queue.c **** 	updated. */
2146:FreeRTOS/Source/queue.c **** 	taskENTER_CRITICAL();
2147:FreeRTOS/Source/queue.c **** 	{
2148:FreeRTOS/Source/queue.c **** 		int8_t cTxLock = pxQueue->cTxLock;
2149:FreeRTOS/Source/queue.c **** 
2150:FreeRTOS/Source/queue.c **** 		/* See if data was added to the queue while it was locked. */
2151:FreeRTOS/Source/queue.c **** 		while( cTxLock > queueLOCKED_UNMODIFIED )
2152:FreeRTOS/Source/queue.c **** 		{
2153:FreeRTOS/Source/queue.c **** 			/* Data was posted while the queue was locked.  Are any tasks
2154:FreeRTOS/Source/queue.c **** 			blocked waiting for data to become available? */
2155:FreeRTOS/Source/queue.c **** 			#if ( configUSE_QUEUE_SETS == 1 )
2156:FreeRTOS/Source/queue.c **** 			{
2157:FreeRTOS/Source/queue.c **** 				if( pxQueue->pxQueueSetContainer != NULL )
2158:FreeRTOS/Source/queue.c **** 				{
2159:FreeRTOS/Source/queue.c **** 					if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) != pdFALSE )
2160:FreeRTOS/Source/queue.c **** 					{
2161:FreeRTOS/Source/queue.c **** 						/* The queue is a member of a queue set, and posting to
2162:FreeRTOS/Source/queue.c **** 						the queue set caused a higher priority task to unblock.
2163:FreeRTOS/Source/queue.c **** 						A context switch is required. */
2164:FreeRTOS/Source/queue.c **** 						vTaskMissedYield();
2165:FreeRTOS/Source/queue.c **** 					}
2166:FreeRTOS/Source/queue.c **** 					else
2167:FreeRTOS/Source/queue.c **** 					{
2168:FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
2169:FreeRTOS/Source/queue.c **** 					}
2170:FreeRTOS/Source/queue.c **** 				}
2171:FreeRTOS/Source/queue.c **** 				else
2172:FreeRTOS/Source/queue.c **** 				{
2173:FreeRTOS/Source/queue.c **** 					/* Tasks that are removed from the event list will get
2174:FreeRTOS/Source/queue.c **** 					added to the pending ready list as the scheduler is still
2175:FreeRTOS/Source/queue.c **** 					suspended. */
2176:FreeRTOS/Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
2177:FreeRTOS/Source/queue.c **** 					{
2178:FreeRTOS/Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
2179:FreeRTOS/Source/queue.c **** 						{
2180:FreeRTOS/Source/queue.c **** 							/* The task waiting has a higher priority so record that a
2181:FreeRTOS/Source/queue.c **** 							context	switch is required. */
2182:FreeRTOS/Source/queue.c **** 							vTaskMissedYield();
2183:FreeRTOS/Source/queue.c **** 						}
2184:FreeRTOS/Source/queue.c **** 						else
2185:FreeRTOS/Source/queue.c **** 						{
2186:FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
2187:FreeRTOS/Source/queue.c **** 						}
2188:FreeRTOS/Source/queue.c **** 					}
2189:FreeRTOS/Source/queue.c **** 					else
2190:FreeRTOS/Source/queue.c **** 					{
2191:FreeRTOS/Source/queue.c **** 						break;
2192:FreeRTOS/Source/queue.c **** 					}
2193:FreeRTOS/Source/queue.c **** 				}
2194:FreeRTOS/Source/queue.c **** 			}
2195:FreeRTOS/Source/queue.c **** 			#else /* configUSE_QUEUE_SETS */
2196:FreeRTOS/Source/queue.c **** 			{
2197:FreeRTOS/Source/queue.c **** 				/* Tasks that are removed from the event list will get added to
2198:FreeRTOS/Source/queue.c **** 				the pending ready list as the scheduler is still suspended. */
2199:FreeRTOS/Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
2200:FreeRTOS/Source/queue.c **** 				{
2201:FreeRTOS/Source/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
2202:FreeRTOS/Source/queue.c **** 					{
2203:FreeRTOS/Source/queue.c **** 						/* The task waiting has a higher priority so record that
2204:FreeRTOS/Source/queue.c **** 						a context switch is required. */
2205:FreeRTOS/Source/queue.c **** 						vTaskMissedYield();
2206:FreeRTOS/Source/queue.c **** 					}
2207:FreeRTOS/Source/queue.c **** 					else
2208:FreeRTOS/Source/queue.c **** 					{
2209:FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
2210:FreeRTOS/Source/queue.c **** 					}
2211:FreeRTOS/Source/queue.c **** 				}
2212:FreeRTOS/Source/queue.c **** 				else
2213:FreeRTOS/Source/queue.c **** 				{
2214:FreeRTOS/Source/queue.c **** 					break;
2215:FreeRTOS/Source/queue.c **** 				}
2216:FreeRTOS/Source/queue.c **** 			}
2217:FreeRTOS/Source/queue.c **** 			#endif /* configUSE_QUEUE_SETS */
2218:FreeRTOS/Source/queue.c **** 
2219:FreeRTOS/Source/queue.c **** 			--cTxLock;
2220:FreeRTOS/Source/queue.c **** 		}
2221:FreeRTOS/Source/queue.c **** 
2222:FreeRTOS/Source/queue.c **** 		pxQueue->cTxLock = queueUNLOCKED;
2223:FreeRTOS/Source/queue.c **** 	}
2224:FreeRTOS/Source/queue.c **** 	taskEXIT_CRITICAL();
2225:FreeRTOS/Source/queue.c **** 
2226:FreeRTOS/Source/queue.c **** 	/* Do the same for the Rx lock. */
2227:FreeRTOS/Source/queue.c **** 	taskENTER_CRITICAL();
2228:FreeRTOS/Source/queue.c **** 	{
2229:FreeRTOS/Source/queue.c **** 		int8_t cRxLock = pxQueue->cRxLock;
2230:FreeRTOS/Source/queue.c **** 
2231:FreeRTOS/Source/queue.c **** 		while( cRxLock > queueLOCKED_UNMODIFIED )
2232:FreeRTOS/Source/queue.c **** 		{
2233:FreeRTOS/Source/queue.c **** 			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
2234:FreeRTOS/Source/queue.c **** 			{
2235:FreeRTOS/Source/queue.c **** 				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
2236:FreeRTOS/Source/queue.c **** 				{
2237:FreeRTOS/Source/queue.c **** 					vTaskMissedYield();
2238:FreeRTOS/Source/queue.c **** 				}
2239:FreeRTOS/Source/queue.c **** 				else
2240:FreeRTOS/Source/queue.c **** 				{
2241:FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2242:FreeRTOS/Source/queue.c **** 				}
2243:FreeRTOS/Source/queue.c **** 
2244:FreeRTOS/Source/queue.c **** 				--cRxLock;
2245:FreeRTOS/Source/queue.c **** 			}
2246:FreeRTOS/Source/queue.c **** 			else
2247:FreeRTOS/Source/queue.c **** 			{
2248:FreeRTOS/Source/queue.c **** 				break;
2249:FreeRTOS/Source/queue.c **** 			}
2250:FreeRTOS/Source/queue.c **** 		}
2251:FreeRTOS/Source/queue.c **** 
2252:FreeRTOS/Source/queue.c **** 		pxQueue->cRxLock = queueUNLOCKED;
2253:FreeRTOS/Source/queue.c **** 	}
2254:FreeRTOS/Source/queue.c **** 	taskEXIT_CRITICAL();
2255:FreeRTOS/Source/queue.c **** }
2256:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2257:FreeRTOS/Source/queue.c **** 
2258:FreeRTOS/Source/queue.c **** static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
2259:FreeRTOS/Source/queue.c **** {
 197               	.LM0:
 198               	.LFBB1:
 199               	/* prologue: function */
 200               	/* frame size = 0 */
 201               	/* stack size = 0 */
 202               	.L__stack_usage = 0
2260:FreeRTOS/Source/queue.c **** BaseType_t xReturn;
2261:FreeRTOS/Source/queue.c **** 
2262:FreeRTOS/Source/queue.c **** 	taskENTER_CRITICAL();
 204               	.LM1:
 205               	/* #APP */
 206               	 ;  2262 "FreeRTOS/Source/queue.c" 1
 207 0000 0FB6      		in		__tmp_reg__, __SREG__
 208               	 ;  0 "" 2
 209               	 ;  2262 "FreeRTOS/Source/queue.c" 1
 210 0002 F894      		cli
 211               	 ;  0 "" 2
 212               	 ;  2262 "FreeRTOS/Source/queue.c" 1
 213 0004 0F92      		push	__tmp_reg__
 214               	 ;  0 "" 2
2263:FreeRTOS/Source/queue.c **** 	{
2264:FreeRTOS/Source/queue.c **** 		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
 216               	.LM2:
 217               	/* #NOAPP */
 218 0006 FC01      		movw r30,r24
 219 0008 928D      		ldd r25,Z+26
2265:FreeRTOS/Source/queue.c **** 		{
2266:FreeRTOS/Source/queue.c **** 			xReturn = pdTRUE;
2267:FreeRTOS/Source/queue.c **** 		}
2268:FreeRTOS/Source/queue.c **** 		else
2269:FreeRTOS/Source/queue.c **** 		{
2270:FreeRTOS/Source/queue.c **** 			xReturn = pdFALSE;
2271:FreeRTOS/Source/queue.c **** 		}
2272:FreeRTOS/Source/queue.c **** 	}
2273:FreeRTOS/Source/queue.c **** 	taskEXIT_CRITICAL();
 221               	.LM3:
 222               	/* #APP */
 223               	 ;  2273 "FreeRTOS/Source/queue.c" 1
 224 000a 0F90      		pop		__tmp_reg__
 225               	 ;  0 "" 2
 226               	 ;  2273 "FreeRTOS/Source/queue.c" 1
 227 000c 0FBE      		out		__SREG__, __tmp_reg__
 228               	 ;  0 "" 2
2264:FreeRTOS/Source/queue.c **** 		{
 230               	.LM4:
 231               	/* #NOAPP */
 232 000e 81E0      		ldi r24,lo8(1)
 233 0010 9111      		cpse r25,__zero_reg__
 234 0012 80E0      		ldi r24,0
 235               	.L2:
2274:FreeRTOS/Source/queue.c **** 
2275:FreeRTOS/Source/queue.c **** 	return xReturn;
2276:FreeRTOS/Source/queue.c **** }
 237               	.LM5:
 238 0014 0895      		ret
 240               	.Lscope1:
 242               		.stabd	78,0,0
 248               	prvCopyDataToQueue:
 249               		.stabd	46,0,0
2042:FreeRTOS/Source/queue.c **** BaseType_t xReturn = pdFALSE;
 251               	.LM6:
 252               	.LFBB2:
 253 0016 0F93      		push r16
 254 0018 1F93      		push r17
 255 001a CF93      		push r28
 256 001c DF93      		push r29
 257               	/* prologue: function */
 258               	/* frame size = 0 */
 259               	/* stack size = 4 */
 260               	.L__stack_usage = 4
 261 001e EC01      		movw r28,r24
 262 0020 042F      		mov r16,r20
2048:FreeRTOS/Source/queue.c **** 
 264               	.LM7:
 265 0022 1A8D      		ldd r17,Y+26
2050:FreeRTOS/Source/queue.c **** 	{
 267               	.LM8:
 268 0024 8C8D      		ldd r24,Y+28
 269 0026 8823      		tst r24
 270 0028 01F0      		breq .L8
 271 002a 482F      		mov r20,r24
 272 002c 50E0      		ldi r21,0
2067:FreeRTOS/Source/queue.c **** 	{
 274               	.LM9:
 275 002e 0111      		cpse r16,__zero_reg__
 276 0030 00C0      		rjmp .L9
2069:FreeRTOS/Source/queue.c **** 		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 278               	.LM10:
 279 0032 8C81      		ldd r24,Y+4
 280 0034 9D81      		ldd r25,Y+5
 281 0036 0E94 0000 		call memcpy
2070:FreeRTOS/Source/queue.c **** 		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison 
 283               	.LM11:
 284 003a 2C8D      		ldd r18,Y+28
 285 003c 8C81      		ldd r24,Y+4
 286 003e 9D81      		ldd r25,Y+5
 287 0040 820F      		add r24,r18
 288 0042 911D      		adc r25,__zero_reg__
 289 0044 9D83      		std Y+5,r25
 290 0046 8C83      		std Y+4,r24
2071:FreeRTOS/Source/queue.c **** 		{
 292               	.LM12:
 293 0048 2A81      		ldd r18,Y+2
 294 004a 3B81      		ldd r19,Y+3
 295 004c 8217      		cp r24,r18
 296 004e 9307      		cpc r25,r19
 297 0050 00F0      		brlo .L8
2073:FreeRTOS/Source/queue.c **** 		}
 299               	.LM13:
 300 0052 8881      		ld r24,Y
 301 0054 9981      		ldd r25,Y+1
 302 0056 9D83      		std Y+5,r25
 303 0058 8C83      		std Y+4,r24
 304 005a 00C0      		rjmp .L8
 305               	.L9:
2082:FreeRTOS/Source/queue.c **** 		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
 307               	.LM14:
 308 005c 8E81      		ldd r24,Y+6
 309 005e 9F81      		ldd r25,Y+7
 310 0060 0E94 0000 		call memcpy
2083:FreeRTOS/Source/queue.c **** 		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as compariso
 312               	.LM15:
 313 0064 8C8D      		ldd r24,Y+28
 314 0066 90E0      		ldi r25,0
 315 0068 9195      		neg r25
 316 006a 8195      		neg r24
 317 006c 9109      		sbc r25,__zero_reg__
 318 006e 2E81      		ldd r18,Y+6
 319 0070 3F81      		ldd r19,Y+7
 320 0072 280F      		add r18,r24
 321 0074 391F      		adc r19,r25
 322 0076 3F83      		std Y+7,r19
 323 0078 2E83      		std Y+6,r18
2084:FreeRTOS/Source/queue.c **** 		{
 325               	.LM16:
 326 007a 4881      		ld r20,Y
 327 007c 5981      		ldd r21,Y+1
 328 007e 2417      		cp r18,r20
 329 0080 3507      		cpc r19,r21
 330 0082 00F4      		brsh .L10
2086:FreeRTOS/Source/queue.c **** 		}
 332               	.LM17:
 333 0084 2A81      		ldd r18,Y+2
 334 0086 3B81      		ldd r19,Y+3
 335 0088 820F      		add r24,r18
 336 008a 931F      		adc r25,r19
 337 008c 9F83      		std Y+7,r25
 338 008e 8E83      		std Y+6,r24
 339               	.L10:
2093:FreeRTOS/Source/queue.c **** 		{
 341               	.LM18:
 342 0090 0230      		cpi r16,lo8(2)
 343 0092 01F4      		brne .L8
2095:FreeRTOS/Source/queue.c **** 			{
 345               	.LM19:
 346 0094 1111      		cpse r17,__zero_reg__
2101:FreeRTOS/Source/queue.c **** 			}
 348               	.LM20:
 349 0096 1150      		subi r17,lo8(-(-1))
 350               	.L8:
2114:FreeRTOS/Source/queue.c **** 
 352               	.LM21:
 353 0098 1F5F      		subi r17,lo8(-(1))
 354 009a 1A8F      		std Y+26,r17
2117:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 356               	.LM22:
 357 009c 80E0      		ldi r24,0
 358               	/* epilogue start */
 359 009e DF91      		pop r29
 360 00a0 CF91      		pop r28
 361 00a2 1F91      		pop r17
 362 00a4 0F91      		pop r16
 363 00a6 0895      		ret
 368               	.Lscope2:
 370               		.stabd	78,0,0
 375               	prvCopyDataFromQueue:
 376               		.stabd	46,0,0
2121:FreeRTOS/Source/queue.c **** 	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 378               	.LM23:
 379               	.LFBB3:
 380               	/* prologue: function */
 381               	/* frame size = 0 */
 382               	/* stack size = 0 */
 383               	.L__stack_usage = 0
 384 00a8 FC01      		movw r30,r24
 385 00aa CB01      		movw r24,r22
2122:FreeRTOS/Source/queue.c **** 	{
 387               	.LM24:
 388 00ac 448D      		ldd r20,Z+28
 389 00ae 4423      		tst r20
 390 00b0 01F0      		breq .L17
2124:FreeRTOS/Source/queue.c **** 		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of t
 392               	.LM25:
 393 00b2 50E0      		ldi r21,0
 394 00b4 2681      		ldd r18,Z+6
 395 00b6 3781      		ldd r19,Z+7
 396 00b8 240F      		add r18,r20
 397 00ba 351F      		adc r19,r21
 398 00bc 3783      		std Z+7,r19
 399 00be 2683      		std Z+6,r18
2125:FreeRTOS/Source/queue.c **** 		{
 401               	.LM26:
 402 00c0 6281      		ldd r22,Z+2
 403 00c2 7381      		ldd r23,Z+3
 404 00c4 2617      		cp r18,r22
 405 00c6 3707      		cpc r19,r23
 406 00c8 00F0      		brlo .L19
2127:FreeRTOS/Source/queue.c **** 		}
 408               	.LM27:
 409 00ca 2081      		ld r18,Z
 410 00cc 3181      		ldd r19,Z+1
 411 00ce 3783      		std Z+7,r19
 412 00d0 2683      		std Z+6,r18
 413               	.L19:
2133:FreeRTOS/Source/queue.c **** 	}
 415               	.LM28:
 416 00d2 6681      		ldd r22,Z+6
 417 00d4 7781      		ldd r23,Z+7
 418 00d6 0C94 0000 		jmp memcpy
 419               	.L17:
 420 00da 0895      		ret
 422               	.Lscope3:
 424               		.stabd	78,0,0
 428               	prvUnlockQueue:
 429               		.stabd	46,0,0
2139:FreeRTOS/Source/queue.c **** 	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */
 431               	.LM29:
 432               	.LFBB4:
 433 00dc EF92      		push r14
 434 00de FF92      		push r15
 435 00e0 1F93      		push r17
 436 00e2 CF93      		push r28
 437 00e4 DF93      		push r29
 438               	/* prologue: function */
 439               	/* frame size = 0 */
 440               	/* stack size = 5 */
 441               	.L__stack_usage = 5
 442 00e6 EC01      		movw r28,r24
2146:FreeRTOS/Source/queue.c **** 	{
 444               	.LM30:
 445               	/* #APP */
 446               	 ;  2146 "FreeRTOS/Source/queue.c" 1
 447 00e8 0FB6      		in		__tmp_reg__, __SREG__
 448               	 ;  0 "" 2
 449               	 ;  2146 "FreeRTOS/Source/queue.c" 1
 450 00ea F894      		cli
 451               	 ;  0 "" 2
 452               	 ;  2146 "FreeRTOS/Source/queue.c" 1
 453 00ec 0F92      		push	__tmp_reg__
 454               	 ;  0 "" 2
 455               	/* #NOAPP */
 456               	.LBB2:
2148:FreeRTOS/Source/queue.c **** 
 458               	.LM31:
 459 00ee 1E8D      		ldd r17,Y+30
2201:FreeRTOS/Source/queue.c **** 					{
 461               	.LM32:
 462 00f0 7C01      		movw r14,r24
 463 00f2 81E1      		ldi r24,17
 464 00f4 E80E      		add r14,r24
 465 00f6 F11C      		adc r15,__zero_reg__
 466               	.L21:
2151:FreeRTOS/Source/queue.c **** 		{
 468               	.LM33:
 469 00f8 1116      		cp __zero_reg__,r17
 470 00fa 04F4      		brge .L22
2199:FreeRTOS/Source/queue.c **** 				{
 472               	.LM34:
 473 00fc 8989      		ldd r24,Y+17
 474 00fe 8823      		tst r24
 475 0100 01F0      		breq .L22
2201:FreeRTOS/Source/queue.c **** 					{
 477               	.LM35:
 478 0102 C701      		movw r24,r14
 479 0104 0E94 0000 		call xTaskRemoveFromEventList
 480 0108 8111      		cpse r24,__zero_reg__
2205:FreeRTOS/Source/queue.c **** 					}
 482               	.LM36:
 483 010a 0E94 0000 		call vTaskMissedYield
 484               	.L23:
 485 010e 1150      		subi r17,lo8(-(-1))
 486 0110 00C0      		rjmp .L21
 487               	.L22:
2222:FreeRTOS/Source/queue.c **** 	}
 489               	.LM37:
 490 0112 8FEF      		ldi r24,lo8(-1)
 491 0114 8E8F      		std Y+30,r24
 492               	.LBE2:
2224:FreeRTOS/Source/queue.c **** 
 494               	.LM38:
 495               	/* #APP */
 496               	 ;  2224 "FreeRTOS/Source/queue.c" 1
 497 0116 0F90      		pop		__tmp_reg__
 498               	 ;  0 "" 2
 499               	 ;  2224 "FreeRTOS/Source/queue.c" 1
 500 0118 0FBE      		out		__SREG__, __tmp_reg__
 501               	 ;  0 "" 2
2227:FreeRTOS/Source/queue.c **** 	{
 503               	.LM39:
 504               	 ;  2227 "FreeRTOS/Source/queue.c" 1
 505 011a 0FB6      		in		__tmp_reg__, __SREG__
 506               	 ;  0 "" 2
 507               	 ;  2227 "FreeRTOS/Source/queue.c" 1
 508 011c F894      		cli
 509               	 ;  0 "" 2
 510               	 ;  2227 "FreeRTOS/Source/queue.c" 1
 511 011e 0F92      		push	__tmp_reg__
 512               	 ;  0 "" 2
 513               	/* #NOAPP */
 514               	.LBB3:
2229:FreeRTOS/Source/queue.c **** 
 516               	.LM40:
 517 0120 1D8D      		ldd r17,Y+29
2235:FreeRTOS/Source/queue.c **** 				{
 519               	.LM41:
 520 0122 7E01      		movw r14,r28
 521 0124 88E0      		ldi r24,8
 522 0126 E80E      		add r14,r24
 523 0128 F11C      		adc r15,__zero_reg__
 524               	.L25:
2231:FreeRTOS/Source/queue.c **** 		{
 526               	.LM42:
 527 012a 1116      		cp __zero_reg__,r17
 528 012c 04F4      		brge .L26
2233:FreeRTOS/Source/queue.c **** 			{
 530               	.LM43:
 531 012e 8885      		ldd r24,Y+8
 532 0130 8823      		tst r24
 533 0132 01F0      		breq .L26
2235:FreeRTOS/Source/queue.c **** 				{
 535               	.LM44:
 536 0134 C701      		movw r24,r14
 537 0136 0E94 0000 		call xTaskRemoveFromEventList
 538 013a 8111      		cpse r24,__zero_reg__
2237:FreeRTOS/Source/queue.c **** 				}
 540               	.LM45:
 541 013c 0E94 0000 		call vTaskMissedYield
 542               	.L27:
 543 0140 1150      		subi r17,lo8(-(-1))
 544 0142 00C0      		rjmp .L25
 545               	.L26:
2252:FreeRTOS/Source/queue.c **** 	}
 547               	.LM46:
 548 0144 8FEF      		ldi r24,lo8(-1)
 549 0146 8D8F      		std Y+29,r24
 550               	.LBE3:
2254:FreeRTOS/Source/queue.c **** }
 552               	.LM47:
 553               	/* #APP */
 554               	 ;  2254 "FreeRTOS/Source/queue.c" 1
 555 0148 0F90      		pop		__tmp_reg__
 556               	 ;  0 "" 2
 557               	 ;  2254 "FreeRTOS/Source/queue.c" 1
 558 014a 0FBE      		out		__SREG__, __tmp_reg__
 559               	 ;  0 "" 2
 560               	/* epilogue start */
2255:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 562               	.LM48:
 563               	/* #NOAPP */
 564 014c DF91      		pop r29
 565 014e CF91      		pop r28
 566 0150 1F91      		pop r17
 567 0152 FF90      		pop r15
 568 0154 EF90      		pop r14
 569 0156 0895      		ret
 577               	.Lscope4:
 579               		.stabd	78,0,0
 583               	.global	xQueueGenericReset
 585               	xQueueGenericReset:
 586               		.stabd	46,0,0
 249:FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 588               	.LM49:
 589               	.LFBB5:
 590 0158 CF93      		push r28
 591 015a DF93      		push r29
 592               	/* prologue: function */
 593               	/* frame size = 0 */
 594               	/* stack size = 2 */
 595               	.L__stack_usage = 2
 596 015c EC01      		movw r28,r24
 254:FreeRTOS/Source/queue.c **** 	{
 598               	.LM50:
 599               	/* #APP */
 600               	 ;  254 "FreeRTOS/Source/queue.c" 1
 601 015e 0FB6      		in		__tmp_reg__, __SREG__
 602               	 ;  0 "" 2
 603               	 ;  254 "FreeRTOS/Source/queue.c" 1
 604 0160 F894      		cli
 605               	 ;  0 "" 2
 606               	 ;  254 "FreeRTOS/Source/queue.c" 1
 607 0162 0F92      		push	__tmp_reg__
 608               	 ;  0 "" 2
 256:FreeRTOS/Source/queue.c **** 		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 610               	.LM51:
 611               	/* #NOAPP */
 612 0164 2881      		ld r18,Y
 613 0166 3981      		ldd r19,Y+1
 614 0168 9B8D      		ldd r25,Y+27
 615 016a 4C8D      		ldd r20,Y+28
 616 016c 949F      		mul r25,r20
 617 016e C001      		movw r24,r0
 618 0170 1124      		clr __zero_reg__
 619 0172 F901      		movw r30,r18
 620 0174 E80F      		add r30,r24
 621 0176 F91F      		adc r31,r25
 622 0178 FB83      		std Y+3,r31
 623 017a EA83      		std Y+2,r30
 257:FreeRTOS/Source/queue.c **** 		pxQueue->pcWriteTo = pxQueue->pcHead;
 625               	.LM52:
 626 017c 1A8E      		std Y+26,__zero_reg__
 258:FreeRTOS/Source/queue.c **** 		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue-
 628               	.LM53:
 629 017e 3D83      		std Y+5,r19
 630 0180 2C83      		std Y+4,r18
 259:FreeRTOS/Source/queue.c **** 		pxQueue->cRxLock = queueUNLOCKED;
 632               	.LM54:
 633 0182 841B      		sub r24,r20
 634 0184 9109      		sbc r25,__zero_reg__
 635 0186 820F      		add r24,r18
 636 0188 931F      		adc r25,r19
 637 018a 9F83      		std Y+7,r25
 638 018c 8E83      		std Y+6,r24
 260:FreeRTOS/Source/queue.c **** 		pxQueue->cTxLock = queueUNLOCKED;
 640               	.LM55:
 641 018e 8FEF      		ldi r24,lo8(-1)
 642 0190 8D8F      		std Y+29,r24
 261:FreeRTOS/Source/queue.c **** 
 644               	.LM56:
 645 0192 8E8F      		std Y+30,r24
 263:FreeRTOS/Source/queue.c **** 		{
 647               	.LM57:
 648 0194 6111      		cpse r22,__zero_reg__
 649 0196 00C0      		rjmp .L42
 270:FreeRTOS/Source/queue.c **** 			{
 651               	.LM58:
 652 0198 8885      		ldd r24,Y+8
 653 019a 8823      		tst r24
 654 019c 01F0      		breq .L44
 272:FreeRTOS/Source/queue.c **** 				{
 656               	.LM59:
 657 019e CE01      		movw r24,r28
 658 01a0 0896      		adiw r24,8
 659 01a2 0E94 0000 		call xTaskRemoveFromEventList
 660 01a6 8823      		tst r24
 661 01a8 01F0      		breq .L44
 274:FreeRTOS/Source/queue.c **** 				}
 663               	.LM60:
 664 01aa 0E94 0000 		call vPortYield
 665 01ae 00C0      		rjmp .L44
 666               	.L42:
 289:FreeRTOS/Source/queue.c **** 			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 668               	.LM61:
 669 01b0 CE01      		movw r24,r28
 670 01b2 0896      		adiw r24,8
 671 01b4 0E94 0000 		call vListInitialise
 290:FreeRTOS/Source/queue.c **** 		}
 673               	.LM62:
 674 01b8 CE01      		movw r24,r28
 675 01ba 4196      		adiw r24,17
 676 01bc 0E94 0000 		call vListInitialise
 677               	.L44:
 293:FreeRTOS/Source/queue.c **** 
 679               	.LM63:
 680               	/* #APP */
 681               	 ;  293 "FreeRTOS/Source/queue.c" 1
 682 01c0 0F90      		pop		__tmp_reg__
 683               	 ;  0 "" 2
 684               	 ;  293 "FreeRTOS/Source/queue.c" 1
 685 01c2 0FBE      		out		__SREG__, __tmp_reg__
 686               	 ;  0 "" 2
 298:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 688               	.LM64:
 689               	/* #NOAPP */
 690 01c4 81E0      		ldi r24,lo8(1)
 691               	/* epilogue start */
 692 01c6 DF91      		pop r29
 693 01c8 CF91      		pop r28
 694 01ca 0895      		ret
 696               	.Lscope5:
 698               		.stabd	78,0,0
 703               	.global	xQueueGenericCreate
 705               	xQueueGenericCreate:
 706               		.stabd	46,0,0
 360:FreeRTOS/Source/queue.c **** 	Queue_t *pxNewQueue;
 708               	.LM65:
 709               	.LFBB6:
 710 01cc EF92      		push r14
 711 01ce FF92      		push r15
 712 01d0 1F93      		push r17
 713 01d2 CF93      		push r28
 714 01d4 DF93      		push r29
 715 01d6 1F92      		push __zero_reg__
 716 01d8 CDB7      		in r28,__SP_L__
 717 01da DEB7      		in r29,__SP_H__
 718               	/* prologue: function */
 719               	/* frame size = 1 */
 720               	/* stack size = 6 */
 721               	.L__stack_usage = 6
 722 01dc 182F      		mov r17,r24
 367:FreeRTOS/Source/queue.c **** 		{
 724               	.LM66:
 725 01de 6623      		tst r22
 726 01e0 01F0      		breq .L54
 376:FreeRTOS/Source/queue.c **** 		}
 728               	.LM67:
 729 01e2 869F      		mul r24,r22
 730 01e4 C001      		movw r24,r0
 731 01e6 1124      		clr __zero_reg__
 732 01e8 00C0      		rjmp .L50
 733               	.L54:
 370:FreeRTOS/Source/queue.c **** 		}
 735               	.LM68:
 736 01ea 80E0      		ldi r24,0
 737 01ec 90E0      		ldi r25,0
 738               	.L50:
 379:FreeRTOS/Source/queue.c **** 
 740               	.LM69:
 741 01ee 4F96      		adiw r24,31
 742 01f0 6983      		std Y+1,r22
 743 01f2 0E94 0000 		call pvPortMalloc
 744 01f6 7C01      		movw r14,r24
 381:FreeRTOS/Source/queue.c **** 		{
 746               	.LM70:
 747 01f8 6981      		ldd r22,Y+1
 748 01fa 0097      		sbiw r24,0
 749 01fc 01F0      		breq .L51
 750               	.LBB6:
 751               	.LBB7:
 415:FreeRTOS/Source/queue.c **** 	{
 753               	.LM71:
 754 01fe 6111      		cpse r22,__zero_reg__
 755 0200 00C0      		rjmp .L52
 421:FreeRTOS/Source/queue.c **** 	}
 757               	.LM72:
 758 0202 FC01      		movw r30,r24
 759 0204 9183      		std Z+1,r25
 760 0206 8083      		st Z,r24
 761 0208 00C0      		rjmp .L53
 762               	.L52:
 763               	.LBE7:
 764               	.LBE6:
 385:FreeRTOS/Source/queue.c **** 
 766               	.LM73:
 767 020a 4F96      		adiw r24,31
 768               	.LBB9:
 769               	.LBB8:
 426:FreeRTOS/Source/queue.c **** 	}
 771               	.LM74:
 772 020c F701      		movw r30,r14
 773 020e 9183      		std Z+1,r25
 774 0210 8083      		st Z,r24
 775               	.L53:
 431:FreeRTOS/Source/queue.c **** 	pxNewQueue->uxItemSize = uxItemSize;
 777               	.LM75:
 778 0212 F701      		movw r30,r14
 779 0214 138F      		std Z+27,r17
 432:FreeRTOS/Source/queue.c **** 	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 781               	.LM76:
 782 0216 648F      		std Z+28,r22
 433:FreeRTOS/Source/queue.c **** 
 784               	.LM77:
 785 0218 61E0      		ldi r22,lo8(1)
 786 021a C701      		movw r24,r14
 787 021c 0E94 0000 		call xQueueGenericReset
 788               	.L51:
 789               	.LBE8:
 790               	.LBE9:
 404:FreeRTOS/Source/queue.c **** 
 792               	.LM78:
 793 0220 C701      		movw r24,r14
 794               	/* epilogue start */
 795 0222 0F90      		pop __tmp_reg__
 796 0224 DF91      		pop r29
 797 0226 CF91      		pop r28
 798 0228 1F91      		pop r17
 799 022a FF90      		pop r15
 800 022c EF90      		pop r14
 801 022e 0895      		ret
 807               	.Lscope6:
 809               		.stabd	78,0,0
 815               	.global	xQueueGenericSend
 817               	xQueueGenericSend:
 818               		.stabd	46,0,0
 727:FreeRTOS/Source/queue.c **** BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
 820               	.LM79:
 821               	.LFBB7:
 822 0230 AF92      		push r10
 823 0232 BF92      		push r11
 824 0234 CF92      		push r12
 825 0236 DF92      		push r13
 826 0238 FF92      		push r15
 827 023a 0F93      		push r16
 828 023c 1F93      		push r17
 829 023e CF93      		push r28
 830 0240 DF93      		push r29
 831 0242 00D0      		rcall .
 832 0244 00D0      		rcall .
 833 0246 1F92      		push __zero_reg__
 834 0248 CDB7      		in r28,__SP_L__
 835 024a DEB7      		in r29,__SP_H__
 836               	/* prologue: function */
 837               	/* frame size = 5 */
 838               	/* stack size = 14 */
 839               	.L__stack_usage = 14
 840 024c 8C01      		movw r16,r24
 841 024e 6B01      		movw r12,r22
 842 0250 5D83      		std Y+5,r21
 843 0252 4C83      		std Y+4,r20
 844 0254 F22E      		mov r15,r18
 728:FreeRTOS/Source/queue.c **** TimeOut_t xTimeOut;
 846               	.LM80:
 847 0256 90E0      		ldi r25,0
 885:FreeRTOS/Source/queue.c **** 
 849               	.LM81:
 850 0258 5801      		movw r10,r16
 851 025a 88E0      		ldi r24,8
 852 025c A80E      		add r10,r24
 853 025e B11C      		adc r11,__zero_reg__
 854               	.L59:
 747:FreeRTOS/Source/queue.c **** 		{
 856               	.LM82:
 857               	/* #APP */
 858               	 ;  747 "FreeRTOS/Source/queue.c" 1
 859 0260 0FB6      		in		__tmp_reg__, __SREG__
 860               	 ;  0 "" 2
 861               	 ;  747 "FreeRTOS/Source/queue.c" 1
 862 0262 F894      		cli
 863               	 ;  0 "" 2
 864               	 ;  747 "FreeRTOS/Source/queue.c" 1
 865 0264 0F92      		push	__tmp_reg__
 866               	 ;  0 "" 2
 753:FreeRTOS/Source/queue.c **** 			{
 868               	.LM83:
 869               	/* #NOAPP */
 870 0266 F801      		movw r30,r16
 871 0268 228D      		ldd r18,Z+26
 872 026a 838D      		ldd r24,Z+27
 873 026c 2817      		cp r18,r24
 874 026e 00F0      		brlo .L60
 753:FreeRTOS/Source/queue.c **** 			{
 876               	.LM84:
 877 0270 F2E0      		ldi r31,lo8(2)
 878 0272 FF12      		cpse r15,r31
 879 0274 00C0      		rjmp .L61
 880               	.L60:
 756:FreeRTOS/Source/queue.c **** 
 882               	.LM85:
 883 0276 4F2D      		mov r20,r15
 884 0278 B601      		movw r22,r12
 885 027a C801      		movw r24,r16
 886 027c 0E94 0000 		call prvCopyDataToQueue
 811:FreeRTOS/Source/queue.c **** 					{
 888               	.LM86:
 889 0280 F801      		movw r30,r16
 890 0282 9189      		ldd r25,Z+17
 891 0284 9923      		tst r25
 892 0286 01F0      		breq .L74
 813:FreeRTOS/Source/queue.c **** 						{
 894               	.LM87:
 895 0288 C801      		movw r24,r16
 896 028a 4196      		adiw r24,17
 897 028c 0E94 0000 		call xTaskRemoveFromEventList
 898               	.L74:
 899 0290 8111      		cpse r24,__zero_reg__
 819:FreeRTOS/Source/queue.c **** 						}
 901               	.LM88:
 902 0292 0E94 0000 		call vPortYield
 903               	.L64:
 841:FreeRTOS/Source/queue.c **** 				return pdPASS;
 905               	.LM89:
 906               	/* #APP */
 907               	 ;  841 "FreeRTOS/Source/queue.c" 1
 908 0296 0F90      		pop		__tmp_reg__
 909               	 ;  0 "" 2
 910               	 ;  841 "FreeRTOS/Source/queue.c" 1
 911 0298 0FBE      		out		__SREG__, __tmp_reg__
 912               	 ;  0 "" 2
 842:FreeRTOS/Source/queue.c **** 			}
 914               	.LM90:
 915               	/* #NOAPP */
 916 029a 81E0      		ldi r24,lo8(1)
 917 029c 00C0      		rjmp .L66
 918               	.L61:
 846:FreeRTOS/Source/queue.c **** 				{
 920               	.LM91:
 921 029e 2C81      		ldd r18,Y+4
 922 02a0 3D81      		ldd r19,Y+5
 923 02a2 232B      		or r18,r19
 924 02a4 01F4      		brne .L67
 850:FreeRTOS/Source/queue.c **** 
 926               	.LM92:
 927               	/* #APP */
 928               	 ;  850 "FreeRTOS/Source/queue.c" 1
 929 02a6 0F90      		pop		__tmp_reg__
 930               	 ;  0 "" 2
 931               	 ;  850 "FreeRTOS/Source/queue.c" 1
 932 02a8 0FBE      		out		__SREG__, __tmp_reg__
 933               	 ;  0 "" 2
 934               	/* #NOAPP */
 935 02aa 00C0      		rjmp .L75
 936               	.L67:
 857:FreeRTOS/Source/queue.c **** 				{
 938               	.LM93:
 939 02ac 9111      		cpse r25,__zero_reg__
 940 02ae 00C0      		rjmp .L68
 861:FreeRTOS/Source/queue.c **** 					xEntryTimeSet = pdTRUE;
 942               	.LM94:
 943 02b0 CE01      		movw r24,r28
 944 02b2 0196      		adiw r24,1
 945 02b4 0E94 0000 		call vTaskInternalSetTimeOutState
 946               	.L68:
 871:FreeRTOS/Source/queue.c **** 
 948               	.LM95:
 949               	/* #APP */
 950               	 ;  871 "FreeRTOS/Source/queue.c" 1
 951 02b8 0F90      		pop		__tmp_reg__
 952               	 ;  0 "" 2
 953               	 ;  871 "FreeRTOS/Source/queue.c" 1
 954 02ba 0FBE      		out		__SREG__, __tmp_reg__
 955               	 ;  0 "" 2
 876:FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
 957               	.LM96:
 958               	/* #NOAPP */
 959 02bc 0E94 0000 		call vTaskSuspendAll
 877:FreeRTOS/Source/queue.c **** 
 961               	.LM97:
 962               	/* #APP */
 963               	 ;  877 "FreeRTOS/Source/queue.c" 1
 964 02c0 0FB6      		in		__tmp_reg__, __SREG__
 965               	 ;  0 "" 2
 966               	 ;  877 "FreeRTOS/Source/queue.c" 1
 967 02c2 F894      		cli
 968               	 ;  0 "" 2
 969               	 ;  877 "FreeRTOS/Source/queue.c" 1
 970 02c4 0F92      		push	__tmp_reg__
 971               	 ;  0 "" 2
 972               	/* #NOAPP */
 973 02c6 F801      		movw r30,r16
 974 02c8 858D      		ldd r24,Z+29
 975 02ca 8F3F      		cpi r24,lo8(-1)
 976 02cc 01F4      		brne .L69
 877:FreeRTOS/Source/queue.c **** 
 978               	.LM98:
 979 02ce 158E      		std Z+29,__zero_reg__
 980               	.L69:
 877:FreeRTOS/Source/queue.c **** 
 982               	.LM99:
 983 02d0 F801      		movw r30,r16
 984 02d2 868D      		ldd r24,Z+30
 985 02d4 8F3F      		cpi r24,lo8(-1)
 986 02d6 01F4      		brne .L70
 877:FreeRTOS/Source/queue.c **** 
 988               	.LM100:
 989 02d8 168E      		std Z+30,__zero_reg__
 990               	.L70:
 877:FreeRTOS/Source/queue.c **** 
 992               	.LM101:
 993               	/* #APP */
 994               	 ;  877 "FreeRTOS/Source/queue.c" 1
 995 02da 0F90      		pop		__tmp_reg__
 996               	 ;  0 "" 2
 997               	 ;  877 "FreeRTOS/Source/queue.c" 1
 998 02dc 0FBE      		out		__SREG__, __tmp_reg__
 999               	 ;  0 "" 2
 880:FreeRTOS/Source/queue.c **** 		{
 1001               	.LM102:
 1002               	/* #NOAPP */
 1003 02de BE01      		movw r22,r28
 1004 02e0 6C5F      		subi r22,-4
 1005 02e2 7F4F      		sbci r23,-1
 1006 02e4 CE01      		movw r24,r28
 1007 02e6 0196      		adiw r24,1
 1008 02e8 0E94 0000 		call xTaskCheckForTimeOut
 1009 02ec 8111      		cpse r24,__zero_reg__
 1010 02ee 00C0      		rjmp .L71
 1011               	.LBB12:
 1012               	.LBB13:
2277:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2278:FreeRTOS/Source/queue.c **** 
2279:FreeRTOS/Source/queue.c **** BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
2280:FreeRTOS/Source/queue.c **** {
2281:FreeRTOS/Source/queue.c **** BaseType_t xReturn;
2282:FreeRTOS/Source/queue.c **** 
2283:FreeRTOS/Source/queue.c **** 	configASSERT( xQueue );
2284:FreeRTOS/Source/queue.c **** 	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( UBaseType_t ) 0 )
2285:FreeRTOS/Source/queue.c **** 	{
2286:FreeRTOS/Source/queue.c **** 		xReturn = pdTRUE;
2287:FreeRTOS/Source/queue.c **** 	}
2288:FreeRTOS/Source/queue.c **** 	else
2289:FreeRTOS/Source/queue.c **** 	{
2290:FreeRTOS/Source/queue.c **** 		xReturn = pdFALSE;
2291:FreeRTOS/Source/queue.c **** 	}
2292:FreeRTOS/Source/queue.c **** 
2293:FreeRTOS/Source/queue.c **** 	return xReturn;
2294:FreeRTOS/Source/queue.c **** } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
2295:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2296:FreeRTOS/Source/queue.c **** 
2297:FreeRTOS/Source/queue.c **** static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
2298:FreeRTOS/Source/queue.c **** {
2299:FreeRTOS/Source/queue.c **** BaseType_t xReturn;
2300:FreeRTOS/Source/queue.c **** 
2301:FreeRTOS/Source/queue.c **** 	taskENTER_CRITICAL();
 1014               	.LM103:
 1015               	/* #APP */
 1016               	 ;  2301 "FreeRTOS/Source/queue.c" 1
 1017 02f0 0FB6      		in		__tmp_reg__, __SREG__
 1018               	 ;  0 "" 2
 1019               	 ;  2301 "FreeRTOS/Source/queue.c" 1
 1020 02f2 F894      		cli
 1021               	 ;  0 "" 2
 1022               	 ;  2301 "FreeRTOS/Source/queue.c" 1
 1023 02f4 0F92      		push	__tmp_reg__
 1024               	 ;  0 "" 2
2302:FreeRTOS/Source/queue.c **** 	{
2303:FreeRTOS/Source/queue.c **** 		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 1026               	.LM104:
 1027               	/* #NOAPP */
 1028 02f6 F801      		movw r30,r16
 1029 02f8 928D      		ldd r25,Z+26
2304:FreeRTOS/Source/queue.c **** 		{
2305:FreeRTOS/Source/queue.c **** 			xReturn = pdTRUE;
2306:FreeRTOS/Source/queue.c **** 		}
2307:FreeRTOS/Source/queue.c **** 		else
2308:FreeRTOS/Source/queue.c **** 		{
2309:FreeRTOS/Source/queue.c **** 			xReturn = pdFALSE;
2310:FreeRTOS/Source/queue.c **** 		}
2311:FreeRTOS/Source/queue.c **** 	}
2312:FreeRTOS/Source/queue.c **** 	taskEXIT_CRITICAL();
 1031               	.LM105:
 1032               	/* #APP */
 1033               	 ;  2312 "FreeRTOS/Source/queue.c" 1
 1034 02fa 0F90      		pop		__tmp_reg__
 1035               	 ;  0 "" 2
 1036               	 ;  2312 "FreeRTOS/Source/queue.c" 1
 1037 02fc 0FBE      		out		__SREG__, __tmp_reg__
 1038               	 ;  0 "" 2
 1039               	/* #NOAPP */
 1040               	.LBE13:
 1041               	.LBE12:
 882:FreeRTOS/Source/queue.c **** 			{
 1043               	.LM106:
 1044 02fe 838D      		ldd r24,Z+27
 1045 0300 9813      		cpse r25,r24
 1046 0302 00C0      		rjmp .L72
 885:FreeRTOS/Source/queue.c **** 
 1048               	.LM107:
 1049 0304 6C81      		ldd r22,Y+4
 1050 0306 7D81      		ldd r23,Y+5
 1051 0308 C501      		movw r24,r10
 1052 030a 0E94 0000 		call vTaskPlaceOnEventList
 892:FreeRTOS/Source/queue.c **** 
 1054               	.LM108:
 1055 030e C801      		movw r24,r16
 1056 0310 0E94 0000 		call prvUnlockQueue
 899:FreeRTOS/Source/queue.c **** 				{
 1058               	.LM109:
 1059 0314 0E94 0000 		call xTaskResumeAll
 1060 0318 8823      		tst r24
 1061 031a 01F0      		breq .L76
 1062               	.L73:
 1063 031c 91E0      		ldi r25,lo8(1)
 1064 031e 00C0      		rjmp .L59
 1065               	.L76:
 901:FreeRTOS/Source/queue.c **** 				}
 1067               	.LM110:
 1068 0320 0E94 0000 		call vPortYield
 1069 0324 00C0      		rjmp .L73
 1070               	.L72:
 907:FreeRTOS/Source/queue.c **** 				( void ) xTaskResumeAll();
 1072               	.LM111:
 1073 0326 C801      		movw r24,r16
 1074 0328 0E94 0000 		call prvUnlockQueue
 908:FreeRTOS/Source/queue.c **** 			}
 1076               	.LM112:
 1077 032c 0E94 0000 		call xTaskResumeAll
 1078 0330 00C0      		rjmp .L73
 1079               	.L71:
 914:FreeRTOS/Source/queue.c **** 			( void ) xTaskResumeAll();
 1081               	.LM113:
 1082 0332 C801      		movw r24,r16
 1083 0334 0E94 0000 		call prvUnlockQueue
 915:FreeRTOS/Source/queue.c **** 
 1085               	.LM114:
 1086 0338 0E94 0000 		call xTaskResumeAll
 1087               	.L75:
 918:FreeRTOS/Source/queue.c **** 		}
 1089               	.LM115:
 1090 033c 80E0      		ldi r24,0
 1091               	.L66:
 1092               	/* epilogue start */
 921:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 1094               	.LM116:
 1095 033e 0F90      		pop __tmp_reg__
 1096 0340 0F90      		pop __tmp_reg__
 1097 0342 0F90      		pop __tmp_reg__
 1098 0344 0F90      		pop __tmp_reg__
 1099 0346 0F90      		pop __tmp_reg__
 1100 0348 DF91      		pop r29
 1101 034a CF91      		pop r28
 1102 034c 1F91      		pop r17
 1103 034e 0F91      		pop r16
 1104 0350 FF90      		pop r15
 1105 0352 DF90      		pop r13
 1106 0354 CF90      		pop r12
 1107 0356 BF90      		pop r11
 1108 0358 AF90      		pop r10
 1109 035a 0895      		ret
 1116               	.Lscope7:
 1118               		.stabd	78,0,0
 1124               	.global	xQueueGenericSendFromISR
 1126               	xQueueGenericSendFromISR:
 1127               		.stabd	46,0,0
 925:FreeRTOS/Source/queue.c **** BaseType_t xReturn;
 1129               	.LM117:
 1130               	.LFBB8:
 1131 035c EF92      		push r14
 1132 035e FF92      		push r15
 1133 0360 1F93      		push r17
 1134 0362 CF93      		push r28
 1135 0364 DF93      		push r29
 1136               	/* prologue: function */
 1137               	/* frame size = 0 */
 1138               	/* stack size = 5 */
 1139               	.L__stack_usage = 5
 1140 0366 EC01      		movw r28,r24
 957:FreeRTOS/Source/queue.c **** 		{
 1142               	.LM118:
 1143 0368 9A8D      		ldd r25,Y+26
 1144 036a 8B8D      		ldd r24,Y+27
 1145 036c 9817      		cp r25,r24
 1146 036e 00F0      		brlo .L78
 957:FreeRTOS/Source/queue.c **** 		{
 1148               	.LM119:
 1149 0370 2230      		cpi r18,lo8(2)
 1150 0372 01F4      		brne .L83
 1151               	.L78:
 1152 0374 7A01      		movw r14,r20
 1153               	.LBB14:
 959:FreeRTOS/Source/queue.c **** 
 1155               	.LM120:
 1156 0376 1E8D      		ldd r17,Y+30
 968:FreeRTOS/Source/queue.c **** 
 1158               	.LM121:
 1159 0378 422F      		mov r20,r18
 1160 037a CE01      		movw r24,r28
 1161 037c 0E94 0000 		call prvCopyDataToQueue
 972:FreeRTOS/Source/queue.c **** 			{
 1163               	.LM122:
 1164 0380 1F3F      		cpi r17,lo8(-1)
 1165 0382 01F4      		brne .L80
1027:FreeRTOS/Source/queue.c **** 					{
 1167               	.LM123:
 1168 0384 8989      		ldd r24,Y+17
 1169 0386 8823      		tst r24
 1170 0388 01F0      		breq .L90
1029:FreeRTOS/Source/queue.c **** 						{
 1172               	.LM124:
 1173 038a CE01      		movw r24,r28
 1174 038c 4196      		adiw r24,17
 1175 038e 0E94 0000 		call xTaskRemoveFromEventList
 1176 0392 8823      		tst r24
 1177 0394 01F0      		breq .L90
1033:FreeRTOS/Source/queue.c **** 							{
 1179               	.LM125:
 1180 0396 E114      		cp r14,__zero_reg__
 1181 0398 F104      		cpc r15,__zero_reg__
 1182 039a 01F0      		breq .L90
1035:FreeRTOS/Source/queue.c **** 							}
 1184               	.LM126:
 1185 039c 81E0      		ldi r24,lo8(1)
 1186 039e F701      		movw r30,r14
 1187 03a0 8083      		st Z,r24
 1188 03a2 00C0      		rjmp .L79
 1189               	.L80:
1058:FreeRTOS/Source/queue.c **** 			}
 1191               	.LM127:
 1192 03a4 1F5F      		subi r17,lo8(-(1))
 1193 03a6 1E8F      		std Y+30,r17
 1194               	.L90:
1061:FreeRTOS/Source/queue.c **** 		}
 1196               	.LM128:
 1197 03a8 81E0      		ldi r24,lo8(1)
 1198 03aa 00C0      		rjmp .L79
 1199               	.L83:
 1200               	.LBE14:
1066:FreeRTOS/Source/queue.c **** 		}
 1202               	.LM129:
 1203 03ac 80E0      		ldi r24,0
 1204               	.L79:
 1205               	/* epilogue start */
1072:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 1207               	.LM130:
 1208 03ae DF91      		pop r29
 1209 03b0 CF91      		pop r28
 1210 03b2 1F91      		pop r17
 1211 03b4 FF90      		pop r15
 1212 03b6 EF90      		pop r14
 1213 03b8 0895      		ret
 1221               	.Lscope8:
 1223               		.stabd	78,0,0
 1227               	.global	xQueueGiveFromISR
 1229               	xQueueGiveFromISR:
 1230               		.stabd	46,0,0
1076:FreeRTOS/Source/queue.c **** BaseType_t xReturn;
 1232               	.LM131:
 1233               	.LFBB9:
 1234 03ba CF93      		push r28
 1235 03bc DF93      		push r29
 1236               	/* prologue: function */
 1237               	/* frame size = 0 */
 1238               	/* stack size = 2 */
 1239               	.L__stack_usage = 2
 1240 03be FC01      		movw r30,r24
 1241               	.LBB15:
1116:FreeRTOS/Source/queue.c **** 
 1243               	.LM132:
 1244 03c0 928D      		ldd r25,Z+26
1121:FreeRTOS/Source/queue.c **** 		{
 1246               	.LM133:
 1247 03c2 838D      		ldd r24,Z+27
 1248 03c4 9817      		cp r25,r24
 1249 03c6 00F4      		brsh .L96
 1250               	.LBB16:
1123:FreeRTOS/Source/queue.c **** 
 1252               	.LM134:
 1253 03c8 868D      		ldd r24,Z+30
1133:FreeRTOS/Source/queue.c **** 
 1255               	.LM135:
 1256 03ca 9F5F      		subi r25,lo8(-(1))
 1257 03cc 928F      		std Z+26,r25
1137:FreeRTOS/Source/queue.c **** 			{
 1259               	.LM136:
 1260 03ce 8F3F      		cpi r24,lo8(-1)
 1261 03d0 01F4      		brne .L93
1192:FreeRTOS/Source/queue.c **** 					{
 1263               	.LM137:
 1264 03d2 8189      		ldd r24,Z+17
 1265 03d4 8823      		tst r24
 1266 03d6 01F0      		breq .L103
 1267 03d8 EB01      		movw r28,r22
 1268 03da CF01      		movw r24,r30
1194:FreeRTOS/Source/queue.c **** 						{
 1270               	.LM138:
 1271 03dc 4196      		adiw r24,17
 1272 03de 0E94 0000 		call xTaskRemoveFromEventList
 1273 03e2 8823      		tst r24
 1274 03e4 01F0      		breq .L103
1198:FreeRTOS/Source/queue.c **** 							{
 1276               	.LM139:
 1277 03e6 2097      		sbiw r28,0
 1278 03e8 01F0      		breq .L103
1200:FreeRTOS/Source/queue.c **** 							}
 1280               	.LM140:
 1281 03ea 81E0      		ldi r24,lo8(1)
 1282 03ec 8883      		st Y,r24
 1283 03ee 00C0      		rjmp .L92
 1284               	.L93:
1223:FreeRTOS/Source/queue.c **** 			}
 1286               	.LM141:
 1287 03f0 8F5F      		subi r24,lo8(-(1))
 1288 03f2 868F      		std Z+30,r24
 1289               	.L103:
1226:FreeRTOS/Source/queue.c **** 		}
 1291               	.LM142:
 1292 03f4 81E0      		ldi r24,lo8(1)
 1293 03f6 00C0      		rjmp .L92
 1294               	.L96:
 1295               	.LBE16:
1231:FreeRTOS/Source/queue.c **** 		}
 1297               	.LM143:
 1298 03f8 80E0      		ldi r24,0
 1299               	.L92:
 1300               	/* epilogue start */
 1301               	.LBE15:
1237:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 1303               	.LM144:
 1304 03fa DF91      		pop r29
 1305 03fc CF91      		pop r28
 1306 03fe 0895      		ret
 1317               	.Lscope9:
 1319               		.stabd	78,0,0
 1324               	.global	xQueueReceive
 1326               	xQueueReceive:
 1327               		.stabd	46,0,0
1241:FreeRTOS/Source/queue.c **** BaseType_t xEntryTimeSet = pdFALSE;
 1329               	.LM145:
 1330               	.LFBB10:
 1331 0400 AF92      		push r10
 1332 0402 BF92      		push r11
 1333 0404 CF92      		push r12
 1334 0406 DF92      		push r13
 1335 0408 FF92      		push r15
 1336 040a 0F93      		push r16
 1337 040c 1F93      		push r17
 1338 040e CF93      		push r28
 1339 0410 DF93      		push r29
 1340 0412 00D0      		rcall .
 1341 0414 00D0      		rcall .
 1342 0416 1F92      		push __zero_reg__
 1343 0418 CDB7      		in r28,__SP_L__
 1344 041a DEB7      		in r29,__SP_H__
 1345               	/* prologue: function */
 1346               	/* frame size = 5 */
 1347               	/* stack size = 14 */
 1348               	.L__stack_usage = 14
 1349 041c 8C01      		movw r16,r24
 1350 041e 6B01      		movw r12,r22
 1351 0420 5D83      		std Y+5,r21
 1352 0422 4C83      		std Y+4,r20
1242:FreeRTOS/Source/queue.c **** TimeOut_t xTimeOut;
 1354               	.LM146:
 1355 0424 90E0      		ldi r25,0
1342:FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 1357               	.LM147:
 1358 0426 5801      		movw r10,r16
 1359 0428 81E1      		ldi r24,17
 1360 042a A80E      		add r10,r24
 1361 042c B11C      		adc r11,__zero_reg__
 1362               	.L105:
1267:FreeRTOS/Source/queue.c **** 		{
 1364               	.LM148:
 1365               	/* #APP */
 1366               	 ;  1267 "FreeRTOS/Source/queue.c" 1
 1367 042e 0FB6      		in		__tmp_reg__, __SREG__
 1368               	 ;  0 "" 2
 1369               	 ;  1267 "FreeRTOS/Source/queue.c" 1
 1370 0430 F894      		cli
 1371               	 ;  0 "" 2
 1372               	 ;  1267 "FreeRTOS/Source/queue.c" 1
 1373 0432 0F92      		push	__tmp_reg__
 1374               	 ;  0 "" 2
 1375               	/* #NOAPP */
 1376               	.LBB17:
1269:FreeRTOS/Source/queue.c **** 
 1378               	.LM149:
 1379 0434 F801      		movw r30,r16
 1380 0436 F28C      		ldd r15,Z+26
1273:FreeRTOS/Source/queue.c **** 			{
 1382               	.LM150:
 1383 0438 FF20      		tst r15
 1384 043a 01F0      		breq .L106
1276:FreeRTOS/Source/queue.c **** 				traceQUEUE_RECEIVE( pxQueue );
 1386               	.LM151:
 1387 043c B601      		movw r22,r12
 1388 043e C801      		movw r24,r16
 1389 0440 0E94 0000 		call prvCopyDataFromQueue
1278:FreeRTOS/Source/queue.c **** 
 1391               	.LM152:
 1392 0444 FA94      		dec r15
 1393 0446 F801      		movw r30,r16
 1394 0448 F28E      		std Z+26,r15
1283:FreeRTOS/Source/queue.c **** 				{
 1396               	.LM153:
 1397 044a 8085      		ldd r24,Z+8
 1398 044c 8823      		tst r24
 1399 044e 01F0      		breq .L108
1285:FreeRTOS/Source/queue.c **** 					{
 1401               	.LM154:
 1402 0450 C801      		movw r24,r16
 1403 0452 0896      		adiw r24,8
 1404 0454 0E94 0000 		call xTaskRemoveFromEventList
 1405 0458 8111      		cpse r24,__zero_reg__
1287:FreeRTOS/Source/queue.c **** 					}
 1407               	.LM155:
 1408 045a 0E94 0000 		call vPortYield
 1409               	.L108:
1299:FreeRTOS/Source/queue.c **** 				return pdPASS;
 1411               	.LM156:
 1412               	/* #APP */
 1413               	 ;  1299 "FreeRTOS/Source/queue.c" 1
 1414 045e 0F90      		pop		__tmp_reg__
 1415               	 ;  0 "" 2
 1416               	 ;  1299 "FreeRTOS/Source/queue.c" 1
 1417 0460 0FBE      		out		__SREG__, __tmp_reg__
 1418               	 ;  0 "" 2
1300:FreeRTOS/Source/queue.c **** 			}
 1420               	.LM157:
 1421               	/* #NOAPP */
 1422 0462 81E0      		ldi r24,lo8(1)
 1423 0464 00C0      		rjmp .L110
 1424               	.L106:
1304:FreeRTOS/Source/queue.c **** 				{
 1426               	.LM158:
 1427 0466 2C81      		ldd r18,Y+4
 1428 0468 3D81      		ldd r19,Y+5
 1429 046a 232B      		or r18,r19
 1430 046c 01F4      		brne .L111
1308:FreeRTOS/Source/queue.c **** 					traceQUEUE_RECEIVE_FAILED( pxQueue );
 1432               	.LM159:
 1433               	/* #APP */
 1434               	 ;  1308 "FreeRTOS/Source/queue.c" 1
 1435 046e 0F90      		pop		__tmp_reg__
 1436               	 ;  0 "" 2
 1437               	 ;  1308 "FreeRTOS/Source/queue.c" 1
 1438 0470 0FBE      		out		__SREG__, __tmp_reg__
 1439               	 ;  0 "" 2
 1440               	/* #NOAPP */
 1441 0472 00C0      		rjmp .L125
 1442               	.L111:
1312:FreeRTOS/Source/queue.c **** 				{
 1444               	.LM160:
 1445 0474 9111      		cpse r25,__zero_reg__
 1446 0476 00C0      		rjmp .L112
1316:FreeRTOS/Source/queue.c **** 					xEntryTimeSet = pdTRUE;
 1448               	.LM161:
 1449 0478 CE01      		movw r24,r28
 1450 047a 0196      		adiw r24,1
 1451 047c 0E94 0000 		call vTaskInternalSetTimeOutState
 1452               	.L112:
 1453               	.LBE17:
1326:FreeRTOS/Source/queue.c **** 
 1455               	.LM162:
 1456               	/* #APP */
 1457               	 ;  1326 "FreeRTOS/Source/queue.c" 1
 1458 0480 0F90      		pop		__tmp_reg__
 1459               	 ;  0 "" 2
 1460               	 ;  1326 "FreeRTOS/Source/queue.c" 1
 1461 0482 0FBE      		out		__SREG__, __tmp_reg__
 1462               	 ;  0 "" 2
1331:FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
 1464               	.LM163:
 1465               	/* #NOAPP */
 1466 0484 0E94 0000 		call vTaskSuspendAll
1332:FreeRTOS/Source/queue.c **** 
 1468               	.LM164:
 1469               	/* #APP */
 1470               	 ;  1332 "FreeRTOS/Source/queue.c" 1
 1471 0488 0FB6      		in		__tmp_reg__, __SREG__
 1472               	 ;  0 "" 2
 1473               	 ;  1332 "FreeRTOS/Source/queue.c" 1
 1474 048a F894      		cli
 1475               	 ;  0 "" 2
 1476               	 ;  1332 "FreeRTOS/Source/queue.c" 1
 1477 048c 0F92      		push	__tmp_reg__
 1478               	 ;  0 "" 2
 1479               	/* #NOAPP */
 1480 048e F801      		movw r30,r16
 1481 0490 858D      		ldd r24,Z+29
 1482 0492 8F3F      		cpi r24,lo8(-1)
 1483 0494 01F4      		brne .L113
1332:FreeRTOS/Source/queue.c **** 
 1485               	.LM165:
 1486 0496 158E      		std Z+29,__zero_reg__
 1487               	.L113:
1332:FreeRTOS/Source/queue.c **** 
 1489               	.LM166:
 1490 0498 F801      		movw r30,r16
 1491 049a 868D      		ldd r24,Z+30
 1492 049c 8F3F      		cpi r24,lo8(-1)
 1493 049e 01F4      		brne .L114
1332:FreeRTOS/Source/queue.c **** 
 1495               	.LM167:
 1496 04a0 168E      		std Z+30,__zero_reg__
 1497               	.L114:
1332:FreeRTOS/Source/queue.c **** 
 1499               	.LM168:
 1500               	/* #APP */
 1501               	 ;  1332 "FreeRTOS/Source/queue.c" 1
 1502 04a2 0F90      		pop		__tmp_reg__
 1503               	 ;  0 "" 2
 1504               	 ;  1332 "FreeRTOS/Source/queue.c" 1
 1505 04a4 0FBE      		out		__SREG__, __tmp_reg__
 1506               	 ;  0 "" 2
1335:FreeRTOS/Source/queue.c **** 		{
 1508               	.LM169:
 1509               	/* #NOAPP */
 1510 04a6 BE01      		movw r22,r28
 1511 04a8 6C5F      		subi r22,-4
 1512 04aa 7F4F      		sbci r23,-1
 1513 04ac CE01      		movw r24,r28
 1514 04ae 0196      		adiw r24,1
 1515 04b0 0E94 0000 		call xTaskCheckForTimeOut
 1516 04b4 8111      		cpse r24,__zero_reg__
 1517 04b6 00C0      		rjmp .L115
1339:FreeRTOS/Source/queue.c **** 			{
 1519               	.LM170:
 1520 04b8 C801      		movw r24,r16
 1521 04ba 0E94 0000 		call prvIsQueueEmpty
 1522 04be 8823      		tst r24
 1523 04c0 01F0      		breq .L116
1342:FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 1525               	.LM171:
 1526 04c2 6C81      		ldd r22,Y+4
 1527 04c4 7D81      		ldd r23,Y+5
 1528 04c6 C501      		movw r24,r10
 1529 04c8 0E94 0000 		call vTaskPlaceOnEventList
1343:FreeRTOS/Source/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 1531               	.LM172:
 1532 04cc C801      		movw r24,r16
 1533 04ce 0E94 0000 		call prvUnlockQueue
1344:FreeRTOS/Source/queue.c **** 				{
 1535               	.LM173:
 1536 04d2 0E94 0000 		call xTaskResumeAll
 1537 04d6 8823      		tst r24
 1538 04d8 01F0      		breq .L126
 1539               	.L118:
 1540 04da 91E0      		ldi r25,lo8(1)
 1541 04dc 00C0      		rjmp .L105
 1542               	.L126:
1346:FreeRTOS/Source/queue.c **** 				}
 1544               	.LM174:
 1545 04de 0E94 0000 		call vPortYield
 1546 04e2 00C0      		rjmp .L118
 1547               	.L116:
1357:FreeRTOS/Source/queue.c **** 				( void ) xTaskResumeAll();
 1549               	.LM175:
 1550 04e4 C801      		movw r24,r16
 1551 04e6 0E94 0000 		call prvUnlockQueue
1358:FreeRTOS/Source/queue.c **** 			}
 1553               	.LM176:
 1554 04ea 0E94 0000 		call xTaskResumeAll
 1555 04ee 00C0      		rjmp .L118
 1556               	.L115:
1365:FreeRTOS/Source/queue.c **** 			( void ) xTaskResumeAll();
 1558               	.LM177:
 1559 04f0 C801      		movw r24,r16
 1560 04f2 0E94 0000 		call prvUnlockQueue
1366:FreeRTOS/Source/queue.c **** 
 1562               	.LM178:
 1563 04f6 0E94 0000 		call xTaskResumeAll
1368:FreeRTOS/Source/queue.c **** 			{
 1565               	.LM179:
 1566 04fa C801      		movw r24,r16
 1567 04fc 0E94 0000 		call prvIsQueueEmpty
 1568 0500 8823      		tst r24
 1569 0502 01F0      		breq .L118
 1570               	.L125:
1371:FreeRTOS/Source/queue.c **** 			}
 1572               	.LM180:
 1573 0504 80E0      		ldi r24,0
 1574               	.L110:
 1575               	/* epilogue start */
1379:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 1577               	.LM181:
 1578 0506 0F90      		pop __tmp_reg__
 1579 0508 0F90      		pop __tmp_reg__
 1580 050a 0F90      		pop __tmp_reg__
 1581 050c 0F90      		pop __tmp_reg__
 1582 050e 0F90      		pop __tmp_reg__
 1583 0510 DF91      		pop r29
 1584 0512 CF91      		pop r28
 1585 0514 1F91      		pop r17
 1586 0516 0F91      		pop r16
 1587 0518 FF90      		pop r15
 1588 051a DF90      		pop r13
 1589 051c CF90      		pop r12
 1590 051e BF90      		pop r11
 1591 0520 AF90      		pop r10
 1592 0522 0895      		ret
 1601               	.Lscope10:
 1603               		.stabd	78,0,0
 1607               	.global	xQueueSemaphoreTake
 1609               	xQueueSemaphoreTake:
 1610               		.stabd	46,0,0
1383:FreeRTOS/Source/queue.c **** BaseType_t xEntryTimeSet = pdFALSE;
 1612               	.LM182:
 1613               	.LFBB11:
 1614 0524 EF92      		push r14
 1615 0526 FF92      		push r15
 1616 0528 0F93      		push r16
 1617 052a 1F93      		push r17
 1618 052c CF93      		push r28
 1619 052e DF93      		push r29
 1620 0530 00D0      		rcall .
 1621 0532 00D0      		rcall .
 1622 0534 1F92      		push __zero_reg__
 1623 0536 CDB7      		in r28,__SP_L__
 1624 0538 DEB7      		in r29,__SP_H__
 1625               	/* prologue: function */
 1626               	/* frame size = 5 */
 1627               	/* stack size = 11 */
 1628               	.L__stack_usage = 11
 1629 053a 8C01      		movw r16,r24
 1630 053c 7D83      		std Y+5,r23
 1631 053e 6C83      		std Y+4,r22
1384:FreeRTOS/Source/queue.c **** TimeOut_t xTimeOut;
 1633               	.LM183:
 1634 0540 20E0      		ldi r18,0
1534:FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 1636               	.LM184:
 1637 0542 7C01      		movw r14,r24
 1638 0544 81E1      		ldi r24,17
 1639 0546 E80E      		add r14,r24
 1640 0548 F11C      		adc r15,__zero_reg__
 1641               	.L128:
1413:FreeRTOS/Source/queue.c **** 		{
 1643               	.LM185:
 1644               	/* #APP */
 1645               	 ;  1413 "FreeRTOS/Source/queue.c" 1
 1646 054a 0FB6      		in		__tmp_reg__, __SREG__
 1647               	 ;  0 "" 2
 1648               	 ;  1413 "FreeRTOS/Source/queue.c" 1
 1649 054c F894      		cli
 1650               	 ;  0 "" 2
 1651               	 ;  1413 "FreeRTOS/Source/queue.c" 1
 1652 054e 0F92      		push	__tmp_reg__
 1653               	 ;  0 "" 2
 1654               	/* #NOAPP */
 1655               	.LBB18:
1417:FreeRTOS/Source/queue.c **** 
 1657               	.LM186:
 1658 0550 F801      		movw r30,r16
 1659 0552 928D      		ldd r25,Z+26
1421:FreeRTOS/Source/queue.c **** 			{
 1661               	.LM187:
 1662 0554 9923      		tst r25
 1663 0556 01F0      		breq .L129
1427:FreeRTOS/Source/queue.c **** 
 1665               	.LM188:
 1666 0558 9150      		subi r25,lo8(-(-1))
 1667 055a 928F      		std Z+26,r25
1446:FreeRTOS/Source/queue.c **** 				{
 1669               	.LM189:
 1670 055c 8085      		ldd r24,Z+8
 1671 055e 8823      		tst r24
 1672 0560 01F0      		breq .L131
1448:FreeRTOS/Source/queue.c **** 					{
 1674               	.LM190:
 1675 0562 C801      		movw r24,r16
 1676 0564 0896      		adiw r24,8
 1677 0566 0E94 0000 		call xTaskRemoveFromEventList
 1678 056a 8111      		cpse r24,__zero_reg__
1450:FreeRTOS/Source/queue.c **** 					}
 1680               	.LM191:
 1681 056c 0E94 0000 		call vPortYield
 1682               	.L131:
1462:FreeRTOS/Source/queue.c **** 				return pdPASS;
 1684               	.LM192:
 1685               	/* #APP */
 1686               	 ;  1462 "FreeRTOS/Source/queue.c" 1
 1687 0570 0F90      		pop		__tmp_reg__
 1688               	 ;  0 "" 2
 1689               	 ;  1462 "FreeRTOS/Source/queue.c" 1
 1690 0572 0FBE      		out		__SREG__, __tmp_reg__
 1691               	 ;  0 "" 2
1463:FreeRTOS/Source/queue.c **** 			}
 1693               	.LM193:
 1694               	/* #NOAPP */
 1695 0574 81E0      		ldi r24,lo8(1)
 1696 0576 00C0      		rjmp .L133
 1697               	.L129:
1467:FreeRTOS/Source/queue.c **** 				{
 1699               	.LM194:
 1700 0578 8C81      		ldd r24,Y+4
 1701 057a 9D81      		ldd r25,Y+5
 1702 057c 892B      		or r24,r25
 1703 057e 01F4      		brne .L134
1480:FreeRTOS/Source/queue.c **** 					traceQUEUE_RECEIVE_FAILED( pxQueue );
 1705               	.LM195:
 1706               	/* #APP */
 1707               	 ;  1480 "FreeRTOS/Source/queue.c" 1
 1708 0580 0F90      		pop		__tmp_reg__
 1709               	 ;  0 "" 2
 1710               	 ;  1480 "FreeRTOS/Source/queue.c" 1
 1711 0582 0FBE      		out		__SREG__, __tmp_reg__
 1712               	 ;  0 "" 2
 1713               	/* #NOAPP */
 1714 0584 00C0      		rjmp .L148
 1715               	.L134:
1484:FreeRTOS/Source/queue.c **** 				{
 1717               	.LM196:
 1718 0586 2111      		cpse r18,__zero_reg__
 1719 0588 00C0      		rjmp .L135
1488:FreeRTOS/Source/queue.c **** 					xEntryTimeSet = pdTRUE;
 1721               	.LM197:
 1722 058a CE01      		movw r24,r28
 1723 058c 0196      		adiw r24,1
 1724 058e 0E94 0000 		call vTaskInternalSetTimeOutState
 1725               	.L135:
 1726               	.LBE18:
1498:FreeRTOS/Source/queue.c **** 
 1728               	.LM198:
 1729               	/* #APP */
 1730               	 ;  1498 "FreeRTOS/Source/queue.c" 1
 1731 0592 0F90      		pop		__tmp_reg__
 1732               	 ;  0 "" 2
 1733               	 ;  1498 "FreeRTOS/Source/queue.c" 1
 1734 0594 0FBE      		out		__SREG__, __tmp_reg__
 1735               	 ;  0 "" 2
1503:FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
 1737               	.LM199:
 1738               	/* #NOAPP */
 1739 0596 0E94 0000 		call vTaskSuspendAll
1504:FreeRTOS/Source/queue.c **** 
 1741               	.LM200:
 1742               	/* #APP */
 1743               	 ;  1504 "FreeRTOS/Source/queue.c" 1
 1744 059a 0FB6      		in		__tmp_reg__, __SREG__
 1745               	 ;  0 "" 2
 1746               	 ;  1504 "FreeRTOS/Source/queue.c" 1
 1747 059c F894      		cli
 1748               	 ;  0 "" 2
 1749               	 ;  1504 "FreeRTOS/Source/queue.c" 1
 1750 059e 0F92      		push	__tmp_reg__
 1751               	 ;  0 "" 2
 1752               	/* #NOAPP */
 1753 05a0 F801      		movw r30,r16
 1754 05a2 858D      		ldd r24,Z+29
 1755 05a4 8F3F      		cpi r24,lo8(-1)
 1756 05a6 01F4      		brne .L136
1504:FreeRTOS/Source/queue.c **** 
 1758               	.LM201:
 1759 05a8 158E      		std Z+29,__zero_reg__
 1760               	.L136:
1504:FreeRTOS/Source/queue.c **** 
 1762               	.LM202:
 1763 05aa F801      		movw r30,r16
 1764 05ac 868D      		ldd r24,Z+30
 1765 05ae 8F3F      		cpi r24,lo8(-1)
 1766 05b0 01F4      		brne .L137
1504:FreeRTOS/Source/queue.c **** 
 1768               	.LM203:
 1769 05b2 168E      		std Z+30,__zero_reg__
 1770               	.L137:
1504:FreeRTOS/Source/queue.c **** 
 1772               	.LM204:
 1773               	/* #APP */
 1774               	 ;  1504 "FreeRTOS/Source/queue.c" 1
 1775 05b4 0F90      		pop		__tmp_reg__
 1776               	 ;  0 "" 2
 1777               	 ;  1504 "FreeRTOS/Source/queue.c" 1
 1778 05b6 0FBE      		out		__SREG__, __tmp_reg__
 1779               	 ;  0 "" 2
1507:FreeRTOS/Source/queue.c **** 		{
 1781               	.LM205:
 1782               	/* #NOAPP */
 1783 05b8 BE01      		movw r22,r28
 1784 05ba 6C5F      		subi r22,-4
 1785 05bc 7F4F      		sbci r23,-1
 1786 05be CE01      		movw r24,r28
 1787 05c0 0196      		adiw r24,1
 1788 05c2 0E94 0000 		call xTaskCheckForTimeOut
 1789 05c6 8111      		cpse r24,__zero_reg__
 1790 05c8 00C0      		rjmp .L138
1513:FreeRTOS/Source/queue.c **** 			{
 1792               	.LM206:
 1793 05ca C801      		movw r24,r16
 1794 05cc 0E94 0000 		call prvIsQueueEmpty
 1795 05d0 8823      		tst r24
 1796 05d2 01F0      		breq .L139
1534:FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 1798               	.LM207:
 1799 05d4 6C81      		ldd r22,Y+4
 1800 05d6 7D81      		ldd r23,Y+5
 1801 05d8 C701      		movw r24,r14
 1802 05da 0E94 0000 		call vTaskPlaceOnEventList
1535:FreeRTOS/Source/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 1804               	.LM208:
 1805 05de C801      		movw r24,r16
 1806 05e0 0E94 0000 		call prvUnlockQueue
1536:FreeRTOS/Source/queue.c **** 				{
 1808               	.LM209:
 1809 05e4 0E94 0000 		call xTaskResumeAll
 1810 05e8 8823      		tst r24
 1811 05ea 01F0      		breq .L149
 1812               	.L141:
 1813 05ec 21E0      		ldi r18,lo8(1)
 1814 05ee 00C0      		rjmp .L128
 1815               	.L149:
1538:FreeRTOS/Source/queue.c **** 				}
 1817               	.LM210:
 1818 05f0 0E94 0000 		call vPortYield
 1819 05f4 00C0      		rjmp .L141
 1820               	.L139:
1549:FreeRTOS/Source/queue.c **** 				( void ) xTaskResumeAll();
 1822               	.LM211:
 1823 05f6 C801      		movw r24,r16
 1824 05f8 0E94 0000 		call prvUnlockQueue
1550:FreeRTOS/Source/queue.c **** 			}
 1826               	.LM212:
 1827 05fc 0E94 0000 		call xTaskResumeAll
 1828 0600 00C0      		rjmp .L141
 1829               	.L138:
1556:FreeRTOS/Source/queue.c **** 			( void ) xTaskResumeAll();
 1831               	.LM213:
 1832 0602 C801      		movw r24,r16
 1833 0604 0E94 0000 		call prvUnlockQueue
1557:FreeRTOS/Source/queue.c **** 
 1835               	.LM214:
 1836 0608 0E94 0000 		call xTaskResumeAll
1563:FreeRTOS/Source/queue.c **** 			{
 1838               	.LM215:
 1839 060c C801      		movw r24,r16
 1840 060e 0E94 0000 		call prvIsQueueEmpty
 1841 0612 8823      		tst r24
 1842 0614 01F0      		breq .L141
 1843               	.L148:
1590:FreeRTOS/Source/queue.c **** 			}
 1845               	.LM216:
 1846 0616 80E0      		ldi r24,0
 1847               	.L133:
 1848               	/* epilogue start */
1598:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 1850               	.LM217:
 1851 0618 0F90      		pop __tmp_reg__
 1852 061a 0F90      		pop __tmp_reg__
 1853 061c 0F90      		pop __tmp_reg__
 1854 061e 0F90      		pop __tmp_reg__
 1855 0620 0F90      		pop __tmp_reg__
 1856 0622 DF91      		pop r29
 1857 0624 CF91      		pop r28
 1858 0626 1F91      		pop r17
 1859 0628 0F91      		pop r16
 1860 062a FF90      		pop r15
 1861 062c EF90      		pop r14
 1862 062e 0895      		ret
 1871               	.Lscope11:
 1873               		.stabd	78,0,0
 1878               	.global	xQueuePeek
 1880               	xQueuePeek:
 1881               		.stabd	46,0,0
1602:FreeRTOS/Source/queue.c **** BaseType_t xEntryTimeSet = pdFALSE;
 1883               	.LM218:
 1884               	.LFBB12:
 1885 0630 CF92      		push r12
 1886 0632 DF92      		push r13
 1887 0634 EF92      		push r14
 1888 0636 FF92      		push r15
 1889 0638 0F93      		push r16
 1890 063a 1F93      		push r17
 1891 063c CF93      		push r28
 1892 063e DF93      		push r29
 1893 0640 00D0      		rcall .
 1894 0642 00D0      		rcall .
 1895 0644 1F92      		push __zero_reg__
 1896 0646 CDB7      		in r28,__SP_L__
 1897 0648 DEB7      		in r29,__SP_H__
 1898               	/* prologue: function */
 1899               	/* frame size = 5 */
 1900               	/* stack size = 13 */
 1901               	.L__stack_usage = 13
 1902 064a 8C01      		movw r16,r24
 1903 064c 7B01      		movw r14,r22
 1904 064e 5D83      		std Y+5,r21
 1905 0650 4C83      		std Y+4,r20
1603:FreeRTOS/Source/queue.c **** TimeOut_t xTimeOut;
 1907               	.LM219:
 1908 0652 90E0      		ldi r25,0
1711:FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 1910               	.LM220:
 1911 0654 6801      		movw r12,r16
 1912 0656 81E1      		ldi r24,17
 1913 0658 C80E      		add r12,r24
 1914 065a D11C      		adc r13,__zero_reg__
 1915               	.L151:
1629:FreeRTOS/Source/queue.c **** 		{
 1917               	.LM221:
 1918               	/* #APP */
 1919               	 ;  1629 "FreeRTOS/Source/queue.c" 1
 1920 065c 0FB6      		in		__tmp_reg__, __SREG__
 1921               	 ;  0 "" 2
 1922               	 ;  1629 "FreeRTOS/Source/queue.c" 1
 1923 065e F894      		cli
 1924               	 ;  0 "" 2
 1925               	 ;  1629 "FreeRTOS/Source/queue.c" 1
 1926 0660 0F92      		push	__tmp_reg__
 1927               	 ;  0 "" 2
 1928               	/* #NOAPP */
 1929               	.LBB19:
1631:FreeRTOS/Source/queue.c **** 
 1931               	.LM222:
 1932 0662 F801      		movw r30,r16
 1933 0664 828D      		ldd r24,Z+26
1635:FreeRTOS/Source/queue.c **** 			{
 1935               	.LM223:
 1936 0666 8823      		tst r24
 1937 0668 01F0      		breq .L152
1640:FreeRTOS/Source/queue.c **** 
 1939               	.LM224:
 1940 066a C680      		ldd r12,Z+6
 1941 066c D780      		ldd r13,Z+7
1642:FreeRTOS/Source/queue.c **** 				traceQUEUE_PEEK( pxQueue );
 1943               	.LM225:
 1944 066e B701      		movw r22,r14
 1945 0670 C801      		movw r24,r16
 1946 0672 0E94 0000 		call prvCopyDataFromQueue
1646:FreeRTOS/Source/queue.c **** 
 1948               	.LM226:
 1949 0676 F801      		movw r30,r16
 1950 0678 D782      		std Z+7,r13
 1951 067a C682      		std Z+6,r12
1650:FreeRTOS/Source/queue.c **** 				{
 1953               	.LM227:
 1954 067c 8189      		ldd r24,Z+17
 1955 067e 8823      		tst r24
 1956 0680 01F0      		breq .L154
1652:FreeRTOS/Source/queue.c **** 					{
 1958               	.LM228:
 1959 0682 C801      		movw r24,r16
 1960 0684 4196      		adiw r24,17
 1961 0686 0E94 0000 		call xTaskRemoveFromEventList
 1962 068a 8111      		cpse r24,__zero_reg__
1655:FreeRTOS/Source/queue.c **** 					}
 1964               	.LM229:
 1965 068c 0E94 0000 		call vPortYield
 1966               	.L154:
1667:FreeRTOS/Source/queue.c **** 				return pdPASS;
 1968               	.LM230:
 1969               	/* #APP */
 1970               	 ;  1667 "FreeRTOS/Source/queue.c" 1
 1971 0690 0F90      		pop		__tmp_reg__
 1972               	 ;  0 "" 2
 1973               	 ;  1667 "FreeRTOS/Source/queue.c" 1
 1974 0692 0FBE      		out		__SREG__, __tmp_reg__
 1975               	 ;  0 "" 2
1668:FreeRTOS/Source/queue.c **** 			}
 1977               	.LM231:
 1978               	/* #NOAPP */
 1979 0694 81E0      		ldi r24,lo8(1)
 1980 0696 00C0      		rjmp .L156
 1981               	.L152:
1672:FreeRTOS/Source/queue.c **** 				{
 1983               	.LM232:
 1984 0698 2C81      		ldd r18,Y+4
 1985 069a 3D81      		ldd r19,Y+5
 1986 069c 232B      		or r18,r19
 1987 069e 01F4      		brne .L157
1676:FreeRTOS/Source/queue.c **** 					traceQUEUE_PEEK_FAILED( pxQueue );
 1989               	.LM233:
 1990               	/* #APP */
 1991               	 ;  1676 "FreeRTOS/Source/queue.c" 1
 1992 06a0 0F90      		pop		__tmp_reg__
 1993               	 ;  0 "" 2
 1994               	 ;  1676 "FreeRTOS/Source/queue.c" 1
 1995 06a2 0FBE      		out		__SREG__, __tmp_reg__
 1996               	 ;  0 "" 2
 1997               	/* #NOAPP */
 1998 06a4 00C0      		rjmp .L171
 1999               	.L157:
1680:FreeRTOS/Source/queue.c **** 				{
 2001               	.LM234:
 2002 06a6 9111      		cpse r25,__zero_reg__
 2003 06a8 00C0      		rjmp .L158
1685:FreeRTOS/Source/queue.c **** 					xEntryTimeSet = pdTRUE;
 2005               	.LM235:
 2006 06aa CE01      		movw r24,r28
 2007 06ac 0196      		adiw r24,1
 2008 06ae 0E94 0000 		call vTaskInternalSetTimeOutState
 2009               	.L158:
 2010               	.LBE19:
1695:FreeRTOS/Source/queue.c **** 
 2012               	.LM236:
 2013               	/* #APP */
 2014               	 ;  1695 "FreeRTOS/Source/queue.c" 1
 2015 06b2 0F90      		pop		__tmp_reg__
 2016               	 ;  0 "" 2
 2017               	 ;  1695 "FreeRTOS/Source/queue.c" 1
 2018 06b4 0FBE      		out		__SREG__, __tmp_reg__
 2019               	 ;  0 "" 2
1700:FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
 2021               	.LM237:
 2022               	/* #NOAPP */
 2023 06b6 0E94 0000 		call vTaskSuspendAll
1701:FreeRTOS/Source/queue.c **** 
 2025               	.LM238:
 2026               	/* #APP */
 2027               	 ;  1701 "FreeRTOS/Source/queue.c" 1
 2028 06ba 0FB6      		in		__tmp_reg__, __SREG__
 2029               	 ;  0 "" 2
 2030               	 ;  1701 "FreeRTOS/Source/queue.c" 1
 2031 06bc F894      		cli
 2032               	 ;  0 "" 2
 2033               	 ;  1701 "FreeRTOS/Source/queue.c" 1
 2034 06be 0F92      		push	__tmp_reg__
 2035               	 ;  0 "" 2
 2036               	/* #NOAPP */
 2037 06c0 F801      		movw r30,r16
 2038 06c2 858D      		ldd r24,Z+29
 2039 06c4 8F3F      		cpi r24,lo8(-1)
 2040 06c6 01F4      		brne .L159
1701:FreeRTOS/Source/queue.c **** 
 2042               	.LM239:
 2043 06c8 158E      		std Z+29,__zero_reg__
 2044               	.L159:
1701:FreeRTOS/Source/queue.c **** 
 2046               	.LM240:
 2047 06ca F801      		movw r30,r16
 2048 06cc 868D      		ldd r24,Z+30
 2049 06ce 8F3F      		cpi r24,lo8(-1)
 2050 06d0 01F4      		brne .L160
1701:FreeRTOS/Source/queue.c **** 
 2052               	.LM241:
 2053 06d2 168E      		std Z+30,__zero_reg__
 2054               	.L160:
1701:FreeRTOS/Source/queue.c **** 
 2056               	.LM242:
 2057               	/* #APP */
 2058               	 ;  1701 "FreeRTOS/Source/queue.c" 1
 2059 06d4 0F90      		pop		__tmp_reg__
 2060               	 ;  0 "" 2
 2061               	 ;  1701 "FreeRTOS/Source/queue.c" 1
 2062 06d6 0FBE      		out		__SREG__, __tmp_reg__
 2063               	 ;  0 "" 2
1704:FreeRTOS/Source/queue.c **** 		{
 2065               	.LM243:
 2066               	/* #NOAPP */
 2067 06d8 BE01      		movw r22,r28
 2068 06da 6C5F      		subi r22,-4
 2069 06dc 7F4F      		sbci r23,-1
 2070 06de CE01      		movw r24,r28
 2071 06e0 0196      		adiw r24,1
 2072 06e2 0E94 0000 		call xTaskCheckForTimeOut
 2073 06e6 8111      		cpse r24,__zero_reg__
 2074 06e8 00C0      		rjmp .L161
1708:FreeRTOS/Source/queue.c **** 			{
 2076               	.LM244:
 2077 06ea C801      		movw r24,r16
 2078 06ec 0E94 0000 		call prvIsQueueEmpty
 2079 06f0 8823      		tst r24
 2080 06f2 01F0      		breq .L162
1711:FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 2082               	.LM245:
 2083 06f4 6C81      		ldd r22,Y+4
 2084 06f6 7D81      		ldd r23,Y+5
 2085 06f8 C601      		movw r24,r12
 2086 06fa 0E94 0000 		call vTaskPlaceOnEventList
1712:FreeRTOS/Source/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 2088               	.LM246:
 2089 06fe C801      		movw r24,r16
 2090 0700 0E94 0000 		call prvUnlockQueue
1713:FreeRTOS/Source/queue.c **** 				{
 2092               	.LM247:
 2093 0704 0E94 0000 		call xTaskResumeAll
 2094 0708 8823      		tst r24
 2095 070a 01F0      		breq .L172
 2096               	.L164:
 2097 070c 91E0      		ldi r25,lo8(1)
 2098 070e 00C0      		rjmp .L151
 2099               	.L172:
1715:FreeRTOS/Source/queue.c **** 				}
 2101               	.LM248:
 2102 0710 0E94 0000 		call vPortYield
 2103 0714 00C0      		rjmp .L164
 2104               	.L162:
1726:FreeRTOS/Source/queue.c **** 				( void ) xTaskResumeAll();
 2106               	.LM249:
 2107 0716 C801      		movw r24,r16
 2108 0718 0E94 0000 		call prvUnlockQueue
1727:FreeRTOS/Source/queue.c **** 			}
 2110               	.LM250:
 2111 071c 0E94 0000 		call xTaskResumeAll
 2112 0720 00C0      		rjmp .L164
 2113               	.L161:
1734:FreeRTOS/Source/queue.c **** 			( void ) xTaskResumeAll();
 2115               	.LM251:
 2116 0722 C801      		movw r24,r16
 2117 0724 0E94 0000 		call prvUnlockQueue
1735:FreeRTOS/Source/queue.c **** 
 2119               	.LM252:
 2120 0728 0E94 0000 		call xTaskResumeAll
1737:FreeRTOS/Source/queue.c **** 			{
 2122               	.LM253:
 2123 072c C801      		movw r24,r16
 2124 072e 0E94 0000 		call prvIsQueueEmpty
 2125 0732 8823      		tst r24
 2126 0734 01F0      		breq .L164
 2127               	.L171:
1740:FreeRTOS/Source/queue.c **** 			}
 2129               	.LM254:
 2130 0736 80E0      		ldi r24,0
 2131               	.L156:
 2132               	/* epilogue start */
1748:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 2134               	.LM255:
 2135 0738 0F90      		pop __tmp_reg__
 2136 073a 0F90      		pop __tmp_reg__
 2137 073c 0F90      		pop __tmp_reg__
 2138 073e 0F90      		pop __tmp_reg__
 2139 0740 0F90      		pop __tmp_reg__
 2140 0742 DF91      		pop r29
 2141 0744 CF91      		pop r28
 2142 0746 1F91      		pop r17
 2143 0748 0F91      		pop r16
 2144 074a FF90      		pop r15
 2145 074c EF90      		pop r14
 2146 074e DF90      		pop r13
 2147 0750 CF90      		pop r12
 2148 0752 0895      		ret
 2158               	.Lscope12:
 2160               		.stabd	78,0,0
 2165               	.global	xQueueReceiveFromISR
 2167               	xQueueReceiveFromISR:
 2168               		.stabd	46,0,0
1752:FreeRTOS/Source/queue.c **** BaseType_t xReturn;
 2170               	.LM256:
 2171               	.LFBB13:
 2172 0754 EF92      		push r14
 2173 0756 FF92      		push r15
 2174 0758 0F93      		push r16
 2175 075a 1F93      		push r17
 2176 075c CF93      		push r28
 2177 075e DF93      		push r29
 2178               	/* prologue: function */
 2179               	/* frame size = 0 */
 2180               	/* stack size = 6 */
 2181               	.L__stack_usage = 6
 2182               	.LBB20:
1778:FreeRTOS/Source/queue.c **** 
 2184               	.LM257:
 2185 0760 FC01      		movw r30,r24
 2186 0762 028D      		ldd r16,Z+26
1781:FreeRTOS/Source/queue.c **** 		{
 2188               	.LM258:
 2189 0764 0023      		tst r16
 2190 0766 01F0      		breq .L178
 2191 0768 7A01      		movw r14,r20
 2192 076a EC01      		movw r28,r24
 2193               	.LBB21:
1783:FreeRTOS/Source/queue.c **** 
 2195               	.LM259:
 2196 076c 158D      		ldd r17,Z+29
1787:FreeRTOS/Source/queue.c **** 			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 2198               	.LM260:
 2199 076e 0E94 0000 		call prvCopyDataFromQueue
1788:FreeRTOS/Source/queue.c **** 
 2201               	.LM261:
 2202 0772 0150      		subi r16,lo8(-(-1))
 2203 0774 0A8F      		std Y+26,r16
1794:FreeRTOS/Source/queue.c **** 			{
 2205               	.LM262:
 2206 0776 1F3F      		cpi r17,lo8(-1)
 2207 0778 01F4      		brne .L175
1796:FreeRTOS/Source/queue.c **** 				{
 2209               	.LM263:
 2210 077a 8885      		ldd r24,Y+8
 2211 077c 8823      		tst r24
 2212 077e 01F0      		breq .L185
1798:FreeRTOS/Source/queue.c **** 					{
 2214               	.LM264:
 2215 0780 CE01      		movw r24,r28
 2216 0782 0896      		adiw r24,8
 2217 0784 0E94 0000 		call xTaskRemoveFromEventList
 2218 0788 8823      		tst r24
 2219 078a 01F0      		breq .L185
1802:FreeRTOS/Source/queue.c **** 						{
 2221               	.LM265:
 2222 078c E114      		cp r14,__zero_reg__
 2223 078e F104      		cpc r15,__zero_reg__
 2224 0790 01F0      		breq .L185
1804:FreeRTOS/Source/queue.c **** 						}
 2226               	.LM266:
 2227 0792 81E0      		ldi r24,lo8(1)
 2228 0794 F701      		movw r30,r14
 2229 0796 8083      		st Z,r24
 2230 0798 00C0      		rjmp .L174
 2231               	.L175:
1825:FreeRTOS/Source/queue.c **** 			}
 2233               	.LM267:
 2234 079a 1F5F      		subi r17,lo8(-(1))
 2235 079c 1D8F      		std Y+29,r17
 2236               	.L185:
1828:FreeRTOS/Source/queue.c **** 		}
 2238               	.LM268:
 2239 079e 81E0      		ldi r24,lo8(1)
 2240 07a0 00C0      		rjmp .L174
 2241               	.L178:
 2242               	.LBE21:
1832:FreeRTOS/Source/queue.c **** 			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
 2244               	.LM269:
 2245 07a2 80E0      		ldi r24,0
 2246               	.L174:
 2247               	/* epilogue start */
 2248               	.LBE20:
1839:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 2250               	.LM270:
 2251 07a4 DF91      		pop r29
 2252 07a6 CF91      		pop r28
 2253 07a8 1F91      		pop r17
 2254 07aa 0F91      		pop r16
 2255 07ac FF90      		pop r15
 2256 07ae EF90      		pop r14
 2257 07b0 0895      		ret
 2268               	.Lscope13:
 2270               		.stabd	78,0,0
 2274               	.global	xQueuePeekFromISR
 2276               	xQueuePeekFromISR:
 2277               		.stabd	46,0,0
1843:FreeRTOS/Source/queue.c **** BaseType_t xReturn;
 2279               	.LM271:
 2280               	.LFBB14:
 2281 07b2 0F93      		push r16
 2282 07b4 1F93      		push r17
 2283 07b6 CF93      		push r28
 2284 07b8 DF93      		push r29
 2285               	/* prologue: function */
 2286               	/* frame size = 0 */
 2287               	/* stack size = 4 */
 2288               	.L__stack_usage = 4
1872:FreeRTOS/Source/queue.c **** 		{
 2290               	.LM272:
 2291 07ba FC01      		movw r30,r24
 2292 07bc 228D      		ldd r18,Z+26
 2293 07be 2223      		tst r18
 2294 07c0 01F0      		breq .L188
 2295 07c2 EC01      		movw r28,r24
1878:FreeRTOS/Source/queue.c **** 			prvCopyDataFromQueue( pxQueue, pvBuffer );
 2297               	.LM273:
 2298 07c4 0681      		ldd r16,Z+6
 2299 07c6 1781      		ldd r17,Z+7
1879:FreeRTOS/Source/queue.c **** 			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
 2301               	.LM274:
 2302 07c8 0E94 0000 		call prvCopyDataFromQueue
1880:FreeRTOS/Source/queue.c **** 
 2304               	.LM275:
 2305 07cc 1F83      		std Y+7,r17
 2306 07ce 0E83      		std Y+6,r16
1882:FreeRTOS/Source/queue.c **** 		}
 2308               	.LM276:
 2309 07d0 81E0      		ldi r24,lo8(1)
 2310 07d2 00C0      		rjmp .L187
 2311               	.L188:
1886:FreeRTOS/Source/queue.c **** 			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
 2313               	.LM277:
 2314 07d4 80E0      		ldi r24,0
 2315               	.L187:
 2316               	/* epilogue start */
1893:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 2318               	.LM278:
 2319 07d6 DF91      		pop r29
 2320 07d8 CF91      		pop r28
 2321 07da 1F91      		pop r17
 2322 07dc 0F91      		pop r16
 2323 07de 0895      		ret
 2329               	.Lscope14:
 2331               		.stabd	78,0,0
 2334               	.global	uxQueueMessagesWaiting
 2336               	uxQueueMessagesWaiting:
 2337               		.stabd	46,0,0
1897:FreeRTOS/Source/queue.c **** UBaseType_t uxReturn;
 2339               	.LM279:
 2340               	.LFBB15:
 2341               	/* prologue: function */
 2342               	/* frame size = 0 */
 2343               	/* stack size = 0 */
 2344               	.L__stack_usage = 0
1902:FreeRTOS/Source/queue.c **** 	{
 2346               	.LM280:
 2347               	/* #APP */
 2348               	 ;  1902 "FreeRTOS/Source/queue.c" 1
 2349 07e0 0FB6      		in		__tmp_reg__, __SREG__
 2350               	 ;  0 "" 2
 2351               	 ;  1902 "FreeRTOS/Source/queue.c" 1
 2352 07e2 F894      		cli
 2353               	 ;  0 "" 2
 2354               	 ;  1902 "FreeRTOS/Source/queue.c" 1
 2355 07e4 0F92      		push	__tmp_reg__
 2356               	 ;  0 "" 2
1904:FreeRTOS/Source/queue.c **** 	}
 2358               	.LM281:
 2359               	/* #NOAPP */
 2360 07e6 FC01      		movw r30,r24
 2361 07e8 828D      		ldd r24,Z+26
1906:FreeRTOS/Source/queue.c **** 
 2363               	.LM282:
 2364               	/* #APP */
 2365               	 ;  1906 "FreeRTOS/Source/queue.c" 1
 2366 07ea 0F90      		pop		__tmp_reg__
 2367               	 ;  0 "" 2
 2368               	 ;  1906 "FreeRTOS/Source/queue.c" 1
 2369 07ec 0FBE      		out		__SREG__, __tmp_reg__
 2370               	 ;  0 "" 2
1909:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 2372               	.LM283:
 2373               	/* #NOAPP */
 2374 07ee 0895      		ret
 2379               	.Lscope15:
 2381               		.stabd	78,0,0
 2384               	.global	uxQueueSpacesAvailable
 2386               	uxQueueSpacesAvailable:
 2387               		.stabd	46,0,0
1913:FreeRTOS/Source/queue.c **** UBaseType_t uxReturn;
 2389               	.LM284:
 2390               	.LFBB16:
 2391               	/* prologue: function */
 2392               	/* frame size = 0 */
 2393               	/* stack size = 0 */
 2394               	.L__stack_usage = 0
1920:FreeRTOS/Source/queue.c **** 	{
 2396               	.LM285:
 2397               	/* #APP */
 2398               	 ;  1920 "FreeRTOS/Source/queue.c" 1
 2399 07f0 0FB6      		in		__tmp_reg__, __SREG__
 2400               	 ;  0 "" 2
 2401               	 ;  1920 "FreeRTOS/Source/queue.c" 1
 2402 07f2 F894      		cli
 2403               	 ;  0 "" 2
 2404               	 ;  1920 "FreeRTOS/Source/queue.c" 1
 2405 07f4 0F92      		push	__tmp_reg__
 2406               	 ;  0 "" 2
1922:FreeRTOS/Source/queue.c **** 	}
 2408               	.LM286:
 2409               	/* #NOAPP */
 2410 07f6 FC01      		movw r30,r24
 2411 07f8 228D      		ldd r18,Z+26
1924:FreeRTOS/Source/queue.c **** 
 2413               	.LM287:
 2414               	/* #APP */
 2415               	 ;  1924 "FreeRTOS/Source/queue.c" 1
 2416 07fa 0F90      		pop		__tmp_reg__
 2417               	 ;  0 "" 2
 2418               	 ;  1924 "FreeRTOS/Source/queue.c" 1
 2419 07fc 0FBE      		out		__SREG__, __tmp_reg__
 2420               	 ;  0 "" 2
1922:FreeRTOS/Source/queue.c **** 	}
 2422               	.LM288:
 2423               	/* #NOAPP */
 2424 07fe 838D      		ldd r24,Z+27
1927:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 2426               	.LM289:
 2427 0800 821B      		sub r24,r18
 2428 0802 0895      		ret
 2430               	.Lscope16:
 2432               		.stabd	78,0,0
 2435               	.global	uxQueueMessagesWaitingFromISR
 2437               	uxQueueMessagesWaitingFromISR:
 2438               		.stabd	46,0,0
1931:FreeRTOS/Source/queue.c **** UBaseType_t uxReturn;
 2440               	.LM290:
 2441               	.LFBB17:
 2442               	/* prologue: function */
 2443               	/* frame size = 0 */
 2444               	/* stack size = 0 */
 2445               	.L__stack_usage = 0
1936:FreeRTOS/Source/queue.c **** 
 2447               	.LM291:
 2448 0804 FC01      		movw r30,r24
 2449 0806 828D      		ldd r24,Z+26
1939:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 2451               	.LM292:
 2452 0808 0895      		ret
 2457               	.Lscope17:
 2459               		.stabd	78,0,0
 2462               	.global	vQueueDelete
 2464               	vQueueDelete:
 2465               		.stabd	46,0,0
1943:FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 2467               	.LM293:
 2468               	.LFBB18:
 2469               	/* prologue: function */
 2470               	/* frame size = 0 */
 2471               	/* stack size = 0 */
 2472               	.L__stack_usage = 0
1959:FreeRTOS/Source/queue.c **** 	}
 2474               	.LM294:
 2475 080a 0C94 0000 		jmp vPortFree
 2477               	.Lscope18:
 2479               		.stabd	78,0,0
 2482               	.global	xQueueIsQueueEmptyFromISR
 2484               	xQueueIsQueueEmptyFromISR:
 2485               		.stabd	46,0,0
2280:FreeRTOS/Source/queue.c **** BaseType_t xReturn;
 2487               	.LM295:
 2488               	.LFBB19:
 2489               	/* prologue: function */
 2490               	/* frame size = 0 */
 2491               	/* stack size = 0 */
 2492               	.L__stack_usage = 0
2284:FreeRTOS/Source/queue.c **** 	{
 2494               	.LM296:
 2495 080e FC01      		movw r30,r24
 2496 0810 928D      		ldd r25,Z+26
 2497 0812 81E0      		ldi r24,lo8(1)
 2498 0814 9111      		cpse r25,__zero_reg__
 2499 0816 80E0      		ldi r24,0
 2500               	.L194:
2294:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 2502               	.LM297:
 2503 0818 0895      		ret
 2505               	.Lscope19:
 2507               		.stabd	78,0,0
 2510               	.global	xQueueIsQueueFullFromISR
 2512               	xQueueIsQueueFullFromISR:
 2513               		.stabd	46,0,0
2313:FreeRTOS/Source/queue.c **** 
2314:FreeRTOS/Source/queue.c **** 	return xReturn;
2315:FreeRTOS/Source/queue.c **** }
2316:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2317:FreeRTOS/Source/queue.c **** 
2318:FreeRTOS/Source/queue.c **** BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
2319:FreeRTOS/Source/queue.c **** {
 2515               	.LM298:
 2516               	.LFBB20:
 2517               	/* prologue: function */
 2518               	/* frame size = 0 */
 2519               	/* stack size = 0 */
 2520               	.L__stack_usage = 0
 2521 081a FC01      		movw r30,r24
2320:FreeRTOS/Source/queue.c **** BaseType_t xReturn;
2321:FreeRTOS/Source/queue.c **** 
2322:FreeRTOS/Source/queue.c **** 	configASSERT( xQueue );
2323:FreeRTOS/Source/queue.c **** 	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( ( Queue_t * ) xQueue )->uxLength )
 2523               	.LM299:
 2524 081c 228D      		ldd r18,Z+26
 2525 081e 81E0      		ldi r24,lo8(1)
 2526 0820 938D      		ldd r25,Z+27
 2527 0822 2913      		cpse r18,r25
 2528 0824 80E0      		ldi r24,0
 2529               	.L199:
2324:FreeRTOS/Source/queue.c **** 	{
2325:FreeRTOS/Source/queue.c **** 		xReturn = pdTRUE;
2326:FreeRTOS/Source/queue.c **** 	}
2327:FreeRTOS/Source/queue.c **** 	else
2328:FreeRTOS/Source/queue.c **** 	{
2329:FreeRTOS/Source/queue.c **** 		xReturn = pdFALSE;
2330:FreeRTOS/Source/queue.c **** 	}
2331:FreeRTOS/Source/queue.c **** 
2332:FreeRTOS/Source/queue.c **** 	return xReturn;
2333:FreeRTOS/Source/queue.c **** } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 2531               	.LM300:
 2532 0826 0895      		ret
 2534               	.Lscope20:
 2536               		.stabd	78,0,0
 2541               	.global	xQueueCRSend
 2543               	xQueueCRSend:
 2544               		.stabd	46,0,0
2334:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2335:FreeRTOS/Source/queue.c **** 
2336:FreeRTOS/Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
2337:FreeRTOS/Source/queue.c **** 
2338:FreeRTOS/Source/queue.c **** 	BaseType_t xQueueCRSend( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait 
2339:FreeRTOS/Source/queue.c **** 	{
 2546               	.LM301:
 2547               	.LFBB21:
 2548 0828 CF93      		push r28
 2549 082a DF93      		push r29
 2550               	/* prologue: function */
 2551               	/* frame size = 0 */
 2552               	/* stack size = 2 */
 2553               	.L__stack_usage = 2
 2554 082c EC01      		movw r28,r24
2340:FreeRTOS/Source/queue.c **** 	BaseType_t xReturn;
2341:FreeRTOS/Source/queue.c **** 	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
2342:FreeRTOS/Source/queue.c **** 
2343:FreeRTOS/Source/queue.c **** 		/* If the queue is already full we may have to block.  A critical section
2344:FreeRTOS/Source/queue.c **** 		is required to prevent an interrupt removing something from the queue
2345:FreeRTOS/Source/queue.c **** 		between the check to see if the queue is full and blocking on the queue. */
2346:FreeRTOS/Source/queue.c **** 		portDISABLE_INTERRUPTS();
 2556               	.LM302:
 2557               	/* #APP */
 2558               	 ;  2346 "FreeRTOS/Source/queue.c" 1
 2559 082e F894      		cli
 2560               	 ;  0 "" 2
 2561               	/* #NOAPP */
 2562               	.LBB24:
 2563               	.LBB25:
2301:FreeRTOS/Source/queue.c **** 	{
 2565               	.LM303:
 2566               	/* #APP */
 2567               	 ;  2301 "FreeRTOS/Source/queue.c" 1
 2568 0830 0FB6      		in		__tmp_reg__, __SREG__
 2569               	 ;  0 "" 2
 2570               	 ;  2301 "FreeRTOS/Source/queue.c" 1
 2571 0832 F894      		cli
 2572               	 ;  0 "" 2
 2573               	 ;  2301 "FreeRTOS/Source/queue.c" 1
 2574 0834 0F92      		push	__tmp_reg__
 2575               	 ;  0 "" 2
2303:FreeRTOS/Source/queue.c **** 		{
 2577               	.LM304:
 2578               	/* #NOAPP */
 2579 0836 8A8D      		ldd r24,Y+26
 2580 0838 9B8D      		ldd r25,Y+27
2312:FreeRTOS/Source/queue.c **** 
 2582               	.LM305:
 2583               	/* #APP */
 2584               	 ;  2312 "FreeRTOS/Source/queue.c" 1
 2585 083a 0F90      		pop		__tmp_reg__
 2586               	 ;  0 "" 2
 2587               	 ;  2312 "FreeRTOS/Source/queue.c" 1
 2588 083c 0FBE      		out		__SREG__, __tmp_reg__
 2589               	 ;  0 "" 2
 2590               	/* #NOAPP */
 2591               	.LBE25:
 2592               	.LBE24:
2347:FreeRTOS/Source/queue.c **** 		{
2348:FreeRTOS/Source/queue.c **** 			if( prvIsQueueFull( pxQueue ) != pdFALSE )
 2594               	.LM306:
 2595 083e 8913      		cpse r24,r25
 2596 0840 00C0      		rjmp .L201
2349:FreeRTOS/Source/queue.c **** 			{
2350:FreeRTOS/Source/queue.c **** 				/* The queue is full - do we want to block or just leave without
2351:FreeRTOS/Source/queue.c **** 				posting? */
2352:FreeRTOS/Source/queue.c **** 				if( xTicksToWait > ( TickType_t ) 0 )
 2598               	.LM307:
 2599 0842 4115      		cp r20,__zero_reg__
 2600 0844 5105      		cpc r21,__zero_reg__
 2601 0846 01F0      		breq .L202
2353:FreeRTOS/Source/queue.c **** 				{
2354:FreeRTOS/Source/queue.c **** 					/* As this is called from a coroutine we cannot block directly, but
2355:FreeRTOS/Source/queue.c **** 					return indicating that we need to block. */
2356:FreeRTOS/Source/queue.c **** 					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
 2603               	.LM308:
 2604 0848 BE01      		movw r22,r28
 2605 084a 685F      		subi r22,-8
 2606 084c 7F4F      		sbci r23,-1
 2607 084e CA01      		movw r24,r20
 2608 0850 0E94 0000 		call vCoRoutineAddToDelayedList
2357:FreeRTOS/Source/queue.c **** 					portENABLE_INTERRUPTS();
 2610               	.LM309:
 2611               	/* #APP */
 2612               	 ;  2357 "FreeRTOS/Source/queue.c" 1
 2613 0854 7894      		sei
 2614               	 ;  0 "" 2
2358:FreeRTOS/Source/queue.c **** 					return errQUEUE_BLOCKED;
 2616               	.LM310:
 2617               	/* #NOAPP */
 2618 0856 8CEF      		ldi r24,lo8(-4)
 2619 0858 00C0      		rjmp .L203
 2620               	.L202:
2359:FreeRTOS/Source/queue.c **** 				}
2360:FreeRTOS/Source/queue.c **** 				else
2361:FreeRTOS/Source/queue.c **** 				{
2362:FreeRTOS/Source/queue.c **** 					portENABLE_INTERRUPTS();
 2622               	.LM311:
 2623               	/* #APP */
 2624               	 ;  2362 "FreeRTOS/Source/queue.c" 1
 2625 085a 7894      		sei
 2626               	 ;  0 "" 2
2363:FreeRTOS/Source/queue.c **** 					return errQUEUE_FULL;
 2628               	.LM312:
 2629               	/* #NOAPP */
 2630 085c 80E0      		ldi r24,0
 2631 085e 00C0      		rjmp .L203
 2632               	.L201:
2364:FreeRTOS/Source/queue.c **** 				}
2365:FreeRTOS/Source/queue.c **** 			}
2366:FreeRTOS/Source/queue.c **** 		}
2367:FreeRTOS/Source/queue.c **** 		portENABLE_INTERRUPTS();
 2634               	.LM313:
 2635               	/* #APP */
 2636               	 ;  2367 "FreeRTOS/Source/queue.c" 1
 2637 0860 7894      		sei
 2638               	 ;  0 "" 2
2368:FreeRTOS/Source/queue.c **** 
2369:FreeRTOS/Source/queue.c **** 		portDISABLE_INTERRUPTS();
 2640               	.LM314:
 2641               	 ;  2369 "FreeRTOS/Source/queue.c" 1
 2642 0862 F894      		cli
 2643               	 ;  0 "" 2
2370:FreeRTOS/Source/queue.c **** 		{
2371:FreeRTOS/Source/queue.c **** 			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 2645               	.LM315:
 2646               	/* #NOAPP */
 2647 0864 8A8D      		ldd r24,Y+26
 2648 0866 8917      		cp r24,r25
 2649 0868 00F4      		brsh .L207
2372:FreeRTOS/Source/queue.c **** 			{
2373:FreeRTOS/Source/queue.c **** 				/* There is room in the queue, copy the data into the queue. */
2374:FreeRTOS/Source/queue.c **** 				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
 2651               	.LM316:
 2652 086a 40E0      		ldi r20,0
 2653 086c CE01      		movw r24,r28
 2654 086e 0E94 0000 		call prvCopyDataToQueue
2375:FreeRTOS/Source/queue.c **** 				xReturn = pdPASS;
2376:FreeRTOS/Source/queue.c **** 
2377:FreeRTOS/Source/queue.c **** 				/* Were any co-routines waiting for data to become available? */
2378:FreeRTOS/Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 2656               	.LM317:
 2657 0872 8989      		ldd r24,Y+17
 2658 0874 8111      		cpse r24,__zero_reg__
 2659 0876 00C0      		rjmp .L205
 2660               	.L206:
2375:FreeRTOS/Source/queue.c **** 				xReturn = pdPASS;
 2662               	.LM318:
 2663 0878 81E0      		ldi r24,lo8(1)
 2664 087a 00C0      		rjmp .L204
 2665               	.L205:
2379:FreeRTOS/Source/queue.c **** 				{
2380:FreeRTOS/Source/queue.c **** 					/* In this instance the co-routine could be placed directly
2381:FreeRTOS/Source/queue.c **** 					into the ready list as we are within a critical section.
2382:FreeRTOS/Source/queue.c **** 					Instead the same pending ready list mechanism is used as if
2383:FreeRTOS/Source/queue.c **** 					the event were caused from within an interrupt. */
2384:FreeRTOS/Source/queue.c **** 					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 2667               	.LM319:
 2668 087c CE01      		movw r24,r28
 2669 087e 4196      		adiw r24,17
 2670 0880 0E94 0000 		call xCoRoutineRemoveFromEventList
 2671 0884 8823      		tst r24
 2672 0886 01F0      		breq .L206
2385:FreeRTOS/Source/queue.c **** 					{
2386:FreeRTOS/Source/queue.c **** 						/* The co-routine waiting has a higher priority so record
2387:FreeRTOS/Source/queue.c **** 						that a yield might be appropriate. */
2388:FreeRTOS/Source/queue.c **** 						xReturn = errQUEUE_YIELD;
 2674               	.LM320:
 2675 0888 8BEF      		ldi r24,lo8(-5)
 2676 088a 00C0      		rjmp .L204
 2677               	.L207:
2389:FreeRTOS/Source/queue.c **** 					}
2390:FreeRTOS/Source/queue.c **** 					else
2391:FreeRTOS/Source/queue.c **** 					{
2392:FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
2393:FreeRTOS/Source/queue.c **** 					}
2394:FreeRTOS/Source/queue.c **** 				}
2395:FreeRTOS/Source/queue.c **** 				else
2396:FreeRTOS/Source/queue.c **** 				{
2397:FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2398:FreeRTOS/Source/queue.c **** 				}
2399:FreeRTOS/Source/queue.c **** 			}
2400:FreeRTOS/Source/queue.c **** 			else
2401:FreeRTOS/Source/queue.c **** 			{
2402:FreeRTOS/Source/queue.c **** 				xReturn = errQUEUE_FULL;
 2679               	.LM321:
 2680 088c 80E0      		ldi r24,0
 2681               	.L204:
2403:FreeRTOS/Source/queue.c **** 			}
2404:FreeRTOS/Source/queue.c **** 		}
2405:FreeRTOS/Source/queue.c **** 		portENABLE_INTERRUPTS();
 2683               	.LM322:
 2684               	/* #APP */
 2685               	 ;  2405 "FreeRTOS/Source/queue.c" 1
 2686 088e 7894      		sei
 2687               	 ;  0 "" 2
 2688               	/* #NOAPP */
 2689               	.L203:
 2690               	/* epilogue start */
2406:FreeRTOS/Source/queue.c **** 
2407:FreeRTOS/Source/queue.c **** 		return xReturn;
2408:FreeRTOS/Source/queue.c **** 	}
 2692               	.LM323:
 2693 0890 DF91      		pop r29
 2694 0892 CF91      		pop r28
 2695 0894 0895      		ret
 2700               	.Lscope21:
 2702               		.stabd	78,0,0
 2707               	.global	xQueueCRReceive
 2709               	xQueueCRReceive:
 2710               		.stabd	46,0,0
2409:FreeRTOS/Source/queue.c **** 
2410:FreeRTOS/Source/queue.c **** #endif /* configUSE_CO_ROUTINES */
2411:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2412:FreeRTOS/Source/queue.c **** 
2413:FreeRTOS/Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
2414:FreeRTOS/Source/queue.c **** 
2415:FreeRTOS/Source/queue.c **** 	BaseType_t xQueueCRReceive( QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait )
2416:FreeRTOS/Source/queue.c **** 	{
 2712               	.LM324:
 2713               	.LFBB22:
 2714 0896 CF93      		push r28
 2715 0898 DF93      		push r29
 2716               	/* prologue: function */
 2717               	/* frame size = 0 */
 2718               	/* stack size = 2 */
 2719               	.L__stack_usage = 2
 2720 089a EC01      		movw r28,r24
 2721 089c FB01      		movw r30,r22
2417:FreeRTOS/Source/queue.c **** 	BaseType_t xReturn;
2418:FreeRTOS/Source/queue.c **** 	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
2419:FreeRTOS/Source/queue.c **** 
2420:FreeRTOS/Source/queue.c **** 		/* If the queue is already empty we may have to block.  A critical section
2421:FreeRTOS/Source/queue.c **** 		is required to prevent an interrupt adding something to the queue
2422:FreeRTOS/Source/queue.c **** 		between the check to see if the queue is empty and blocking on the queue. */
2423:FreeRTOS/Source/queue.c **** 		portDISABLE_INTERRUPTS();
 2723               	.LM325:
 2724               	/* #APP */
 2725               	 ;  2423 "FreeRTOS/Source/queue.c" 1
 2726 089e F894      		cli
 2727               	 ;  0 "" 2
2424:FreeRTOS/Source/queue.c **** 		{
2425:FreeRTOS/Source/queue.c **** 			if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
 2729               	.LM326:
 2730               	/* #NOAPP */
 2731 08a0 8A8D      		ldd r24,Y+26
 2732 08a2 8111      		cpse r24,__zero_reg__
 2733 08a4 00C0      		rjmp .L212
2426:FreeRTOS/Source/queue.c **** 			{
2427:FreeRTOS/Source/queue.c **** 				/* There are no messages in the queue, do we want to block or just
2428:FreeRTOS/Source/queue.c **** 				leave with nothing? */
2429:FreeRTOS/Source/queue.c **** 				if( xTicksToWait > ( TickType_t ) 0 )
 2735               	.LM327:
 2736 08a6 4115      		cp r20,__zero_reg__
 2737 08a8 5105      		cpc r21,__zero_reg__
 2738 08aa 01F0      		breq .L213
2430:FreeRTOS/Source/queue.c **** 				{
2431:FreeRTOS/Source/queue.c **** 					/* As this is a co-routine we cannot block directly, but return
2432:FreeRTOS/Source/queue.c **** 					indicating that we need to block. */
2433:FreeRTOS/Source/queue.c **** 					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
 2740               	.LM328:
 2741 08ac BE01      		movw r22,r28
 2742 08ae 6F5E      		subi r22,-17
 2743 08b0 7F4F      		sbci r23,-1
 2744 08b2 CA01      		movw r24,r20
 2745 08b4 0E94 0000 		call vCoRoutineAddToDelayedList
2434:FreeRTOS/Source/queue.c **** 					portENABLE_INTERRUPTS();
 2747               	.LM329:
 2748               	/* #APP */
 2749               	 ;  2434 "FreeRTOS/Source/queue.c" 1
 2750 08b8 7894      		sei
 2751               	 ;  0 "" 2
2435:FreeRTOS/Source/queue.c **** 					return errQUEUE_BLOCKED;
 2753               	.LM330:
 2754               	/* #NOAPP */
 2755 08ba 8CEF      		ldi r24,lo8(-4)
 2756 08bc 00C0      		rjmp .L214
 2757               	.L213:
2436:FreeRTOS/Source/queue.c **** 				}
2437:FreeRTOS/Source/queue.c **** 				else
2438:FreeRTOS/Source/queue.c **** 				{
2439:FreeRTOS/Source/queue.c **** 					portENABLE_INTERRUPTS();
 2759               	.LM331:
 2760               	/* #APP */
 2761               	 ;  2439 "FreeRTOS/Source/queue.c" 1
 2762 08be 7894      		sei
 2763               	 ;  0 "" 2
2440:FreeRTOS/Source/queue.c **** 					return errQUEUE_FULL;
 2765               	.LM332:
 2766               	/* #NOAPP */
 2767 08c0 80E0      		ldi r24,0
 2768 08c2 00C0      		rjmp .L214
 2769               	.L212:
2441:FreeRTOS/Source/queue.c **** 				}
2442:FreeRTOS/Source/queue.c **** 			}
2443:FreeRTOS/Source/queue.c **** 			else
2444:FreeRTOS/Source/queue.c **** 			{
2445:FreeRTOS/Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2446:FreeRTOS/Source/queue.c **** 			}
2447:FreeRTOS/Source/queue.c **** 		}
2448:FreeRTOS/Source/queue.c **** 		portENABLE_INTERRUPTS();
 2771               	.LM333:
 2772               	/* #APP */
 2773               	 ;  2448 "FreeRTOS/Source/queue.c" 1
 2774 08c4 7894      		sei
 2775               	 ;  0 "" 2
2449:FreeRTOS/Source/queue.c **** 
2450:FreeRTOS/Source/queue.c **** 		portDISABLE_INTERRUPTS();
 2777               	.LM334:
 2778               	 ;  2450 "FreeRTOS/Source/queue.c" 1
 2779 08c6 F894      		cli
 2780               	 ;  0 "" 2
2451:FreeRTOS/Source/queue.c **** 		{
2452:FreeRTOS/Source/queue.c **** 			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
 2782               	.LM335:
 2783               	/* #NOAPP */
 2784 08c8 8A8D      		ldd r24,Y+26
 2785 08ca 8823      		tst r24
 2786 08cc 01F0      		breq .L219
2453:FreeRTOS/Source/queue.c **** 			{
2454:FreeRTOS/Source/queue.c **** 				/* Data is available from the queue. */
2455:FreeRTOS/Source/queue.c **** 				pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
 2788               	.LM336:
 2789 08ce 4C8D      		ldd r20,Y+28
 2790 08d0 50E0      		ldi r21,0
 2791 08d2 2E81      		ldd r18,Y+6
 2792 08d4 3F81      		ldd r19,Y+7
 2793 08d6 240F      		add r18,r20
 2794 08d8 351F      		adc r19,r21
 2795 08da 3F83      		std Y+7,r19
 2796 08dc 2E83      		std Y+6,r18
2456:FreeRTOS/Source/queue.c **** 				if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
 2798               	.LM337:
 2799 08de 8A81      		ldd r24,Y+2
 2800 08e0 9B81      		ldd r25,Y+3
 2801 08e2 2817      		cp r18,r24
 2802 08e4 3907      		cpc r19,r25
 2803 08e6 00F0      		brlo .L216
2457:FreeRTOS/Source/queue.c **** 				{
2458:FreeRTOS/Source/queue.c **** 					pxQueue->u.pcReadFrom = pxQueue->pcHead;
 2805               	.LM338:
 2806 08e8 8881      		ld r24,Y
 2807 08ea 9981      		ldd r25,Y+1
 2808 08ec 9F83      		std Y+7,r25
 2809 08ee 8E83      		std Y+6,r24
 2810               	.L216:
2459:FreeRTOS/Source/queue.c **** 				}
2460:FreeRTOS/Source/queue.c **** 				else
2461:FreeRTOS/Source/queue.c **** 				{
2462:FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2463:FreeRTOS/Source/queue.c **** 				}
2464:FreeRTOS/Source/queue.c **** 				--( pxQueue->uxMessagesWaiting );
 2812               	.LM339:
 2813 08f0 9A8D      		ldd r25,Y+26
 2814 08f2 9150      		subi r25,lo8(-(-1))
 2815 08f4 9A8F      		std Y+26,r25
2465:FreeRTOS/Source/queue.c **** 				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->u
 2817               	.LM340:
 2818 08f6 6E81      		ldd r22,Y+6
 2819 08f8 7F81      		ldd r23,Y+7
 2820 08fa CF01      		movw r24,r30
 2821 08fc 0E94 0000 		call memcpy
2466:FreeRTOS/Source/queue.c **** 
2467:FreeRTOS/Source/queue.c **** 				xReturn = pdPASS;
2468:FreeRTOS/Source/queue.c **** 
2469:FreeRTOS/Source/queue.c **** 				/* Were any co-routines waiting for space to become available? */
2470:FreeRTOS/Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 2823               	.LM341:
 2824 0900 8885      		ldd r24,Y+8
 2825 0902 8111      		cpse r24,__zero_reg__
 2826 0904 00C0      		rjmp .L217
 2827               	.L218:
2467:FreeRTOS/Source/queue.c **** 
 2829               	.LM342:
 2830 0906 81E0      		ldi r24,lo8(1)
 2831 0908 00C0      		rjmp .L215
 2832               	.L217:
2471:FreeRTOS/Source/queue.c **** 				{
2472:FreeRTOS/Source/queue.c **** 					/* In this instance the co-routine could be placed directly
2473:FreeRTOS/Source/queue.c **** 					into the ready list as we are within a critical section.
2474:FreeRTOS/Source/queue.c **** 					Instead the same pending ready list mechanism is used as if
2475:FreeRTOS/Source/queue.c **** 					the event were caused from within an interrupt. */
2476:FreeRTOS/Source/queue.c **** 					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 2834               	.LM343:
 2835 090a CE01      		movw r24,r28
 2836 090c 0896      		adiw r24,8
 2837 090e 0E94 0000 		call xCoRoutineRemoveFromEventList
 2838 0912 8823      		tst r24
 2839 0914 01F0      		breq .L218
2477:FreeRTOS/Source/queue.c **** 					{
2478:FreeRTOS/Source/queue.c **** 						xReturn = errQUEUE_YIELD;
 2841               	.LM344:
 2842 0916 8BEF      		ldi r24,lo8(-5)
 2843 0918 00C0      		rjmp .L215
 2844               	.L219:
2479:FreeRTOS/Source/queue.c **** 					}
2480:FreeRTOS/Source/queue.c **** 					else
2481:FreeRTOS/Source/queue.c **** 					{
2482:FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
2483:FreeRTOS/Source/queue.c **** 					}
2484:FreeRTOS/Source/queue.c **** 				}
2485:FreeRTOS/Source/queue.c **** 				else
2486:FreeRTOS/Source/queue.c **** 				{
2487:FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2488:FreeRTOS/Source/queue.c **** 				}
2489:FreeRTOS/Source/queue.c **** 			}
2490:FreeRTOS/Source/queue.c **** 			else
2491:FreeRTOS/Source/queue.c **** 			{
2492:FreeRTOS/Source/queue.c **** 				xReturn = pdFAIL;
 2846               	.LM345:
 2847 091a 80E0      		ldi r24,0
 2848               	.L215:
2493:FreeRTOS/Source/queue.c **** 			}
2494:FreeRTOS/Source/queue.c **** 		}
2495:FreeRTOS/Source/queue.c **** 		portENABLE_INTERRUPTS();
 2850               	.LM346:
 2851               	/* #APP */
 2852               	 ;  2495 "FreeRTOS/Source/queue.c" 1
 2853 091c 7894      		sei
 2854               	 ;  0 "" 2
 2855               	/* #NOAPP */
 2856               	.L214:
 2857               	/* epilogue start */
2496:FreeRTOS/Source/queue.c **** 
2497:FreeRTOS/Source/queue.c **** 		return xReturn;
2498:FreeRTOS/Source/queue.c **** 	}
 2859               	.LM347:
 2860 091e DF91      		pop r29
 2861 0920 CF91      		pop r28
 2862 0922 0895      		ret
 2867               	.Lscope22:
 2869               		.stabd	78,0,0
 2874               	.global	xQueueCRSendFromISR
 2876               	xQueueCRSendFromISR:
 2877               		.stabd	46,0,0
2499:FreeRTOS/Source/queue.c **** 
2500:FreeRTOS/Source/queue.c **** #endif /* configUSE_CO_ROUTINES */
2501:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2502:FreeRTOS/Source/queue.c **** 
2503:FreeRTOS/Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
2504:FreeRTOS/Source/queue.c **** 
2505:FreeRTOS/Source/queue.c **** 	BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t xCoRou
2506:FreeRTOS/Source/queue.c **** 	{
 2879               	.LM348:
 2880               	.LFBB23:
 2881 0924 0F93      		push r16
 2882 0926 1F93      		push r17
 2883 0928 CF93      		push r28
 2884               	/* prologue: function */
 2885               	/* frame size = 0 */
 2886               	/* stack size = 3 */
 2887               	.L__stack_usage = 3
 2888 092a 8C01      		movw r16,r24
 2889 092c C42F      		mov r28,r20
2507:FreeRTOS/Source/queue.c **** 	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
2508:FreeRTOS/Source/queue.c **** 
2509:FreeRTOS/Source/queue.c **** 		/* Cannot block within an ISR so if there is no space on the queue then
2510:FreeRTOS/Source/queue.c **** 		exit without doing anything. */
2511:FreeRTOS/Source/queue.c **** 		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 2891               	.LM349:
 2892 092e FC01      		movw r30,r24
 2893 0930 928D      		ldd r25,Z+26
 2894 0932 838D      		ldd r24,Z+27
 2895 0934 9817      		cp r25,r24
 2896 0936 00F0      		brlo .L224
 2897               	.L226:
 2898 0938 4C2F      		mov r20,r28
 2899 093a 00C0      		rjmp .L225
 2900               	.L224:
2512:FreeRTOS/Source/queue.c **** 		{
2513:FreeRTOS/Source/queue.c **** 			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
 2902               	.LM350:
 2903 093c 40E0      		ldi r20,0
 2904 093e C801      		movw r24,r16
 2905 0940 0E94 0000 		call prvCopyDataToQueue
2514:FreeRTOS/Source/queue.c **** 
2515:FreeRTOS/Source/queue.c **** 			/* We only want to wake one co-routine per ISR, so check that a
2516:FreeRTOS/Source/queue.c **** 			co-routine has not already been woken. */
2517:FreeRTOS/Source/queue.c **** 			if( xCoRoutinePreviouslyWoken == pdFALSE )
 2907               	.LM351:
 2908 0944 C111      		cpse r28,__zero_reg__
 2909 0946 00C0      		rjmp .L226
2518:FreeRTOS/Source/queue.c **** 			{
2519:FreeRTOS/Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 2911               	.LM352:
 2912 0948 F801      		movw r30,r16
 2913 094a 8189      		ldd r24,Z+17
 2914 094c 8823      		tst r24
 2915 094e 01F0      		breq .L228
2520:FreeRTOS/Source/queue.c **** 				{
2521:FreeRTOS/Source/queue.c **** 					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 2917               	.LM353:
 2918 0950 C801      		movw r24,r16
 2919 0952 4196      		adiw r24,17
 2920 0954 0E94 0000 		call xCoRoutineRemoveFromEventList
 2921 0958 41E0      		ldi r20,lo8(1)
 2922 095a 8111      		cpse r24,__zero_reg__
 2923 095c 00C0      		rjmp .L225
 2924               	.L228:
 2925 095e 40E0      		ldi r20,0
 2926               	.L225:
2522:FreeRTOS/Source/queue.c **** 					{
2523:FreeRTOS/Source/queue.c **** 						return pdTRUE;
2524:FreeRTOS/Source/queue.c **** 					}
2525:FreeRTOS/Source/queue.c **** 					else
2526:FreeRTOS/Source/queue.c **** 					{
2527:FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
2528:FreeRTOS/Source/queue.c **** 					}
2529:FreeRTOS/Source/queue.c **** 				}
2530:FreeRTOS/Source/queue.c **** 				else
2531:FreeRTOS/Source/queue.c **** 				{
2532:FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2533:FreeRTOS/Source/queue.c **** 				}
2534:FreeRTOS/Source/queue.c **** 			}
2535:FreeRTOS/Source/queue.c **** 			else
2536:FreeRTOS/Source/queue.c **** 			{
2537:FreeRTOS/Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2538:FreeRTOS/Source/queue.c **** 			}
2539:FreeRTOS/Source/queue.c **** 		}
2540:FreeRTOS/Source/queue.c **** 		else
2541:FreeRTOS/Source/queue.c **** 		{
2542:FreeRTOS/Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
2543:FreeRTOS/Source/queue.c **** 		}
2544:FreeRTOS/Source/queue.c **** 
2545:FreeRTOS/Source/queue.c **** 		return xCoRoutinePreviouslyWoken;
2546:FreeRTOS/Source/queue.c **** 	}
 2928               	.LM354:
 2929 0960 842F      		mov r24,r20
 2930               	/* epilogue start */
 2931 0962 CF91      		pop r28
 2932 0964 1F91      		pop r17
 2933 0966 0F91      		pop r16
 2934 0968 0895      		ret
 2936               	.Lscope23:
 2938               		.stabd	78,0,0
 2943               	.global	xQueueCRReceiveFromISR
 2945               	xQueueCRReceiveFromISR:
 2946               		.stabd	46,0,0
2547:FreeRTOS/Source/queue.c **** 
2548:FreeRTOS/Source/queue.c **** #endif /* configUSE_CO_ROUTINES */
2549:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2550:FreeRTOS/Source/queue.c **** 
2551:FreeRTOS/Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
2552:FreeRTOS/Source/queue.c **** 
2553:FreeRTOS/Source/queue.c **** 	BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxCoRoutineWo
2554:FreeRTOS/Source/queue.c **** 	{
 2948               	.LM355:
 2949               	.LFBB24:
 2950 096a 0F93      		push r16
 2951 096c 1F93      		push r17
 2952 096e CF93      		push r28
 2953 0970 DF93      		push r29
 2954               	/* prologue: function */
 2955               	/* frame size = 0 */
 2956               	/* stack size = 4 */
 2957               	.L__stack_usage = 4
 2958 0972 FC01      		movw r30,r24
2555:FreeRTOS/Source/queue.c **** 	BaseType_t xReturn;
2556:FreeRTOS/Source/queue.c **** 	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
2557:FreeRTOS/Source/queue.c **** 
2558:FreeRTOS/Source/queue.c **** 		/* We cannot block from an ISR, so check there is data available. If
2559:FreeRTOS/Source/queue.c **** 		not then just leave without doing anything. */
2560:FreeRTOS/Source/queue.c **** 		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
 2960               	.LM356:
 2961 0974 828D      		ldd r24,Z+26
 2962 0976 8823      		tst r24
 2963 0978 01F0      		breq .L234
2561:FreeRTOS/Source/queue.c **** 		{
2562:FreeRTOS/Source/queue.c **** 			/* Copy the data from the queue. */
2563:FreeRTOS/Source/queue.c **** 			pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
 2965               	.LM357:
 2966 097a 248D      		ldd r18,Z+28
 2967 097c 30E0      		ldi r19,0
 2968 097e A681      		ldd r26,Z+6
 2969 0980 B781      		ldd r27,Z+7
 2970 0982 A20F      		add r26,r18
 2971 0984 B31F      		adc r27,r19
 2972 0986 B783      		std Z+7,r27
 2973 0988 A683      		std Z+6,r26
2564:FreeRTOS/Source/queue.c **** 			if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
 2975               	.LM358:
 2976 098a 8281      		ldd r24,Z+2
 2977 098c 9381      		ldd r25,Z+3
 2978 098e A817      		cp r26,r24
 2979 0990 B907      		cpc r27,r25
 2980 0992 00F0      		brlo .L231
2565:FreeRTOS/Source/queue.c **** 			{
2566:FreeRTOS/Source/queue.c **** 				pxQueue->u.pcReadFrom = pxQueue->pcHead;
 2982               	.LM359:
 2983 0994 8081      		ld r24,Z
 2984 0996 9181      		ldd r25,Z+1
 2985 0998 9783      		std Z+7,r25
 2986 099a 8683      		std Z+6,r24
 2987               	.L231:
 2988 099c 8A01      		movw r16,r20
 2989 099e CB01      		movw r24,r22
 2990 09a0 EF01      		movw r28,r30
2567:FreeRTOS/Source/queue.c **** 			}
2568:FreeRTOS/Source/queue.c **** 			else
2569:FreeRTOS/Source/queue.c **** 			{
2570:FreeRTOS/Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2571:FreeRTOS/Source/queue.c **** 			}
2572:FreeRTOS/Source/queue.c **** 			--( pxQueue->uxMessagesWaiting );
 2992               	.LM360:
 2993 09a2 428D      		ldd r20,Z+26
 2994 09a4 4150      		subi r20,lo8(-(-1))
 2995 09a6 428F      		std Z+26,r20
2573:FreeRTOS/Source/queue.c **** 			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->ux
 2997               	.LM361:
 2998 09a8 6681      		ldd r22,Z+6
 2999 09aa 7781      		ldd r23,Z+7
 3000 09ac A901      		movw r20,r18
 3001 09ae 0E94 0000 		call memcpy
2574:FreeRTOS/Source/queue.c **** 
2575:FreeRTOS/Source/queue.c **** 			if( ( *pxCoRoutineWoken ) == pdFALSE )
 3003               	.LM362:
 3004 09b2 F801      		movw r30,r16
 3005 09b4 8081      		ld r24,Z
 3006 09b6 8823      		tst r24
 3007 09b8 01F0      		breq .L232
 3008               	.L233:
2576:FreeRTOS/Source/queue.c **** 			{
2577:FreeRTOS/Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
2578:FreeRTOS/Source/queue.c **** 				{
2579:FreeRTOS/Source/queue.c **** 					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
2580:FreeRTOS/Source/queue.c **** 					{
2581:FreeRTOS/Source/queue.c **** 						*pxCoRoutineWoken = pdTRUE;
2582:FreeRTOS/Source/queue.c **** 					}
2583:FreeRTOS/Source/queue.c **** 					else
2584:FreeRTOS/Source/queue.c **** 					{
2585:FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
2586:FreeRTOS/Source/queue.c **** 					}
2587:FreeRTOS/Source/queue.c **** 				}
2588:FreeRTOS/Source/queue.c **** 				else
2589:FreeRTOS/Source/queue.c **** 				{
2590:FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2591:FreeRTOS/Source/queue.c **** 				}
2592:FreeRTOS/Source/queue.c **** 			}
2593:FreeRTOS/Source/queue.c **** 			else
2594:FreeRTOS/Source/queue.c **** 			{
2595:FreeRTOS/Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2596:FreeRTOS/Source/queue.c **** 			}
2597:FreeRTOS/Source/queue.c **** 
2598:FreeRTOS/Source/queue.c **** 			xReturn = pdPASS;
 3010               	.LM363:
 3011 09ba 81E0      		ldi r24,lo8(1)
 3012 09bc 00C0      		rjmp .L230
 3013               	.L232:
2577:FreeRTOS/Source/queue.c **** 				{
 3015               	.LM364:
 3016 09be 8885      		ldd r24,Y+8
 3017 09c0 8823      		tst r24
 3018 09c2 01F0      		breq .L233
2579:FreeRTOS/Source/queue.c **** 					{
 3020               	.LM365:
 3021 09c4 CE01      		movw r24,r28
 3022 09c6 0896      		adiw r24,8
 3023 09c8 0E94 0000 		call xCoRoutineRemoveFromEventList
 3024 09cc 8823      		tst r24
 3025 09ce 01F0      		breq .L233
2581:FreeRTOS/Source/queue.c **** 					}
 3027               	.LM366:
 3028 09d0 81E0      		ldi r24,lo8(1)
 3029 09d2 F801      		movw r30,r16
 3030 09d4 8083      		st Z,r24
 3031 09d6 00C0      		rjmp .L230
 3032               	.L234:
2599:FreeRTOS/Source/queue.c **** 		}
2600:FreeRTOS/Source/queue.c **** 		else
2601:FreeRTOS/Source/queue.c **** 		{
2602:FreeRTOS/Source/queue.c **** 			xReturn = pdFAIL;
 3034               	.LM367:
 3035 09d8 80E0      		ldi r24,0
 3036               	.L230:
 3037               	/* epilogue start */
2603:FreeRTOS/Source/queue.c **** 		}
2604:FreeRTOS/Source/queue.c **** 
2605:FreeRTOS/Source/queue.c **** 		return xReturn;
2606:FreeRTOS/Source/queue.c **** 	}
 3039               	.LM368:
 3040 09da DF91      		pop r29
 3041 09dc CF91      		pop r28
 3042 09de 1F91      		pop r17
 3043 09e0 0F91      		pop r16
 3044 09e2 0895      		ret
 3049               	.Lscope24:
 3051               		.stabd	78,0,0
 3053               	.Letext0:
 3054               		.ident	"GCC: (GNU) 4.9.2"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 queue.c
     /tmp/ccljjCtb.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccljjCtb.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccljjCtb.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccljjCtb.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccljjCtb.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccljjCtb.s:194    .text:0000000000000000 prvIsQueueEmpty
     /tmp/ccljjCtb.s:248    .text:0000000000000016 prvCopyDataToQueue
     /tmp/ccljjCtb.s:375    .text:00000000000000a8 prvCopyDataFromQueue
     /tmp/ccljjCtb.s:428    .text:00000000000000dc prvUnlockQueue
     /tmp/ccljjCtb.s:585    .text:0000000000000158 xQueueGenericReset
     /tmp/ccljjCtb.s:705    .text:00000000000001cc xQueueGenericCreate
     /tmp/ccljjCtb.s:817    .text:0000000000000230 xQueueGenericSend
     /tmp/ccljjCtb.s:1126   .text:000000000000035c xQueueGenericSendFromISR
     /tmp/ccljjCtb.s:1229   .text:00000000000003ba xQueueGiveFromISR
     /tmp/ccljjCtb.s:1326   .text:0000000000000400 xQueueReceive
     /tmp/ccljjCtb.s:1609   .text:0000000000000524 xQueueSemaphoreTake
     /tmp/ccljjCtb.s:1880   .text:0000000000000630 xQueuePeek
     /tmp/ccljjCtb.s:2167   .text:0000000000000754 xQueueReceiveFromISR
     /tmp/ccljjCtb.s:2276   .text:00000000000007b2 xQueuePeekFromISR
     /tmp/ccljjCtb.s:2336   .text:00000000000007e0 uxQueueMessagesWaiting
     /tmp/ccljjCtb.s:2386   .text:00000000000007f0 uxQueueSpacesAvailable
     /tmp/ccljjCtb.s:2437   .text:0000000000000804 uxQueueMessagesWaitingFromISR
     /tmp/ccljjCtb.s:2464   .text:000000000000080a vQueueDelete
     /tmp/ccljjCtb.s:2484   .text:000000000000080e xQueueIsQueueEmptyFromISR
     /tmp/ccljjCtb.s:2512   .text:000000000000081a xQueueIsQueueFullFromISR
     /tmp/ccljjCtb.s:2543   .text:0000000000000828 xQueueCRSend
     /tmp/ccljjCtb.s:2709   .text:0000000000000896 xQueueCRReceive
     /tmp/ccljjCtb.s:2876   .text:0000000000000924 xQueueCRSendFromISR
     /tmp/ccljjCtb.s:2945   .text:000000000000096a xQueueCRReceiveFromISR

UNDEFINED SYMBOLS
memcpy
xTaskRemoveFromEventList
vTaskMissedYield
vPortYield
vListInitialise
pvPortMalloc
vTaskInternalSetTimeOutState
vTaskSuspendAll
xTaskCheckForTimeOut
vTaskPlaceOnEventList
xTaskResumeAll
vPortFree
vCoRoutineAddToDelayedList
xCoRoutineRemoveFromEventList
